diff --git a/arch/arm64/Kconfig.platforms b/arch/arm64/Kconfig.platforms
index 2c5620822895..fb164da6eb00 100644
--- a/arch/arm64/Kconfig.platforms
+++ b/arch/arm64/Kconfig.platforms
@@ -186,6 +186,12 @@ config ARCH_MVEBU
 	   - Armada 7K SoC Family
 	   - Armada 8K SoC Family
 
+config ARCH_PHYTIUM
+	bool "Phytium SoC Family"
+	help
+	  This enables support for Phytium ARMv8 SoC family.
+	select ARM_GIC_PHYTIUM_2500
+
 config ARCH_MXC
 	bool "ARMv8 based NXP i.MX SoC family"
 	select ARM64_ERRATUM_843419
diff --git a/arch/arm64/boot/dts/Makefile b/arch/arm64/boot/dts/Makefile
index cc6c25629057..19e347bbfde8 100644
--- a/arch/arm64/boot/dts/Makefile
+++ b/arch/arm64/boot/dts/Makefile
@@ -19,6 +19,7 @@ subdir-y += marvell
 subdir-y += mediatek
 subdir-y += microchip
 subdir-y += nvidia
+subdir-y += phytium
 subdir-y += qcom
 subdir-y += realtek
 subdir-y += renesas
diff --git a/arch/arm64/boot/dts/phytium/Makefile b/arch/arm64/boot/dts/phytium/Makefile
new file mode 100755
index 000000000000..56f163a61f65
--- /dev/null
+++ b/arch/arm64/boot/dts/phytium/Makefile
@@ -0,0 +1,11 @@
+dtb-$(CONFIG_ARCH_PHYTIUM) += ft2004-devboard-d4-dsk.dtb
+dtb-$(CONFIG_ARCH_PHYTIUM) += ft1500a-devboard-16c-dsk.dtb
+dtb-$(CONFIG_ARCH_PHYTIUM) += ft2000plus-SR-devboard-64c-dsk.dtb
+dtb-$(CONFIG_ARCH_PHYTIUM) += ft2000plus-MR-devboard-64c-dsk.dtb
+dtb-$(CONFIG_ARCH_PHYTIUM) += ft2000ahk-devboard-dsk.dtb
+dtb-$(CONFIG_ARCH_PHYTIUM) += d2000-devboard-dsk.dtb
+dtb-$(CONFIG_ARCH_PHYTIUM) += ft2000ahke-devboard-dsk.dtb
+
+always		:= $(dtb-y)
+subdir-y	:= $(dts-dirs)
+clean-files	:= *.dtb
diff --git a/arch/arm64/boot/dts/phytium/d2000-devboard-dsk.dts b/arch/arm64/boot/dts/phytium/d2000-devboard-dsk.dts
new file mode 100755
index 000000000000..5519213c53e3
--- /dev/null
+++ b/arch/arm64/boot/dts/phytium/d2000-devboard-dsk.dts
@@ -0,0 +1,73 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * DTS file for Phytium D2000 devboard
+ *
+ * Copyright (C) 2020, Phytium Technology Co., Ltd.
+ */
+
+/dts-v1/;
+/memreserve/ 0x80000000 0x10000;
+
+#include "d2000-generic-psci-soc.dtsi"
+
+/{
+	model = "D2000 Development Board";
+	compatible = "phytium,d2000";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	chosen {
+		stdout-path = "uart1:115200n8";
+	};
+
+	memory@00{
+		device_type = "memory";
+		reg = <0x0 0x80000000 0x1 0x00000000>;
+	};
+
+	memory@01{
+		device_type = "memory";
+		reg = <0x20 0x00000000 0x1 0x00000000>;
+	};
+
+	firmware {
+		optee {
+			compatible = "linaro,optee-tz";
+			method = "smc";
+		};
+	};
+};
+
+&rtc0 {
+	status = "ok";
+};
+
+&uart1 {
+	status = "ok";
+};
+
+&gmac0 {
+	status = "ok";
+	phy-mode = "rgmii-txid";
+};
+
+&gmac1 {
+	status = "ok";
+	phy-mode = "rgmii-txid";
+};
+
+&spi0 {
+	status = "ok";
+};
+
+&qspi {
+	status = "ok";
+};
+
+&i2c0 {
+	status = "ok";
+};
+
+&i2c1 {
+	status = "ok";
+};
diff --git a/arch/arm64/boot/dts/phytium/d2000-generic-psci-soc.dtsi b/arch/arm64/boot/dts/phytium/d2000-generic-psci-soc.dtsi
new file mode 100755
index 000000000000..b5efc20cb34f
--- /dev/null
+++ b/arch/arm64/boot/dts/phytium/d2000-generic-psci-soc.dtsi
@@ -0,0 +1,522 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * dts file for Phytium D2000 SoC
+ *
+ * Copyright (C) 2020, Phytium Technology Co., Ltd.
+ */
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+
+/ {
+	compatible = "phytium,d2000";
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	aliases {
+		ethernet0 = &gmac0;
+		ethernet1 = &gmac1;
+	};
+
+	psci {
+		compatible   = "arm,psci-1.0";
+		method       = "smc";
+		cpu_suspend  = <0xc4000001>;
+		cpu_off      = <0x84000002>;
+		cpu_on       = <0xc4000003>;
+		sys_poweroff = <0x84000008>;
+		sys_reset    = <0x84000009>;
+	};
+
+	cpus {
+		#address-cells = <0x2>;
+		#size-cells = <0x0>;
+
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x0>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+			clocks = <&scpi_dvfs 0>;
+		};
+
+		cpu1: cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x1>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+			clocks = <&scpi_dvfs 0>;
+		};
+
+		cpu2: cpu@100 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x100>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+			clocks = <&scpi_dvfs 1>;
+		};
+
+		cpu3: cpu@101 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x101>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+			clocks = <&scpi_dvfs 1>;
+		};
+
+		cpu4: cpu@200 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x200>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+			clocks = <&scpi_dvfs 2>;
+		};
+
+		cpu5: cpu@201 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x201>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+			clocks = <&scpi_dvfs 2>;
+		};
+
+		cpu6: cpu@300 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x300>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+			clocks = <&scpi_dvfs 3>;
+		};
+
+		cpu7: cpu@301 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x301>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+			clocks = <&scpi_dvfs 3>;
+		};
+	};
+
+	gic: interrupt-controller@29900000 {
+		compatible = "arm,gic-v3";
+		#interrupt-cells = <3>;
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		interrupt-controller;
+		reg = <0x0 0x29a00000 0 0x20000>,       /* GICD */
+		      <0x0 0x29b00000 0 0x100000>,      /* GICR */
+		      <0x0 0x29c00000 0 0x10000>,       /* GICC */
+		      <0x0 0x29c10000 0 0x10000>,       /* GICH */
+		      <0x0 0x29c20000 0 0x10000>;       /* GICV */
+		interrupts = <GIC_PPI 9 IRQ_TYPE_LEVEL_HIGH>;
+
+		its: gic-its@29920000 {
+			compatible = "arm,gic-v3-its";
+			msi-controller;
+			reg = <0x0 0x29a20000 0x0 0x20000>;
+		};
+	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		interrupts = <GIC_PPI 13 IRQ_TYPE_LEVEL_LOW>,
+			     <GIC_PPI 14 IRQ_TYPE_LEVEL_LOW>,
+			     <GIC_PPI 11 IRQ_TYPE_LEVEL_LOW>,
+			     <GIC_PPI 10 IRQ_TYPE_LEVEL_LOW>;
+		clock-frequency = <48000000>;
+	};
+
+	pmu {
+		compatible = "arm,armv8-pmuv3";
+		interrupts = <GIC_PPI 7 IRQ_TYPE_LEVEL_LOW>;
+	};
+
+	clocks {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		clk250mhz: clk250mhz {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <250000000>;
+		};
+
+		sysclk_48mhz: clk48mhz {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <48000000>;
+		};
+
+		sysclk_600mhz: clk600mhz {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <600000000>;
+		};
+	};
+
+	soc {
+		compatible = "simple-bus";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		dma-coherent;
+		ranges;
+
+		gpio0: gpio@28004000 {
+			compatible = "phytium,gpio";
+			reg = <0x0 0x28004000 0x0 0x1000>;
+			interrupts = <GIC_SPI 10 IRQ_TYPE_LEVEL_HIGH>;
+			gpio-controller;
+			#gpio-cells = <2>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			porta {
+				compatible = "phytium,gpio-port";
+				reg = <0>;
+				nr-gpios = <8>;
+			};
+
+			portb {
+				compatible = "phytium,gpio-port";
+				reg = <1>;
+				nr-gpios = <8>;
+			};
+		};
+
+		gpio1: gpio@28005000 {
+			compatible = "phytium,gpio";
+			reg = <0x0 0x28005000 0x0 0x1000>;
+			interrupts = <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>;
+			gpio-controller;
+			#gpio-cells = <2>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			porta {
+				compatible = "phytium,gpio-port";
+				reg = <0>;
+				nr-gpios = <8>;
+			};
+
+			portb {
+				compatible = "phytium,gpio-port";
+				reg = <1>;
+				nr-gpios = <8>;
+			};
+		};
+
+		uart0: uart@28000000 {
+			compatible = "arm,pl011", "arm,primecell";
+			reg = <0x0 0x28000000 0x0 0x1000>;
+			baud = <115200>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			interrupts = <GIC_SPI 6 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_48mhz &sysclk_48mhz>;
+			clock-names = "uartclk", "apb_pclk";
+		};
+
+		uart1: uart@28001000 {
+			compatible = "arm,pl011", "arm,primecell";
+			reg = <0x0 0x28001000 0x0 0x1000>;
+			baud = <115200>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			interrupts = <GIC_SPI 7 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_48mhz &sysclk_48mhz>;
+			clock-names = "uartclk", "apb_pclk";
+		};
+
+		uart2: uart@28002000 {
+			compatible = "arm,pl011", "arm,primecell";
+			reg = <0x0 0x28002000 0x0 0x1000>;
+			baud = <115200>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			interrupts = <GIC_SPI 8 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_48mhz &sysclk_48mhz>;
+			clock-names = "uartclk", "apb_pclk";
+		};
+
+		uart3: uart@28003000 {
+			compatible = "arm,pl011", "arm,primecell";
+			reg = <0x0 0x28003000 0x0 0x1000>;
+			baud = <115200>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			interrupts = <GIC_SPI 9 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_48mhz &sysclk_48mhz>;
+			clock-names = "uartclk", "apb_pclk";
+		};
+
+		sdci: sdci@28207c00 {
+			compatible = "phytium,sdci";
+			reg = <0x0 0x28207c00 0x0 0x100>;
+			interrupts = <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 22 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_600mhz &sysclk_600mhz>;
+			clock-names = "phytium_sdc_clk";
+			no-sdio;
+			no-mmc;
+			no-dma-coherent;
+		};
+
+		watchdog0: watchdog@2800a000 {
+			compatible = "arm,sbsa-gwdt";
+			reg = <0x0 0x2800b000 0x0 0x1000>,
+			      <0x0 0x2800a000 0x0 0x1000>;
+			interrupts = <GIC_SPI 16 IRQ_TYPE_LEVEL_HIGH>;
+			timeout-sec = <30>;
+		};
+
+		watchdog1: watchdog@28016000 {
+			compatible = "arm,sbsa-gwdt";
+			reg = <0x0 0x28017000 0x0 0x1000>,
+			      <0x0 0x28016000 0x0 0x1000>;
+			interrupts = <GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH>;
+			timeout-sec = <30>;
+		};
+
+		rtc0: rtc@2800d000 {
+			compatible = "phytium,rtc";
+			reg = <0x0 0x2800d000 0x0 0x1000>;
+			clocks = <&sysclk_48mhz>;
+			clock-names = "rtc_pclk";
+			interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		i2c0: i2c@28006000 {
+			compatible = "snps,designware-i2c";
+			reg = <0x0 0x28006000 0x0 0x1000>;
+			interrupts = <GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_48mhz>;
+			status = "disabled";
+		};
+
+		i2c1: i2c@28007000 {
+			compatible = "snps,designware-i2c";
+			reg = <0x0 0x28007000 0x0 0x1000>;
+			interrupts = <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_48mhz>;
+			status = "disabled";
+		};
+
+		i2c2: i2c@28008000 {
+			compatible = "snps,designware-i2c";
+			reg = <0x0 0x28008000 0x0 0x1000>;
+			interrupts = <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_48mhz>;
+			status = "disabled";
+		};
+
+		i2c3: i2c@28009000 {
+			compatible = "snps,designware-i2c";
+			reg = <0x0 0x28009000 0x0 0x1000>;
+			interrupts = <GIC_SPI 15 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_48mhz>;
+			status = "disabled";
+		};
+
+		spi0: spi@2800c000 {
+			compatible = "phytium,spi";
+			interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>;
+			reg = <0x0 0x2800c000 0x0 0x1000>;
+			clocks = <&sysclk_48mhz>;
+			num-cs = <4>;
+		};
+
+		spi1: spi@28013000 {
+			compatible = "phytium,spi";
+			interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>;
+			reg = <0x0 0x28013000 0x0 0x1000>;
+			clocks = <&sysclk_48mhz>;
+			num-cs = <4>;
+		};
+
+		qspi: qspi@28014000 {
+			compatible = "phytium,qspi";
+			reg = <0x0 0x28014000 0x0     0x1000>,
+			      <0x0        0x0 0x0 0x02000000>;
+			reg-names = "qspi", "qspi_mm";
+			clocks = <&sysclk_600mhz>;
+
+			flash@0 {
+				spi-rx-bus-width = <1>;
+				spi-max-frequency = <600000000>;
+			};
+		};
+
+		phytium_axi_setup: stmmac-axi-config {
+			snps,wr_osr_lmt = <0>;
+			snps,rd_osr_lmt = <0>;
+			snps,blen = <0 0 0 0 16 8 4>;
+		};
+
+		gmac0: eth@2820c000 {
+			compatible = "snps,dwmac";
+			reg = <0x0 0x2820c000 0x0 0x2000>;
+			interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq";
+			clocks = <&clk250mhz>;
+			clock-names = "stmmaceth";
+			status = "disabled";
+
+			snps,pbl = <16>;
+			snps,fixed-burst;
+			snps,axi-config = <&phytium_axi_setup>;
+			snps,force_sf_dma_mode;
+			snps,multicast-filter-bins = <64>;
+			snps,perfect-filter-entries = <128>;
+			tx-fifo-depth = <4096>;
+			rx-fifo-depth = <4096>;
+			max-frame-size = <9000>;
+		};
+
+		gmac1: eth@28210000 {
+			compatible = "snps,dwmac";
+			reg = <0x0 0x28210000 0x0 0x2000>;
+			interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq";
+			clocks = <&clk250mhz>;
+			clock-names = "stmmaceth";
+			status = "disabled";
+
+			snps,pbl = <16>;
+			snps,fixed-burst;
+			snps,axi-config = <&phytium_axi_setup>;
+			snps,force_sf_dma_mode;
+			snps,multicast-filter-bins = <64>;
+			snps,perfect-filter-entries = <128>;
+			snps,rx-queues-to-use = <2>;
+			tx-fifo-depth = <4096>;
+			rx-fifo-depth = <4096>;
+			max-frame-size = <9000>;
+		};
+
+		can0: can@28207000 {
+			compatible = "phytium,can";
+			reg = <0x0 0x28207000 0x0 0x400>;
+			interrupts = <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_600mhz>;
+			clock-names = "phytium_can_clk";
+			tx-fifo-depth = <0x40>;
+			rx-fifo-depth = <0x40>;
+		};
+
+		can1: can@28207400 {
+			compatible = "phytium,can";
+			reg = <0x0 0x28207400 0x0 0x400>;
+			interrupts = <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_600mhz>;
+			clock-names = "phytium_can_clk";
+			tx-fifo-depth = <0x40>;
+			rx-fifo-depth = <0x40>;
+		};
+
+		can2: can@028207800 {
+			compatible = "phytium,can";
+			reg = <0x0 0x28207800 0x0 0x400>;
+			interrupts = <GIC_SPI 92 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_600mhz>;
+			clock-names = "phytium_can_clk";
+			tx-fifo-depth = <0x40>;
+			rx-fifo-depth = <0x40>;
+		};
+
+		hda: hda@28206000 {
+			compatible = "phytium,hda";
+			reg = <0 0x28206000 0x0 0x1000>;
+			interrupts = <GIC_SPI 23 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_48mhz>;
+			clock-names = "phytium_hda_clk";
+		};
+
+		mbox: mailbox@2a000000 {
+			compatible = "phytium,mbox";
+			reg = <0x0 0x2a000000 0x0 0x1000>;
+			interrupts = <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
+			#mbox-cells = <1>;
+			clocks = <&sysclk_48mhz>;
+			clock-names = "apb_pclk";
+		};
+
+		sram: sram@2a006000 {
+			compatible = "phytium,ft2004-sram-ns","mmio-sram";
+			reg = <0x0 0x2a006000 0x0 0x2000>;
+
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x0 0x0 0x2a006000 0x2000>;
+
+			scpi_lpri: scpi-shmem@0 {
+				compatible = "phytium,ft2004-scpi-shmem";
+				reg = <0x1000 0x800>;
+			};
+		};
+
+		scpi_protocol: scpi {
+			compatible = "arm,scpi";
+			mboxes = <&mbox 0>;
+			shmem = <&scpi_lpri>;
+
+			clocks {
+				compatible = "arm,scpi-clocks";
+
+				scpi_dvfs: scpi_clocks@0 {
+					compatible = "arm,scpi-dvfs-clocks";
+					#clock-cells = <1>;
+					clock-indices = <0>, <1>, <2>, <3>;
+					clock-output-names = "c0", "c1", "c2", "c3";
+				};
+			};
+
+			scpi_sensors: sensors {
+				compatible = "arm,scpi-sensors";
+				#thermal-sensor-cells = <1>;
+			};
+		};
+
+		ixic: interrupt-controller@29000000 {
+			compatible = "phytium,d2000-ixic";
+			reg-names = "ctr", "hpb";
+			reg = <0x0 0x29000000 0x0 0x00060000>,
+			      <0x0 0x29100000 0x0 0x00002000>;
+			interrupt-controller;
+			interrupt-parent = <&gic>;
+			#interrupt-cells = <3>;
+			intx-spi-base = <28>;
+		};
+
+		pcie: pcie {
+			compatible = "pci-host-ecam-generic";
+			device_type = "pci";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			#interrupt-cells = <1>;
+			reg = <0x0 0x40000000 0x0 0x10000000>;
+			msi-parent = <&its>;
+			bus-range = <0x0 0xff>;
+			interrupt-map-mask = <0x0 0x0 0x0 0x7>;
+			interrupt-map = <0x0 0x0 0x0 0x1 &ixic GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x2 &ixic GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x3 &ixic GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x4 &ixic GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>;
+			ranges = <0x01000000 0x00 0x00000000 0x0  0x50000000  0x0  0x00f00000>,
+				 <0x02000000 0x00 0x58000000 0x0  0x58000000  0x0  0x28000000>,
+				 <0x03000000 0x10 0x00000000 0x10 0x00000000 0x10  0x00000000>;
+		};
+	};
+
+};
diff --git a/arch/arm64/boot/dts/phytium/ft1500a-16c-generic-psci-soc.dtsi b/arch/arm64/boot/dts/phytium/ft1500a-16c-generic-psci-soc.dtsi
new file mode 100755
index 000000000000..b1e4a9222d5d
--- /dev/null
+++ b/arch/arm64/boot/dts/phytium/ft1500a-16c-generic-psci-soc.dtsi
@@ -0,0 +1,511 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * dts file for FT-1500A SoC
+ *
+ * Copyright (C) 2019, Phytium Technology Co., Ltd.
+ */
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+
+/ {
+	compatible = "phytium,ft1500a";
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	aliases {
+		ethernet0 = &gmac0;
+		ethernet1 = &gmac1;
+	};
+
+	psci {
+		compatible = "arm,psci-1.0", "arm,psci-0.2", "arm,psci";
+		method = "smc";
+		cpu_suspend = <0xc4000001>;
+		cpu_off = <0x84000002>;
+		cpu_on = <0xc4000003>;
+	};
+
+	cpus {
+		#address-cells = <2>;
+		#size-cells = <0>;
+
+		cpu-map {
+			cluster0 {
+				core0 {
+					cpu = <&cpu0>;
+				};
+				core1 {
+					cpu = <&cpu1>;
+				};
+				core2 {
+					cpu = <&cpu2>;
+				};
+				core3 {
+					cpu = <&cpu3>;
+				};
+			};
+
+			cluster1 {
+				core0 {
+					cpu = <&cpu4>;
+				};
+				core1 {
+					cpu = <&cpu5>;
+				};
+				core2 {
+					cpu = <&cpu6>;
+				};
+				core3 {
+					cpu = <&cpu7>;
+				};
+			};
+
+			cluster2 {
+				core0 {
+					cpu = <&cpu8>;
+				};
+				core1 {
+					cpu = <&cpu9>;
+				};
+				core2 {
+					cpu = <&cpu10>;
+				};
+				core3 {
+					cpu = <&cpu11>;
+				};
+			};
+
+			cluster3 {
+				core0 {
+					cpu = <&cpu12>;
+				};
+				core1 {
+					cpu = <&cpu13>;
+				};
+				core2 {
+					cpu = <&cpu14>;
+				};
+				core3 {
+					cpu = <&cpu15>;
+				};
+			};
+		};
+
+		idle-states {
+			entry-method = "arm,psci";
+
+			CPU_SLEEP: cpu-sleep {
+				compatible = "arm,idle-state";
+				local-timer-stop;
+				arm,psci-suspend-param = <0x0010000>;
+				entry-latency-us = <100>;
+				exit-latency-us = <100>;
+				min-residency-us = <200>;
+			};
+		};
+
+		cpu0:cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x000>;
+			enable-method = "psci";
+			cpu-idle-states = <&CPU_SLEEP>;
+			clocks = <&cpuclk 0>;
+			clock-latency = <10000>;
+			cooling-min-level = <0>;	/* cooling options */
+			cooling-max-level = <5>;
+			#cooling-cells = <2>;		/* min followed by max */
+		};
+
+		cpu1:cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x001>;
+			enable-method = "psci";
+			cpu-idle-states = <&CPU_SLEEP>;
+			clocks = <&cpuclk 0>;
+			clock-latency = <10000>;
+		};
+
+		cpu2:cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x002>;
+			enable-method = "psci";
+			cpu-idle-states = <&CPU_SLEEP>;
+			clocks = <&cpuclk 0>;
+			clock-latency = <10000>;
+		};
+
+		cpu3:cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x003>;
+			enable-method = "psci";
+			cpu-idle-states = <&CPU_SLEEP>;
+			clocks = <&cpuclk 0>;
+			clock-latency = <10000>;
+		};
+
+		cpu4:cpu@100 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x100>;
+			enable-method = "psci";
+			cpu-idle-states = <&CPU_SLEEP>;
+			clocks = <&cpuclk 1>;
+			clock-latency = <10000>;
+			cooling-min-level = <0>;	/* cooling options */
+			cooling-max-level = <5>;
+			#cooling-cells = <2>;		/* min followed by max */
+		};
+
+		cpu5:cpu@101 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x101>;
+			enable-method = "psci";
+			cpu-idle-states = <&CPU_SLEEP>;
+			clocks = <&cpuclk 1>;
+			clock-latency = <10000>;
+		};
+
+		cpu6:cpu@102 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x102>;
+			enable-method = "psci";
+			cpu-idle-states = <&CPU_SLEEP>;
+			clocks = <&cpuclk 1>;
+			clock-latency = <10000>;
+		};
+
+		cpu7:cpu@103 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x103>;
+			enable-method = "psci";
+			cpu-idle-states = <&CPU_SLEEP>;
+			clocks = <&cpuclk 1>;
+			clock-latency = <10000>;
+		};
+
+		cpu8:cpu@200 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x200>;
+			enable-method = "psci";
+			cpu-idle-states = <&CPU_SLEEP>;
+			clocks = <&cpuclk 2>;
+			clock-latency = <10000>;
+			cooling-min-level = <0>;	/* cooling options */
+			cooling-max-level = <5>;
+			#cooling-cells = <2>;		/* min followed by max */
+		};
+
+		cpu9:cpu@201 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x201>;
+			enable-method = "psci";
+			cpu-idle-states = <&CPU_SLEEP>;
+			clocks = <&cpuclk 2>;
+			clock-latency = <10000>;
+		};
+
+		cpu10:cpu@202 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x202>;
+			enable-method = "psci";
+			cpu-idle-states = <&CPU_SLEEP>;
+			clocks = <&cpuclk 2>;
+			clock-latency = <10000>;
+		};
+
+		cpu11:cpu@203 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x203>;
+			enable-method = "psci";
+			cpu-idle-states = <&CPU_SLEEP>;
+			clocks = <&cpuclk 2>;
+			clock-latency = <10000>;
+		};
+
+		cpu12:cpu@300 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x300>;
+			enable-method = "psci";
+			cpu-idle-states = <&CPU_SLEEP>;
+			clocks = <&cpuclk 3>;
+			clock-latency = <10000>;
+			cooling-min-level = <0>;	/* cooling options */
+			cooling-max-level = <5>;
+			#cooling-cells = <2>;		/* min followed by max */
+		};
+
+		cpu13:cpu@301 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x301>;
+			enable-method = "psci";
+			cpu-idle-states = <&CPU_SLEEP>;
+			clocks = <&cpuclk 3>;
+			clock-latency = <10000>;
+		};
+
+		cpu14:cpu@302 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x302>;
+			enable-method = "psci";
+			cpu-idle-states = <&CPU_SLEEP>;
+			clocks = <&cpuclk 3>;
+			clock-latency = <10000>;
+		};
+
+		cpu15:cpu@303 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x303>;
+			enable-method = "psci";
+			cpu-idle-states = <&CPU_SLEEP>;
+			clocks = <&cpuclk 3>;
+			clock-latency = <10000>;
+		};
+	};
+
+	gic: interrupt-controller@29800000 {
+		compatible = "arm,gic-v3";
+		#interrupt-cells = <3>;
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		interrupt-controller;
+		reg = <0x0 0x29800000 0 0x10000>,	/* GICD */
+		      <0x0 0x29a00000 0 0x200000>,	/* GICR */
+		      <0x0 0x29c00000 0 0x10000>,	/* GICC */
+		      <0x0 0x29c10000 0 0x10000>,	/* GICH */
+		      <0x0 0x29c20000 0 0x10000>;	/* GICV */
+		interrupts = <GIC_PPI 9 IRQ_TYPE_LEVEL_HIGH>;
+
+		its: gic-its@29820000 {
+			compatible = "arm,gic-v3-its";
+			msi-controller;
+			reg = <0x0 0x29820000 0x0 0x20000>;
+		};
+	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		interrupts = <GIC_PPI 13 IRQ_TYPE_LEVEL_LOW>,
+			     <GIC_PPI 14 IRQ_TYPE_LEVEL_LOW>,
+			     <GIC_PPI 11 IRQ_TYPE_LEVEL_LOW>,
+			     <GIC_PPI 10 IRQ_TYPE_LEVEL_LOW>;
+		clock-frequency = <50000000>;
+	};
+
+	pmu {
+		compatible = "arm,armv8-pmuv3";
+		interrupts = <GIC_PPI 7 IRQ_TYPE_LEVEL_LOW>;
+	};
+
+	clocks {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* 50 MHz reference crystal */
+		refclk: refclk {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <50000000>;
+		};
+
+		clk_100mhz: clk_100mhz {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clocks = <&refclk>;
+			clock-frequency = <100000000>;
+		};
+
+		cpuclk: cpuclk {
+			compatible = "phytium,1500a-cpu-clock";
+			#clock-cells = <1>;
+			reg = <0x0 0x28100600 0x0 0x10>;
+			clocks = <&refclk>;
+			mode = <0x2>; /* 0: do not use pll, 1: partially use pll, 2: totally use pll */
+			/*big-clock;*/
+			clock-output-names = "cluster0-clk",
+					     "cluster1-clk",
+					     "cluster2-clk",
+					     "cluster3-clk";
+		};
+
+		gmacclk: gmacclk {
+			compatible = "phytium,1500a-gmac-clock";
+			#clock-cells = <0>;
+			reg = <0x0 0x2810050c 0x0 0x4>;
+			clocks = <&refclk>;
+			clock-frequency = <500000000>;
+			clock-output-names = "gmac-clk";
+		};
+	};
+
+	soc {
+		compatible = "simple-bus";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		dma-coherent;
+		ranges;
+
+		uart0: serial@28000000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x0 0x28000000 0x0 0x1000>;
+			clock-frequency = <50000000>;
+			interrupts = <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			status = "disabled";
+		};
+
+		uart1: serial@28001000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x0 0x28001000 0x0 0x1000>;
+			clock-frequency = <50000000>;
+			interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			status = "disabled";
+		};
+
+		i2c0: i2c@28002000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "snps,designware-i2c";
+			reg = <0x0 0x28002000 0x0 0x1000>;
+			interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
+			clock-frequency = <100000>;
+			clocks = <&clk_100mhz>;
+			status = "disabled";
+		};
+
+		i2c1: i2c@28003000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "snps,designware-i2c";
+			reg = <0x0 0x28003000 0x0 0x1000>;
+			interrupts = <GIC_SPI 37 IRQ_TYPE_LEVEL_HIGH>;
+			clock-frequency = <100000>;
+			clocks = <&clk_100mhz>;
+			status = "disabled";
+		};
+
+		wdt0: watchdog@28004000 {
+			compatible = "snps,dw-wdt";
+			reg = <0x0 0x28004000 0x0 0x1000>;
+			clocks = <&refclk>;
+			interrupts = <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		wdt1: watchdog@28005000 {
+			compatible = "snps,dw-wdt";
+			reg = <0x0 0x28005000 0x0 0x1000>;
+			clocks = <&refclk>;
+			interrupts = <GIC_SPI 39 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		gpio: gpio@28006000 {
+			compatible = "snps,dw-apb-gpio";
+			reg = <0x0 0x28006000 0x0 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+			porta: gpio-controller@0 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <8>;
+				reg = <0>;
+			};
+			portb: gpio-controller@1 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <8>;
+				reg = <1>;
+			};
+			portc: gpio-controller@2 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <8>;
+				reg = <2>;
+			};
+			portd: gpio-controller@3 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <8>;
+				reg = <3>;
+			};
+		};
+
+		gmac0: ethernet@28c00000 {
+			compatible = "snps,dwmac";
+			reg = <0 0x28c00000 0x0 0x2000>;
+			interrupts = <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq";
+			clocks = <&gmacclk>;
+			clock-names = "stmmaceth";
+			snps,pbl = <32>;
+			snps,fixed-burst;
+			snps,burst_len = <0xe>;
+			snps,force_sf_dma_mode;
+			snps,multicast-filter-bins = <64>;
+			snps,perfect-filter-entries = <1>;
+			max-frame-size = <9000>;
+			status = "disabled";
+		};
+
+		gmac1: ethernet@28c02000 {
+			compatible = "snps,dwmac";
+			reg = <0 0x28c02000 0x0 0x2000>;
+			interrupts = <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq";
+			clocks = <&gmacclk>;
+			clock-names = "stmmaceth";
+			snps,pbl = <32>;
+			snps,fixed-burst;
+			snps,burst_len = <0xe>;
+			snps,force_sf_dma_mode;
+			snps,multicast-filter-bins = <64>;
+			snps,perfect-filter-entries = <1>;
+			max-frame-size = <9000>;
+			status = "disabled";
+		};
+
+		pcie0: pcie@40000000 {
+			compatible = "pci-host-ecam-generic";
+			device_type = "pci";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			#interrupt-cells = <1>;
+			reg = <0 0x40000000 0 0x10000000>;
+			msi-parent = <&its>;
+			interrupt-map-mask = <0x0000 0x0 0x0 0x7>;
+			interrupt-map = <0x0 0x0 0x0 0x1 &gic 0x0 0x0 GIC_SPI 0x33 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x2 &gic 0x0 0x0 GIC_SPI 0x34 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x3 &gic 0x0 0x0 GIC_SPI 0x35 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x4 &gic 0x0 0x0 GIC_SPI 0x36 IRQ_TYPE_LEVEL_HIGH>;
+			ranges = <0x01000000 0x00 0x00000000 0x00 0x50000000 0x00 0x1000000>,
+				 <0x02000000 0x00 0x60000000 0x00 0x60000000 0x00 0x20000000>,
+				 <0x43000000 0x01 0x00000000 0x01 0x00000000 0x01 0x00000000>;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/phytium/ft1500a-devboard-16c-dsk.dts b/arch/arm64/boot/dts/phytium/ft1500a-devboard-16c-dsk.dts
new file mode 100755
index 000000000000..ed2127496e95
--- /dev/null
+++ b/arch/arm64/boot/dts/phytium/ft1500a-devboard-16c-dsk.dts
@@ -0,0 +1,51 @@
+/*
+ * DTS file for Phytium FT1500A Generic board
+ *
+ * Copyright (C) 2015, Phytium Technology Co., Ltd.
+ *
+ * This file is licensed under a dual GPLv2 or BSD license.
+ */
+
+/dts-v1/;
+/memreserve/ 0x80000000 0x80000;
+
+#include "ft1500a-16c-generic-psci-soc.dtsi"
+
+/ {
+	model = "FT1500A-16CORE-DSK Development Board";
+	compatible = "phytium,ft-1500a";
+
+	chosen {
+		linux,pci-probe-only = <1>;
+		stdout-path = "uart1:115200n8";
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0x0 0x80000000>;	/* Updated by bootloader */
+	};
+};
+
+&uart1 {
+	status = "ok";
+};
+
+&i2c0 {
+	status = "ok";
+};
+
+&i2c1 {
+	status = "ok";
+};
+
+&wdt0 {
+	status = "ok";
+};
+
+&gmac0 {
+	phy-mode = "gmii";
+};
+
+&gmac1 {
+	phy-mode = "gmii";
+};
diff --git a/arch/arm64/boot/dts/phytium/ft2000ahk-devboard-dsk.dts b/arch/arm64/boot/dts/phytium/ft2000ahk-devboard-dsk.dts
new file mode 100755
index 000000000000..4afbbf9c827b
--- /dev/null
+++ b/arch/arm64/boot/dts/phytium/ft2000ahk-devboard-dsk.dts
@@ -0,0 +1,52 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * DTS file for Phytium FT-2000A/2 devboard (FT-2000A-HK-DSK series)
+ *
+ * Copyright (C) 2019, Phytium Techonlogy Co., Ltd.
+ */
+
+/dts-v1/;
+
+#include "ft2000ahk-generic-spintable-soc.dtsi"
+
+/ {
+	model = "FT-2000A-HK-DSK Development Board";
+	compatible = "phytium,ft-2000ahk";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	chosen {
+		linux,pci-probe-only = <1>;
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0x0 0x80000000>;
+	};
+};
+
+&i2c0 {
+	status = "ok";
+	rtc@68 {
+		compatible = "dallas,ds1339";
+		reg = <0x68>;
+	};
+};
+
+&uart1 {
+	status = "ok";
+};
+
+&gmac0 {
+	status = "ok";
+	phy-mode = "rgmii";
+};
+
+&gmac1 {
+	status = "ok";
+	phy-mode = "rgmii";
+};
+
+&gpio {
+	status = "ok";
+};
diff --git a/arch/arm64/boot/dts/phytium/ft2000ahk-generic-spintable-soc.dtsi b/arch/arm64/boot/dts/phytium/ft2000ahk-generic-spintable-soc.dtsi
new file mode 100755
index 000000000000..81393fc55bec
--- /dev/null
+++ b/arch/arm64/boot/dts/phytium/ft2000ahk-generic-spintable-soc.dtsi
@@ -0,0 +1,253 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * dts file for FT-2000A/2 SoC
+ *
+ * Copyright (C) 2019, Phytium Technology Co., Ltd.
+ */
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+
+/ {
+	compatible = "phytium,ft2000ahk";
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	aliases {
+		ethernet0 = &gmac0;
+		ethernet1 = &gmac1;
+	};
+
+	cpus {
+		#address-cells = <2>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x0>;
+			enable-method = "spin-table";
+			cpu-release-addr = <0x0 0x8007fff0>;
+		};
+
+		cpu1: cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x1>;
+			enable-method = "spin-table";
+			cpu-release-addr = <0x0 0x8007fff0>;
+		};
+	};
+
+	gic: interrupt-controller@71800000 {
+		compatible = "arm,gic-400";
+		#interrupt-cells = <3>;
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		interrupt-controller;
+		reg = <0x0 0x71801000 0x0 0x1000>,
+		      <0x0 0x71802000 0x0 0x2000>,
+		      <0x0 0x71804000 0x0 0x1000>,
+		      <0x0 0x71805000 0x0 0x1000>;
+	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		interrupts = <GIC_PPI 13 IRQ_TYPE_LEVEL_LOW>,
+			     <GIC_PPI 14 IRQ_TYPE_LEVEL_LOW>,
+			     <GIC_PPI 11 IRQ_TYPE_LEVEL_LOW>,
+			     <GIC_PPI 10 IRQ_TYPE_LEVEL_LOW>;
+		clock-frequency = <50000000>;
+	};
+
+	pmu {
+		compatible = "arm,armv8-pmuv3";
+		interrupts = <GIC_SPI 0 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 1 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-affinity = <&cpu0 &cpu1>;
+	};
+
+	soc {
+		compatible = "simple-bus";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		dma-coherent;
+		ranges;
+
+		clocks {
+			refclk: refclk {
+				compatible = "fixed-clock";
+				#clock-cells = <0>;
+				clock-frequency = <50000000>;
+			};
+
+			clk250mhz: clk250mhz {
+				compatible = "fixed-clock";
+				#clock-cells = <0>;
+				clock-frequency = <250000000>;
+			};
+
+			clk500mhz: clk500mhz {
+				compatible = "fixed-clock";
+				#clock-cells = <0>;
+				clock-frequency = <500000000>;
+			};
+		};
+
+		uart0: uart@70000000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x0 0x70000000 0x0 0x1000>;
+			clock-frequency = <50000000>;
+			interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			status = "disabled";
+		};
+
+		uart1: uart@70001000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x0 0x70001000 0x0 0x1000>;
+			clock-frequency = <50000000>;
+			interrupts = <GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			status = "disabled";
+		};
+
+		i2c0: i2c@70002000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "snps,designware-i2c";
+			reg = <0x0 0x70002000 0x0 0x1000>;
+			interrupts = <GIC_SPI 6 IRQ_TYPE_LEVEL_HIGH>;
+			clock-frequency = <100000>;
+			clocks = <&refclk>;
+			status = "disabled";
+		};
+
+		i2c1: i2c@70003000 {
+			#address-cells = <01>;
+			#size-cells = <0>;
+			compatible = "snps,designware-i2c";
+			reg = <0x0 0x70003000 0x0 0x1000>;
+			interrupts = <GIC_SPI 7 IRQ_TYPE_LEVEL_HIGH>;
+			clock-frequency = <100000>;
+			clocks = <&refclk>;
+			status = "disabled";
+		};
+
+		watchdog0: wd@70004000 {
+			compatible = "snps,dw-wdt";
+			reg = <0x0 0x70004000 0x0 0x1000>;
+			clocks = <&refclk>;
+			interrupts = <GIC_SPI 8 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		watchdog1: wd@70005000 {
+			compatible = "snps,dw-wdt";
+			reg = <0x0 0x70005000 0x0 0x1000>;
+			clocks = <&refclk>;
+			interrupts = <GIC_SPI 9 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		gpio: gpio@70006000 {
+			compatible = "snps,dw-apb-gpio";
+			reg = <0x0 0x70006000 0x0 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			porta: gpio-controller@0 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <8>;
+				reg = <0>;
+			};
+
+			portb: gpio-controller@1 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <8>;
+				reg = <1>;
+			};
+
+			portc: gpio-controller@2 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <8>;
+				reg = <2>;
+			};
+
+			portd: gpio-controller@3 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <8>;
+				reg = <3>;
+			};
+		};
+
+		gmac0: eth@70c00000 {
+			compatible = "snps,dwmac";
+			reg = <0x0 0x70c00000 0x0 0x2000>;
+			interrupts = <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq";
+			clocks = <&clk500mhz>;
+			clock-names = "stmmaceth";
+			status = "disabled";
+
+			snps,pbl = <16>;
+			snps,fixed-burst;
+			snps,burst_len = <14>;
+			snps,force_sf_dma_mode;
+			snps,multicast-filter-bins = <64>;
+			snps,perfect-filter-entries = <128>;
+			tx-fifo-depth = <4096>;
+			rx-fifo-depth = <4096>;
+			max-frame-size = <9000>;
+		};
+
+		gmac1: eth@70c10000 {
+			compatible = "snps,dwmac";
+			reg = <0x0 0x70c10000 0x0 0x2000>;
+			interrupts = <GIC_SPI 15 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq";
+			clocks = <&clk500mhz>;
+			clock-names = "stmmaceth";
+			status = "disabled";
+
+			snps,pbl = <16>;
+			snps,fixed-burst;
+			snps,burst_len = <14>;
+			snps,force_sf_dma_mode;
+			snps,multicast-filter-bins = <64>;
+			snps,perfect-filter-entries = <128>;
+			tx-fifo-depth = <4096>;
+			rx-fifo-depth = <4096>;
+			max-frame-size = <9000>;
+		};
+
+		pcie: pcie {
+			compatible = "pci-host-ecam-generic";
+			device_type = "pci";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			#interrupt-cells = <1>;
+			reg = <0x0 0x40000000 0x0 0x4000000>;
+			interrupt-map-mask = <0x0 0x0 0x0 0x7>;
+			interrupt-map = <0x00 0x0 0x0 0x1 &gic 0x00 0x00 GIC_SPI 0x17 IRQ_TYPE_LEVEL_HIGH>,
+					<0x00 0x0 0x0 0x2 &gic 0x00 0x00 GIC_SPI 0x16 IRQ_TYPE_LEVEL_HIGH>,
+					<0x00 0x0 0x0 0x3 &gic 0x00 0x00 GIC_SPI 0x15 IRQ_TYPE_LEVEL_HIGH>,
+					<0x00 0x0 0x0 0x4 &gic 0x00 0x00 GIC_SPI 0x14 IRQ_TYPE_LEVEL_HIGH>;
+			ranges = <0x01000000 0x0 0x00000000 0x0 0x44000000 0x0 0x01000000>,
+				 <0x02000000 0x0 0x48000000 0x0 0x48000000 0x0 0x18000000>,
+				 <0x03000000 0x1 0x00000000 0x1 0x00000000 0x1 0x00000000>;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/phytium/ft2000ahke-devboard-dsk.dts b/arch/arm64/boot/dts/phytium/ft2000ahke-devboard-dsk.dts
new file mode 100755
index 000000000000..beafd9b7fd12
--- /dev/null
+++ b/arch/arm64/boot/dts/phytium/ft2000ahke-devboard-dsk.dts
@@ -0,0 +1,68 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * DTS file for Phytium FT-2000A/2 devboard (FT-2000A-HKE-DSK series)
+ *
+ * Copyright (C) 2021, Phytium Techonlogy Co., Ltd.
+ */
+
+/dts-v1/;
+
+#include "ft2000ahke-generic-psci-soc.dtsi"
+
+/ {
+	model = "FT-2000A-HKE-DSK Development Board";
+	compatible = "phytium,ft-2000ahke";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	chosen {
+		linux,pci-probe-only = <1>;
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0x0 0x7C000000>;
+	};
+};
+
+&i2c0 {
+	status = "ok";
+	rtc@68 {
+		compatible = "dallas,ds1339";
+		reg = <0x68>;
+	};
+};
+
+&uart1 {
+	status = "ok";
+};
+
+&gmac0 {
+	status = "ok";
+	phy-mode = "rgmii";
+};
+
+&gmac1 {
+	status = "ok";
+	phy-mode = "rgmii";
+};
+
+&gpio {
+	status = "ok";
+};
+
+&spi0 {
+	status = "ok";
+};
+
+&spi1 {
+	status = "ok";
+};
+
+&can0 {
+	status = "ok";
+};
+
+&can1 {
+	status = "ok";
+};
diff --git a/arch/arm64/boot/dts/phytium/ft2000ahke-generic-psci-soc.dtsi b/arch/arm64/boot/dts/phytium/ft2000ahke-generic-psci-soc.dtsi
new file mode 100755
index 000000000000..3f3731e50efa
--- /dev/null
+++ b/arch/arm64/boot/dts/phytium/ft2000ahke-generic-psci-soc.dtsi
@@ -0,0 +1,312 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * dts file for FT-2000A/2 SoC
+ *
+ * Copyright (C) 2019, Phytium Technology Co., Ltd.
+ */
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+
+/ {
+	compatible = "phytium,ft2000ahke";
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	aliases {
+		ethernet0 = &gmac0;
+		ethernet1 = &gmac1;
+	};
+	psci {
+		compatible = "arm,psci-1.0", "arm,psci-0.2", "arm,psci";
+		method = "smc";
+		cpu_suspend = <0xc4000001>;
+		cpu_off = <0x84000002>;
+		cpu_on = <0xc4000003>;
+		sys_poweroff = <0x84000008>;
+		sys_reset = <0x84000009>;
+	};
+
+	cpus {
+		#address-cells = <2>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x0>;
+			enable-method = "psci";
+		};
+
+		cpu1: cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x1>;
+			enable-method = "psci";
+		};
+	};
+
+	gic: interrupt-controller@71800000 {
+		compatible = "arm,gic-400";
+		#interrupt-cells = <3>;
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		interrupt-controller;
+		reg = <0x0 0x71801000 0x0 0x1000>,
+		      <0x0 0x71802000 0x0 0x2000>,
+		      <0x0 0x71804000 0x0 0x1000>,
+		      <0x0 0x71805000 0x0 0x1000>;
+	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		interrupts = <GIC_PPI 13 IRQ_TYPE_LEVEL_LOW>,
+			     <GIC_PPI 14 IRQ_TYPE_LEVEL_LOW>,
+			     <GIC_PPI 11 IRQ_TYPE_LEVEL_LOW>,
+			     <GIC_PPI 10 IRQ_TYPE_LEVEL_LOW>;
+		clock-frequency = <50000000>;
+	};
+
+	pmu {
+		compatible = "arm,armv8-pmuv3";
+		interrupts = <GIC_SPI 0 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 1 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-affinity = <&cpu0 &cpu1>;
+	};
+
+	soc {
+		compatible = "simple-bus";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		dma-coherent;
+		ranges;
+
+		clocks {
+			refclk: refclk {
+				compatible = "fixed-clock";
+				#clock-cells = <0>;
+				clock-frequency = <50000000>;
+			};
+
+			clk250mhz: clk250mhz {
+				compatible = "fixed-clock";
+				#clock-cells = <0>;
+				clock-frequency = <250000000>;
+			};
+
+			clk500mhz: clk500mhz {
+				compatible = "fixed-clock";
+				#clock-cells = <0>;
+				clock-frequency = <500000000>;
+			};
+
+			sysclk_48mhz: clk48mhz {
+				compatible = "fixed-clock";
+				#clock-cells = <0>;
+				clock-frequency = <48000000>;
+			};
+
+			sysclk_600mhz: clk600mhz {
+				compatible = "fixed-clock";
+				#clock-cells = <0>;
+				clock-frequency = <600000000>;
+			};
+		};
+
+		uart0: uart@70000000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x0 0x70000000 0x0 0x1000>;
+			clock-frequency = <50000000>;
+			interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			status = "disabled";
+		};
+
+		uart1: uart@70001000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x0 0x70001000 0x0 0x1000>;
+			clock-frequency = <50000000>;
+			interrupts = <GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			status = "disabled";
+		};
+
+		uart2: uart@70007000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x0 0x70007000 0x0 0x1000>;
+			clock-frequency = <50000000>;
+			interrupts = <GIC_SPI 7 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			status = "disabled";
+		};
+
+		uart3: uart@70008000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x0 0x70008000 0x0 0x1000>;
+			clock-frequency = <50000000>;
+			interrupts = <GIC_SPI 7 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			status = "disabled";
+		};
+
+		i2c0: i2c@70002000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "snps,designware-i2c";
+			reg = <0x0 0x70002000 0x0 0x1000>;
+			interrupts = <GIC_SPI 6 IRQ_TYPE_LEVEL_HIGH>;
+			clock-frequency = <100000>;
+			clocks = <&refclk>;
+			status = "disabled";
+		};
+
+		i2c1: i2c@70003000 {
+			#address-cells = <01>;
+			#size-cells = <0>;
+			compatible = "snps,designware-i2c";
+			reg = <0x0 0x70003000 0x0 0x1000>;
+			interrupts = <GIC_SPI 7 IRQ_TYPE_LEVEL_HIGH>;
+			clock-frequency = <100000>;
+			clocks = <&refclk>;
+			status = "disabled";
+		};
+
+		gpio: gpio@70006000 {
+			compatible = "snps,dw-apb-gpio";
+			reg = <0x0 0x70006000 0x0 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			porta: gpio-controller@0 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <8>;
+				reg = <0>;
+			};
+
+			portb: gpio-controller@1 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <8>;
+				reg = <1>;
+			};
+
+			portc: gpio-controller@2 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <8>;
+				reg = <2>;
+			};
+
+			portd: gpio-controller@3 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <8>;
+				reg = <3>;
+			};
+		};
+
+		gmac0: eth@70c00000 {
+			compatible = "snps,dwmac";
+			reg = <0x0 0x70c00000 0x0 0x2000>;
+			interrupts = <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq";
+			clocks = <&clk500mhz>;
+			clock-names = "stmmaceth";
+			status = "disabled";
+
+			snps,pbl = <16>;
+			snps,fixed-burst;
+			snps,burst_len = <14>;
+			snps,force_sf_dma_mode;
+			snps,multicast-filter-bins = <64>;
+			snps,perfect-filter-entries = <128>;
+			tx-fifo-depth = <4096>;
+			rx-fifo-depth = <4096>;
+			max-frame-size = <9000>;
+		};
+
+		gmac1: eth@70c10000 {
+			compatible = "snps,dwmac";
+			reg = <0x0 0x70c10000 0x0 0x2000>;
+			interrupts = <GIC_SPI 15 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq";
+			clocks = <&clk500mhz>;
+			clock-names = "stmmaceth";
+			status = "disabled";
+
+			snps,pbl = <16>;
+			snps,fixed-burst;
+			snps,burst_len = <14>;
+			snps,force_sf_dma_mode;
+			snps,multicast-filter-bins = <64>;
+			snps,perfect-filter-entries = <128>;
+			tx-fifo-depth = <4096>;
+			rx-fifo-depth = <4096>;
+			max-frame-size = <9000>;
+		};
+
+		spi0: spi@70009000 {
+			compatible = "phytium,spi";
+			interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
+			reg = <0x0 0x70009000 0x0 0x1000>;
+			clocks = <&sysclk_48mhz>;
+			num-cs = <4>;
+		};
+
+		spi1: spi@7000a000 {
+			compatible = "phytium,spi";
+			interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
+			reg = <0x0 0x7000a000 0x0 0x1000>;
+			clocks = <&sysclk_48mhz>;
+			num-cs = <4>;
+		};
+
+		can0: can@70014000 {
+			compatible = "phytium,can";
+			reg = <0x0 0x70014000 0x0 0x1000>;
+			interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_600mhz>;
+			clock-names = "phytium_can_clk";
+			tx-fifo-depth = <0x40>;
+			rx-fifo-depth = <0x40>;
+		};
+
+		can1: can@70015000 {
+			compatible = "phytium,can";
+			reg = <0x0 0x70015000 0x0 0x1000>;
+			interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_600mhz>;
+			clock-names = "phytium_can_clk";
+			tx-fifo-depth = <0x40>;
+			rx-fifo-depth = <0x40>;
+		};
+
+		pcie: pcie {
+			compatible = "pci-host-ecam-generic";
+			device_type = "pci";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			#interrupt-cells = <1>;
+			reg = <0x0 0x40000000 0x0 0x4000000>;
+			interrupt-map-mask = <0x0 0x0 0x0 0x7>;
+			interrupt-map = <0x00 0x0 0x0 0x1 &gic 0x00 0x00 GIC_SPI 0x17 IRQ_TYPE_LEVEL_HIGH>,
+					<0x00 0x0 0x0 0x2 &gic 0x00 0x00 GIC_SPI 0x16 IRQ_TYPE_LEVEL_HIGH>,
+					<0x00 0x0 0x0 0x3 &gic 0x00 0x00 GIC_SPI 0x15 IRQ_TYPE_LEVEL_HIGH>,
+					<0x00 0x0 0x0 0x4 &gic 0x00 0x00 GIC_SPI 0x14 IRQ_TYPE_LEVEL_HIGH>;
+			ranges = <0x01000000 0x0 0x00000000 0x0 0x44000000 0x0 0x01000000>,
+				 <0x02000000 0x0 0x48000000 0x0 0x48000000 0x0 0x18000000>,
+				 <0x03000000 0x1 0x00000000 0x1 0x00000000 0x1 0x00000000>;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/phytium/ft2000plus-MR-devboard-64c-dsk.dts b/arch/arm64/boot/dts/phytium/ft2000plus-MR-devboard-64c-dsk.dts
new file mode 100755
index 000000000000..7c2ee8e60dce
--- /dev/null
+++ b/arch/arm64/boot/dts/phytium/ft2000plus-MR-devboard-64c-dsk.dts
@@ -0,0 +1,136 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * DTS file for Phytium FT-2000plus devboard.
+ *
+ * Copyright (C) 2019, Phytium Technology Co., Ltd.
+ */
+
+/dts-v1/;
+/memreserve/ 0x0000000080000000 0x0000000000010000;
+
+#include "ft2000plus-MR-psci-soc.dtsi"
+
+/ {
+	model = "FT-2000plus Development Board";
+	compatible = "phytium,ft-2000plus";
+
+	chosen {
+		linux,pci-probe-only = <1>;
+	};
+
+	/* NUMA Node-0 */
+        memory@00 {
+                device_type = "memory";
+		/* 0 - 512MiB (512MiB)*/
+                reg = <0x00000000 0x00000000 0x0 0x20000000>;
+                numa-node-id = <0>;
+        };
+        memory@01 {
+                device_type = "memory";
+		/* 2GiB - 4GiB (2GiB) */
+                reg = <0x00000000 0x80000000 0x0 0x80000000>;
+                numa-node-id = <0>;
+        };
+        memory@02 {
+                device_type = "memory";
+		/* 512GiB - 516GiB (4GiB) */
+                reg = <0x00000080 0x00000000 0x1 0x00000000>;
+                numa-node-id = <0>;
+        };
+	/* NUMA Node-1 */
+        memory@10 {
+                device_type = "memory";
+		/* 1024GiB - 1028GiB (4GiB) */
+                reg = <0x00000100 0x00000000 0x1 0x00000000>;
+                numa-node-id = <1>;
+        };
+        memory@11 {
+                device_type = "memory";
+		/* 1536GiB - 1540GiB (4GiB) */
+                reg = <0x00000180 0x00000000 0x1 0x00000000>;
+                numa-node-id = <1>;
+        };
+	/* NUMA Node-2 */
+        memory@20 {
+                device_type = "memory";
+		/* 2048GiB - 2052GiB (4GiB) */
+                reg = <0x00000200 0x00000000 0x1 0x00000000>;
+                numa-node-id = <2>;
+        };
+        memory@21 {
+                device_type = "memory";
+		/* 2560GiB - 2564GiB (4GiB) */
+                reg = <0x00000280 0x00000000 0x1 0x00000000>;
+                numa-node-id = <2>;
+        };
+	/* NUMA Node-3 */
+        memory@30 {
+                device_type = "memory";
+		/* 3072GiB - 3076GiB (4GiB) */
+                reg = <0x00000300 0x00000000 0x1 0x00000000>;
+                numa-node-id = <3>;
+        };
+        memory@31 {
+                device_type = "memory";
+		/* 3584GiB - 3588GiB (4GiB) */
+                reg = <0x00000380 0x00000000 0x1 0x00000000>;
+                numa-node-id = <3>;
+        };
+	/* NUMA Node-4 */
+        memory@40 {
+                device_type = "memory";
+		/* 4096GiB - 4100GiB (4GiB) */
+                reg = <0x00000400 0x00000000 0x1 0x00000000>;
+                numa-node-id = <4>;
+        };
+        memory@41 {
+                device_type = "memory";
+		/* 4608GiB - 4612GiB (4GiB) */
+                reg = <0x00000480 0x00000000 0x1 0x00000000>;
+                numa-node-id = <4>;
+        };
+	/* NUMA Node-5 */
+        memory@50 {
+                device_type = "memory";
+		/* 5120GiB - 5124GiB (4GiB) */
+                reg = <0x00000500 0x00000000 0x1 0x00000000>;
+                numa-node-id = <5>;
+        };
+        memory@51 {
+                device_type = "memory";
+		/* 5632GiB - 5636GiB (4GiB) */
+                reg = <0x00000580 0x00000000 0x1 0x00000000>;
+                numa-node-id = <5>;
+        };
+	/* NUMA Node-6 */
+        memory@60 {
+                device_type = "memory";
+		/* 6144GiB - 6148GiB (4GiB) */
+                reg = <0x00000600 0x00000000 0x1 0x00000000>;
+                numa-node-id = <6>;
+        };
+        memory@61 {
+                device_type = "memory";
+		/* 6656GiB - 6660GiB (4GiB) */
+                reg = <0x00000680 0x00000000 0x1 0x00000000>;
+                numa-node-id = <6>;
+        };
+	/* NUMA Node-7 */
+        memory@70 {
+                device_type = "memory";
+		/* 7168GiB - 7172GiB (4GiB) */
+                reg = <0x00000700 0x00000000 0x1 0x00000000>;
+                numa-node-id = <7>;
+        };
+        memory@71 {
+                device_type = "memory";
+		/* 7680GiB - 7684GiB (4GiB) */
+                reg = <0x00000780 0x00000000 0x1 0x00000000>;
+                numa-node-id = <7>;
+        };
+
+};
+
+&uart1 {
+	status = "ok";
+};
diff --git a/arch/arm64/boot/dts/phytium/ft2000plus-MR-psci-soc.dtsi b/arch/arm64/boot/dts/phytium/ft2000plus-MR-psci-soc.dtsi
new file mode 100755
index 000000000000..54a1466da796
--- /dev/null
+++ b/arch/arm64/boot/dts/phytium/ft2000plus-MR-psci-soc.dtsi
@@ -0,0 +1,1062 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * dts file for FT-2000plus SoC
+ *
+ * Copyright (C) 2018-2019, Phytium Technology Co., Ltd.
+ */
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+
+/ {
+	compatible = "phytium,ft2000plus";
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	psci {
+		compatible = "arm,psci-1.0";
+		method = "smc";
+		cpu_suspend = <0xc4000001>;
+		cpu_off = <0x84000002>;
+		cpu_on = <0xc4000003>;
+		sys_poweroff = <0x84000008>;
+		sys_reset = <0x84000009>;
+	};
+
+	cpus {
+		#address-cells = <0x2>;
+		#size-cells = <0x0>;
+
+		cpu-map {
+			cluster0 {
+				core0 {
+					cpu = <&cpu0>;
+				};
+				core1 {
+					cpu = <&cpu1>;
+				};
+				core2 {
+					cpu = <&cpu2>;
+				};
+				core3 {
+					cpu = <&cpu3>;
+				};
+			};
+
+			cluster1 {
+				core0 {
+					cpu = <&cpu4>;
+				};
+				core1 {
+					cpu = <&cpu5>;
+				};
+				core2 {
+					cpu = <&cpu6>;
+				};
+				core3 {
+					cpu = <&cpu7>;
+				};
+			};
+
+			cluster2 {
+				core0 {
+					cpu = <&cpu8>;
+				};
+				core1 {
+					cpu = <&cpu9>;
+				};
+				core2 {
+					cpu = <&cpu10>;
+				};
+				core3 {
+					cpu = <&cpu11>;
+				};
+			};
+
+			cluster3 {
+				core0 {
+					cpu = <&cpu12>;
+				};
+				core1 {
+					cpu = <&cpu13>;
+				};
+				core2 {
+					cpu = <&cpu14>;
+				};
+				core3 {
+					cpu = <&cpu15>;
+				};
+			};
+
+			cluster4 {
+				core0 {
+					cpu = <&cpu16>;
+				};
+				core1 {
+					cpu = <&cpu17>;
+				};
+				core2 {
+					cpu = <&cpu18>;
+				};
+				core3 {
+					cpu = <&cpu19>;
+				};
+			};
+
+			cluster5 {
+				core0 {
+					cpu = <&cpu20>;
+				};
+				core1 {
+					cpu = <&cpu21>;
+				};
+				core2 {
+					cpu = <&cpu22>;
+				};
+				core3 {
+					cpu = <&cpu23>;
+				};
+			};
+
+			cluster6 {
+				core0 {
+					cpu = <&cpu24>;
+				};
+				core1 {
+					cpu = <&cpu25>;
+				};
+				core2 {
+					cpu = <&cpu26>;
+				};
+				core3 {
+					cpu = <&cpu27>;
+				};
+			};
+
+			cluster7 {
+				core0 {
+					cpu = <&cpu28>;
+				};
+				core1 {
+					cpu = <&cpu29>;
+				};
+				core2 {
+					cpu = <&cpu30>;
+				};
+				core3 {
+					cpu = <&cpu31>;
+				};
+			};
+
+			cluster8 {
+				core0 {
+					cpu = <&cpu32>;
+				};
+				core1 {
+					cpu = <&cpu33>;
+				};
+				core2 {
+					cpu = <&cpu34>;
+				};
+				core3 {
+					cpu = <&cpu35>;
+				};
+			};
+
+			cluster9 {
+				core0 {
+					cpu = <&cpu36>;
+				};
+				core1 {
+					cpu = <&cpu37>;
+				};
+				core2 {
+					cpu = <&cpu38>;
+				};
+				core3 {
+					cpu = <&cpu39>;
+				};
+			};
+
+			cluster10 {
+				core0 {
+					cpu = <&cpu40>;
+				};
+				core1 {
+					cpu = <&cpu41>;
+				};
+				core2 {
+					cpu = <&cpu42>;
+				};
+				core3 {
+					cpu = <&cpu43>;
+				};
+			};
+
+			cluster11 {
+				core0 {
+					cpu = <&cpu44>;
+				};
+				core1 {
+					cpu = <&cpu45>;
+				};
+				core2 {
+					cpu = <&cpu46>;
+				};
+				core3 {
+					cpu = <&cpu47>;
+				};
+			};
+
+			cluster12 {
+				core0 {
+					cpu = <&cpu48>;
+				};
+				core1 {
+					cpu = <&cpu49>;
+				};
+				core2 {
+					cpu = <&cpu50>;
+				};
+				core3 {
+					cpu = <&cpu51>;
+				};
+			};
+
+			cluster13 {
+				core0 {
+					cpu = <&cpu52>;
+				};
+				core1 {
+					cpu = <&cpu53>;
+				};
+				core2 {
+					cpu = <&cpu54>;
+				};
+				core3 {
+					cpu = <&cpu55>;
+				};
+			};
+
+			cluster14 {
+				core0 {
+					cpu = <&cpu56>;
+				};
+				core1 {
+					cpu = <&cpu57>;
+				};
+				core2 {
+					cpu = <&cpu58>;
+				};
+				core3 {
+					cpu = <&cpu59>;
+				};
+			};
+
+			cluster15 {
+				core0 {
+					cpu = <&cpu60>;
+				};
+				core1 {
+					cpu = <&cpu61>;
+				};
+				core2 {
+					cpu = <&cpu62>;
+				};
+				core3 {
+					cpu = <&cpu63>;
+				};
+			};
+		};
+
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x0>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+		};
+
+		cpu1: cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x1>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+		};
+
+		cpu2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x2>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+		};
+
+		cpu3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x3>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+		};
+
+		cpu4: cpu@100 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x100>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+		};
+
+		cpu5: cpu@101 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x101>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+		};
+
+		cpu6: cpu@102 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x102>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+		};
+
+		cpu7: cpu@103 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x103>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+		};
+
+		cpu8: cpu@200 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x200>;
+			enable-method = "psci";
+			numa-node-id = <1>;
+		};
+
+		cpu9: cpu@201 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x201>;
+			enable-method = "psci";
+			numa-node-id = <1>;
+		};
+
+		cpu10: cpu@202 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x202>;
+			enable-method = "psci";
+			numa-node-id = <1>;
+		};
+
+		cpu11: cpu@203 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x203>;
+			enable-method = "psci";
+			numa-node-id = <1>;
+		};
+
+		cpu12: cpu@300 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x300>;
+			enable-method = "psci";
+			numa-node-id = <1>;
+		};
+
+		cpu13: cpu@301 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x301>;
+			enable-method = "psci";
+			numa-node-id = <1>;
+		};
+
+		cpu14: cpu@302 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x302>;
+			enable-method = "psci";
+			numa-node-id = <1>;
+		};
+
+		cpu15: cpu@303 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x303>;
+			enable-method = "psci";
+			numa-node-id = <1>;
+		};
+
+		cpu16: cpu@400 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x400>;
+			enable-method = "psci";
+			numa-node-id = <2>;
+		};
+
+		cpu17: cpu@401 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x401>;
+			enable-method = "psci";
+			numa-node-id = <2>;
+		};
+
+		cpu18: cpu@402 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x402>;
+			enable-method = "psci";
+			numa-node-id = <2>;
+		};
+
+		cpu19: cpu@403 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x403>;
+			enable-method = "psci";
+			numa-node-id = <2>;
+		};
+
+		cpu20: cpu@500 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x500>;
+			enable-method = "psci";
+			numa-node-id = <2>;
+		};
+
+		cpu21: cpu@501 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x501>;
+			enable-method = "psci";
+			numa-node-id = <2>;
+		};
+
+		cpu22: cpu@502 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x502>;
+			enable-method = "psci";
+			numa-node-id = <2>;
+		};
+
+		cpu23: cpu@503 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x503>;
+			enable-method = "psci";
+			numa-node-id = <2>;
+		};
+
+		cpu24: cpu@600 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x600>;
+			enable-method = "psci";
+			numa-node-id = <3>;
+		};
+
+		cpu25: cpu@601 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x601>;
+			enable-method = "psci";
+			numa-node-id = <3>;
+		};
+
+		cpu26: cpu@602 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x602>;
+			enable-method = "psci";
+			numa-node-id = <3>;
+		};
+
+		cpu27: cpu@603 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x603>;
+			enable-method = "psci";
+			numa-node-id = <3>;
+		};
+
+		cpu28: cpu@700 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x700>;
+			enable-method = "psci";
+			numa-node-id = <3>;
+		};
+
+		cpu29: cpu@701 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x701>;
+			enable-method = "psci";
+			numa-node-id = <3>;
+		};
+
+		cpu30: cpu@702 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x702>;
+			enable-method = "psci";
+			numa-node-id = <3>;
+		};
+
+		cpu31: cpu@703 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x703>;
+			enable-method = "psci";
+			numa-node-id = <3>;
+		};
+
+		cpu32: cpu@800 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x800>;
+			enable-method = "psci";
+			numa-node-id = <4>;
+		};
+
+		cpu33: cpu@801 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x801>;
+			enable-method = "psci";
+			numa-node-id = <4>;
+		};
+
+		cpu34: cpu@802 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x802>;
+			enable-method = "psci";
+			numa-node-id = <4>;
+		};
+
+		cpu35: cpu@803 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x803>;
+			enable-method = "psci";
+			numa-node-id = <4>;
+		};
+
+		cpu36: cpu@900 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x900>;
+			enable-method = "psci";
+			numa-node-id = <4>;
+		};
+
+		cpu37: cpu@901 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x901>;
+			enable-method = "psci";
+			numa-node-id = <4>;
+		};
+
+		cpu38: cpu@902 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x902>;
+			enable-method = "psci";
+			numa-node-id = <4>;
+		};
+
+		cpu39: cpu@903 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x903>;
+			enable-method = "psci";
+			numa-node-id = <4>;
+		};
+
+		cpu40: cpu@a00 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xa00>;
+			enable-method = "psci";
+			numa-node-id = <5>;
+		};
+
+		cpu41: cpu@a01 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xa01>;
+			enable-method = "psci";
+			numa-node-id = <5>;
+		};
+
+		cpu42: cpu@a02 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xa02>;
+			enable-method = "psci";
+			numa-node-id = <5>;
+		};
+
+		cpu43: cpu@a03 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xa03>;
+			enable-method = "psci";
+			numa-node-id = <5>;
+		};
+
+		cpu44: cpu@b00 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xb00>;
+			enable-method = "psci";
+			numa-node-id = <5>;
+		};
+
+		cpu45: cpu@b01 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xb01>;
+			enable-method = "psci";
+			numa-node-id = <5>;
+		};
+
+		cpu46: cpu@b02 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xb02>;
+			enable-method = "psci";
+			numa-node-id = <5>;
+		};
+
+		cpu47: cpu@b03 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xb03>;
+			enable-method = "psci";
+			numa-node-id = <5>;
+		};
+
+		cpu48: cpu@c00 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xc00>;
+			enable-method = "psci";
+			numa-node-id = <6>;
+		};
+
+		cpu49: cpu@c01 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xc01>;
+			enable-method = "psci";
+			numa-node-id = <6>;
+		};
+
+		cpu50: cpu@c02 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xc02>;
+			enable-method = "psci";
+			numa-node-id = <6>;
+		};
+
+		cpu51: cpu@c03 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xc03>;
+			enable-method = "psci";
+			numa-node-id = <6>;
+		};
+
+		cpu52: cpu@d00 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xd00>;
+			enable-method = "psci";
+			numa-node-id = <6>;
+		};
+
+		cpu53: cpu@d01 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xd01>;
+			enable-method = "psci";
+			numa-node-id = <6>;
+		};
+
+		cpu54: cpu@d02 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xd02>;
+			enable-method = "psci";
+			numa-node-id = <6>;
+		};
+
+		cpu55: cpu@d03 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xd03>;
+			enable-method = "psci";
+			numa-node-id = <6>;
+		};
+
+		cpu56: cpu@e00 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xe00>;
+			enable-method = "psci";
+			numa-node-id = <7>;
+		};
+
+		cpu57: cpu@e01 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xe01>;
+			enable-method = "psci";
+			numa-node-id = <7>;
+		};
+
+		cpu58: cpu@e02 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xe02>;
+			enable-method = "psci";
+			numa-node-id = <7>;
+		};
+
+		cpu59: cpu@e03 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xe03>;
+			enable-method = "psci";
+			numa-node-id = <7>;
+		};
+
+		cpu60: cpu@f00 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xf00>;
+			enable-method = "psci";
+			numa-node-id = <7>;
+		};
+
+		cpu61: cpu@f01 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xf01>;
+			enable-method = "psci";
+			numa-node-id = <7>;
+		};
+
+		cpu62: cpu@f02 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xf02>;
+			enable-method = "psci";
+			numa-node-id = <7>;
+		};
+
+		cpu63: cpu@f03 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xf03>;
+			enable-method = "psci";
+			numa-node-id = <7>;
+		};
+	};
+
+	distance-map {
+		compatible = "numa-distance-map-v1";
+		distance-matrix = <0x0 0x0 0x0a>,
+				  <0x0 0x1 0x14>,
+				  <0x0 0x2 0x28>,
+				  <0x0 0x3 0x1e>,
+				  <0x0 0x4 0x14>,
+				  <0x0 0x5 0x1e>,
+				  <0x0 0x6 0x32>,
+				  <0x0 0x7 0x28>,
+				  <0x1 0x0 0x14>,
+				  <0x1 0x1 0x0a>,
+				  <0x1 0x2 0x1e>,
+				  <0x1 0x3 0x14>,
+				  <0x1 0x4 0x1e>,
+				  <0x1 0x5 0x14>,
+				  <0x1 0x6 0x28>,
+				  <0x1 0x7 0x1e>,
+				  <0x2 0x0 0x28>,
+				  <0x2 0x1 0x1e>,
+				  <0x2 0x2 0x0a>,
+				  <0x2 0x3 0x14>,
+				  <0x2 0x4 0x32>,
+				  <0x2 0x5 0x28>,
+				  <0x2 0x6 0x14>,
+				  <0x2 0x7 0x1e>,
+				  <0x3 0x0 0x1e>,
+				  <0x3 0x1 0x14>,
+				  <0x3 0x2 0x14>,
+				  <0x3 0x3 0x0a>,
+				  <0x3 0x4 0x28>,
+				  <0x3 0x5 0x1e>,
+				  <0x3 0x6 0x1e>,
+				  <0x3 0x7 0x14>,
+				  <0x4 0x0 0x14>,
+				  <0x4 0x1 0x1e>,
+				  <0x4 0x2 0x32>,
+				  <0x4 0x3 0x28>,
+				  <0x4 0x4 0x0a>,
+				  <0x4 0x5 0x14>,
+				  <0x4 0x6 0x28>,
+				  <0x4 0x7 0x1e>,
+				  <0x5 0x0 0x1e>,
+				  <0x5 0x1 0x14>,
+				  <0x5 0x2 0x28>,
+				  <0x5 0x3 0x1e>,
+				  <0x5 0x4 0x14>,
+				  <0x5 0x5 0x0a>,
+				  <0x5 0x6 0x1e>,
+				  <0x5 0x7 0x14>,
+				  <0x6 0x0 0x32>,
+				  <0x6 0x1 0x28>,
+				  <0x6 0x2 0x14>,
+				  <0x6 0x3 0x1e>,
+				  <0x6 0x4 0x28>,
+				  <0x6 0x5 0x1e>,
+				  <0x6 0x6 0x0a>,
+				  <0x6 0x7 0x14>,
+				  <0x7 0x0 0x28>,
+				  <0x7 0x1 0x1e>,
+				  <0x7 0x2 0x1e>,
+				  <0x7 0x3 0x14>,
+				  <0x7 0x4 0x1e>,
+				  <0x7 0x5 0x14>,
+				  <0x7 0x6 0x14>,
+				  <0x7 0x7 0x0a>;
+	};
+
+
+	gic: interrupt-controller@8002a000000 {
+		compatible = "arm,gic-v3";
+                #interrupt-cells = <3>;
+                #address-cells = <2>;
+                #size-cells = <2>;
+		ranges;
+		interrupt-controller;
+		reg = <0x0800 0x2a000000 0 0x10000>,    /* GICD */
+		      <0x0800 0x2a800000 0 0x800000>,   /* GICR */
+		      <0x0800 0x29c00000 0 0x10000>,    /* GICC */
+		      <0x0800 0x29c10000 0 0x10000>,    /* GICH */
+		      <0x0800 0x29c20000 0 0x10000>;    /* GICV */
+		interrupts = <GIC_PPI 9 IRQ_TYPE_LEVEL_HIGH>;
+
+                its: gic-its@8002a020000 {
+                        compatible = "arm,gic-v3-its";
+                        msi-controller;
+                        reg = <0x0800 0x2a020000 0x0 0x20000>;
+                };
+	};
+
+        timer {
+                compatible = "arm,armv8-timer";
+                interrupts = <GIC_PPI 13 IRQ_TYPE_LEVEL_LOW>,
+                             <GIC_PPI 14 IRQ_TYPE_LEVEL_LOW>,
+                             <GIC_PPI 11 IRQ_TYPE_LEVEL_LOW>,
+                             <GIC_PPI 10 IRQ_TYPE_LEVEL_LOW>;
+                clock-frequency = <50000000>;
+        };
+
+	soc {
+		compatible = "simple-bus";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		dma-coherent;
+		ranges;
+
+                uart0: serial@28000000 {
+                        compatible = "snps,dw-apb-uart";
+                        reg = <0x800 0x28000000 0x0 0x1000>;
+                        clock-frequency = <50000000>;
+                        interrupts = <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>;
+                        reg-shift = <2>;
+                        reg-io-width = <4>;
+                        status = "disabled";
+                };
+
+                uart1: serial@28001000 {
+                        compatible = "snps,dw-apb-uart";
+                        reg = <0x800 0x28001000 0x0 0x1000>;
+                        clock-frequency = <50000000>;
+                        interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
+                        reg-shift = <2>;
+                        reg-io-width = <4>;
+                        status = "disabled";
+                };
+
+		gpio0:gpio@80028006000 {
+			compatible = "snps,dw-apb-gpio";
+			reg = <0x800 0x28006000 0x0 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "ok";
+
+			gpio-controller@0 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <0x2>;
+				snps,nr-gpios = <0x8>;
+				reg = <0x0>;
+			};
+
+			gpio-controller@1 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <0x2>;
+				snps,nr-gpios = <0x8>;
+				reg = <0x1>;
+			};
+
+			gpio-controller@2 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <0x2>;
+				snps,nr-gpios = <0x8>;
+				reg = <0x2>;
+			};
+
+			gpio-controller@3 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <0x2>;
+				snps,nr-gpios = <0x8>;
+				reg = <0x3>;
+			};
+		};
+
+		i2c0: i2c@80028002000 {
+			compatible = "snps,designware-i2c";
+			reg = <0x800 0x28002000 0x0 0x1000>;
+                        interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
+			clock-frequency = <100000>;
+			status = "ok";
+		};
+
+		i2c1: i2c@80028003000 {
+			compatible = "snps,designware-i2c";
+			reg = <0x800 0x28003000 0x0 0x1000>;
+                        interrupts = <GIC_SPI 37 IRQ_TYPE_LEVEL_HIGH>;
+			clock-frequency = <100000>;
+			status = "ok";
+		};
+
+		pcie0: pcie@80040000000 {
+			compatible = "pci-host-ecam-generic";
+			device_type = "pci";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			#interrupt-cells = <1>;
+			reg = <0x800 0x40000000 0 0x2000000>;
+			msi-parent = <&its>;
+			bus-range = <0 0x1f>;
+			interrupt-map-mask = <0x0 0x0 0x0 0x7>;
+			interrupt-map = <0x0 0x0 0x0 0x1 &gic 0x0 0x0 GIC_SPI 0x33 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x2 &gic 0x0 0x0 GIC_SPI 0x34 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x3 &gic 0x0 0x0 GIC_SPI 0x35 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x4 &gic 0x0 0x0 GIC_SPI 0x36 IRQ_TYPE_LEVEL_HIGH>;
+			ranges = <0x01000000 0x00 0x00000000 0x800 0x50000000 0x00 0x00300000>,
+				 <0x02000000 0x00 0x60000000 0x800 0x60000000 0x00 0x08000000>,
+				 <0x03000000 0x20 0x00000000 0x820 0x00000000 0x08 0x00000000>;
+		};
+
+		pcie1: pcie@80042000000 {
+			compatible = "pci-host-ecam-generic";
+			device_type = "pci";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			#interrupt-cells = <1>;
+			reg = <0x800 0x42000000 0 0x2000000>;
+			msi-parent = <&its>;
+			bus-range = <0x20 0x3f>;
+			interrupt-map-mask = <0x0 0x0 0x0 0x7>;
+			interrupt-map = <0x0 0x0 0x0 0x1 &gic 0x0 0x0 GIC_SPI 0x33 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x2 &gic 0x0 0x0 GIC_SPI 0x34 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x3 &gic 0x0 0x0 GIC_SPI 0x35 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x4 &gic 0x0 0x0 GIC_SPI 0x36 IRQ_TYPE_LEVEL_HIGH>;
+			ranges = <0x01000000 0x00 0x00300000 0x800 0x50300000 0x00 0x00300000>,
+				 <0x02000000 0x00 0x68000000 0x800 0x68000000 0x00 0x04000000>,
+				 <0x03000000 0x28 0x00000000 0x828 0x00000000 0x04 0x00000000>;
+		};
+
+		pcie2: pcie@80044000000 {
+			compatible = "pci-host-ecam-generic";
+			device_type = "pci";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			#interrupt-cells = <1>;
+			reg = <0x800 0x44000000 0 0x1000000>;
+			msi-parent = <&its>;
+			bus-range = <0x40 0x4f>;
+			interrupt-map-mask = <0x0 0x0 0x0 0x7>;
+			interrupt-map = <0x0 0x0 0x0 0x1 &gic 0x0 0x0 GIC_SPI 0x33 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x2 &gic 0x0 0x0 GIC_SPI 0x34 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x3 &gic 0x0 0x0 GIC_SPI 0x35 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x4 &gic 0x0 0x0 GIC_SPI 0x36 IRQ_TYPE_LEVEL_HIGH>;
+			ranges = <0x01000000 0x00 0x00600000 0x800 0x50600000 0x00 0x00300000>,
+				 <0x02000000 0x00 0x6c000000 0x800 0x6c000000 0x00 0x02000000>,
+				 <0x03000000 0x2c 0x00000000 0x82c 0x00000000 0x04 0x00000000>;
+		};
+
+		pcie3: pcie@80045000000 {
+			compatible = "pci-host-ecam-generic";
+			device_type = "pci";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			#interrupt-cells = <1>;
+			reg = <0x800 0x45000000 0 0x2000000>;
+			msi-parent = <&its>;
+			bus-range = <0x50 0x6f>;
+			interrupt-map-mask = <0x0 0x0 0x0 0x7>;
+			interrupt-map = <0x0 0x0 0x0 0x1 &gic 0x0 0x0 GIC_SPI 0x33 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x2 &gic 0x0 0x0 GIC_SPI 0x34 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x3 &gic 0x0 0x0 GIC_SPI 0x35 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x4 &gic 0x0 0x0 GIC_SPI 0x36 IRQ_TYPE_LEVEL_HIGH>;
+			ranges = <0x01000000 0x00 0x00900000 0x800 0x50900000 0x00 0x00300000>,
+				 <0x02000000 0x00 0x6e000000 0x800 0x6e000000 0x00 0x0a000000>,
+				 <0x03000000 0x20 0x00000000 0x830 0x00000000 0x08 0x00000000>;
+		};
+
+		pcie4: pcie@80047000000 {
+			compatible = "pci-host-ecam-generic";
+			device_type = "pci";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			#interrupt-cells = <1>;
+			reg = <0x800 0x47000000 0 0x1000000>;
+			msi-parent = <&its>;
+			bus-range = <0x70 0x7f>;
+			interrupt-map-mask = <0x0 0x0 0x0 0x7>;
+			interrupt-map = <0x0 0x0 0x0 0x1 &gic 0x0 0x0 GIC_SPI 0x33 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x2 &gic 0x0 0x0 GIC_SPI 0x34 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x3 &gic 0x0 0x0 GIC_SPI 0x35 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x4 &gic 0x0 0x0 GIC_SPI 0x36 IRQ_TYPE_LEVEL_HIGH>;
+			ranges = <0x01000000 0x00 0x00c00000 0x800 0x50c00000 0x00 0x00300000>,
+				 <0x02000000 0x00 0x78000000 0x800 0x78000000 0x00 0x08000000>,
+				 <0x03000000 0x38 0x00000000 0x838 0x00000000 0x08 0x00000000>;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/phytium/ft2000plus-SR-devboard-64c-dsk.dts b/arch/arm64/boot/dts/phytium/ft2000plus-SR-devboard-64c-dsk.dts
new file mode 100755
index 000000000000..3e3e1e4a1c38
--- /dev/null
+++ b/arch/arm64/boot/dts/phytium/ft2000plus-SR-devboard-64c-dsk.dts
@@ -0,0 +1,136 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * DTS file for Phytium FT-2000plus devboard.
+ *
+ * Copyright (C) 2019, Phytium Technology Co., Ltd.
+ */
+
+/dts-v1/;
+/memreserve/ 0x0000000080000000 0x0000000000010000;
+
+#include "ft2000plus-SR-psci-soc.dtsi"
+
+/ {
+	model = "FT-2000plus Development Board";
+	compatible = "phytium,ft-2000plus";
+
+	chosen {
+		linux,pci-probe-only = <1>;
+	};
+
+	/* NUMA Node-0 */
+        memory@00 {
+                device_type = "memory";
+		/* 0 - 512MiB (512MiB)*/
+                reg = <0x00000000 0x00000000 0x0 0x20000000>;
+                numa-node-id = <0>;
+        };
+        memory@01 {
+                device_type = "memory";
+		/* 2GiB - 4GiB (2GiB) */
+                reg = <0x00000000 0x80000000 0x0 0x80000000>;
+                numa-node-id = <0>;
+        };
+        memory@02 {
+                device_type = "memory";
+		/* 512GiB - 516GiB (4GiB) */
+                reg = <0x00000080 0x00000000 0x1 0x00000000>;
+                numa-node-id = <0>;
+        };
+	/* NUMA Node-1 */
+        memory@10 {
+                device_type = "memory";
+		/* 1024GiB - 1028GiB (4GiB) */
+                reg = <0x00000100 0x00000000 0x1 0x00000000>;
+                numa-node-id = <1>;
+        };
+        memory@11 {
+                device_type = "memory";
+		/* 1536GiB - 1540GiB (4GiB) */
+                reg = <0x00000180 0x00000000 0x1 0x00000000>;
+                numa-node-id = <1>;
+        };
+	/* NUMA Node-2 */
+        memory@20 {
+                device_type = "memory";
+		/* 2048GiB - 2052GiB (4GiB) */
+                reg = <0x00000200 0x00000000 0x1 0x00000000>;
+                numa-node-id = <2>;
+        };
+        memory@21 {
+                device_type = "memory";
+		/* 2560GiB - 2564GiB (4GiB) */
+                reg = <0x00000280 0x00000000 0x1 0x00000000>;
+                numa-node-id = <2>;
+        };
+	/* NUMA Node-3 */
+        memory@30 {
+                device_type = "memory";
+		/* 3072GiB - 3076GiB (4GiB) */
+                reg = <0x00000300 0x00000000 0x1 0x00000000>;
+                numa-node-id = <3>;
+        };
+        memory@31 {
+                device_type = "memory";
+		/* 3584GiB - 3588GiB (4GiB) */
+                reg = <0x00000380 0x00000000 0x1 0x00000000>;
+                numa-node-id = <3>;
+        };
+	/* NUMA Node-4 */
+        memory@40 {
+                device_type = "memory";
+		/* 4096GiB - 4100GiB (4GiB) */
+                reg = <0x00000400 0x00000000 0x1 0x00000000>;
+                numa-node-id = <4>;
+        };
+        memory@41 {
+                device_type = "memory";
+		/* 4608GiB - 4612GiB (4GiB) */
+                reg = <0x00000480 0x00000000 0x1 0x00000000>;
+                numa-node-id = <4>;
+        };
+	/* NUMA Node-5 */
+        memory@50 {
+                device_type = "memory";
+		/* 5120GiB - 5124GiB (4GiB) */
+                reg = <0x00000500 0x00000000 0x1 0x00000000>;
+                numa-node-id = <5>;
+        };
+        memory@51 {
+                device_type = "memory";
+		/* 5632GiB - 5636GiB (4GiB) */
+                reg = <0x00000580 0x00000000 0x1 0x00000000>;
+                numa-node-id = <5>;
+        };
+	/* NUMA Node-6 */
+        memory@60 {
+                device_type = "memory";
+		/* 6144GiB - 6148GiB (4GiB) */
+                reg = <0x00000600 0x00000000 0x1 0x00000000>;
+                numa-node-id = <6>;
+        };
+        memory@61 {
+                device_type = "memory";
+		/* 6656GiB - 6660GiB (4GiB) */
+                reg = <0x00000680 0x00000000 0x1 0x00000000>;
+                numa-node-id = <6>;
+        };
+	/* NUMA Node-7 */
+        memory@70 {
+                device_type = "memory";
+		/* 7168GiB - 7172GiB (4GiB) */
+                reg = <0x00000700 0x00000000 0x1 0x00000000>;
+                numa-node-id = <7>;
+        };
+        memory@71 {
+                device_type = "memory";
+		/* 7680GiB - 7684GiB (4GiB) */
+                reg = <0x00000780 0x00000000 0x1 0x00000000>;
+                numa-node-id = <7>;
+        };
+
+};
+
+&uart1 {
+	status = "ok";
+};
diff --git a/arch/arm64/boot/dts/phytium/ft2000plus-SR-psci-soc.dtsi b/arch/arm64/boot/dts/phytium/ft2000plus-SR-psci-soc.dtsi
new file mode 100755
index 000000000000..5b557908adbe
--- /dev/null
+++ b/arch/arm64/boot/dts/phytium/ft2000plus-SR-psci-soc.dtsi
@@ -0,0 +1,986 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * dts file for FT-2000plus SoC
+ *
+ * Copyright (C) 2018-2019, Phytium Technology Co., Ltd.
+ */
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+
+/ {
+	compatible = "phytium,ft2000plus";
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	psci {
+		compatible = "arm,psci-1.0";
+		method = "smc";
+		cpu_suspend = <0xc4000001>;
+		cpu_off = <0x84000002>;
+		cpu_on = <0xc4000003>;
+		sys_poweroff = <0x84000008>;
+		sys_reset = <0x84000009>;
+	};
+
+	cpus {
+		#address-cells = <0x2>;
+		#size-cells = <0x0>;
+
+		cpu-map {
+			cluster0 {
+				core0 {
+					cpu = <&cpu0>;
+				};
+				core1 {
+					cpu = <&cpu1>;
+				};
+				core2 {
+					cpu = <&cpu2>;
+				};
+				core3 {
+					cpu = <&cpu3>;
+				};
+			};
+
+			cluster1 {
+				core0 {
+					cpu = <&cpu4>;
+				};
+				core1 {
+					cpu = <&cpu5>;
+				};
+				core2 {
+					cpu = <&cpu6>;
+				};
+				core3 {
+					cpu = <&cpu7>;
+				};
+			};
+
+			cluster2 {
+				core0 {
+					cpu = <&cpu8>;
+				};
+				core1 {
+					cpu = <&cpu9>;
+				};
+				core2 {
+					cpu = <&cpu10>;
+				};
+				core3 {
+					cpu = <&cpu11>;
+				};
+			};
+
+			cluster3 {
+				core0 {
+					cpu = <&cpu12>;
+				};
+				core1 {
+					cpu = <&cpu13>;
+				};
+				core2 {
+					cpu = <&cpu14>;
+				};
+				core3 {
+					cpu = <&cpu15>;
+				};
+			};
+
+			cluster4 {
+				core0 {
+					cpu = <&cpu16>;
+				};
+				core1 {
+					cpu = <&cpu17>;
+				};
+				core2 {
+					cpu = <&cpu18>;
+				};
+				core3 {
+					cpu = <&cpu19>;
+				};
+			};
+
+			cluster5 {
+				core0 {
+					cpu = <&cpu20>;
+				};
+				core1 {
+					cpu = <&cpu21>;
+				};
+				core2 {
+					cpu = <&cpu22>;
+				};
+				core3 {
+					cpu = <&cpu23>;
+				};
+			};
+
+			cluster6 {
+				core0 {
+					cpu = <&cpu24>;
+				};
+				core1 {
+					cpu = <&cpu25>;
+				};
+				core2 {
+					cpu = <&cpu26>;
+				};
+				core3 {
+					cpu = <&cpu27>;
+				};
+			};
+
+			cluster7 {
+				core0 {
+					cpu = <&cpu28>;
+				};
+				core1 {
+					cpu = <&cpu29>;
+				};
+				core2 {
+					cpu = <&cpu30>;
+				};
+				core3 {
+					cpu = <&cpu31>;
+				};
+			};
+
+			cluster8 {
+				core0 {
+					cpu = <&cpu32>;
+				};
+				core1 {
+					cpu = <&cpu33>;
+				};
+				core2 {
+					cpu = <&cpu34>;
+				};
+				core3 {
+					cpu = <&cpu35>;
+				};
+			};
+
+			cluster9 {
+				core0 {
+					cpu = <&cpu36>;
+				};
+				core1 {
+					cpu = <&cpu37>;
+				};
+				core2 {
+					cpu = <&cpu38>;
+				};
+				core3 {
+					cpu = <&cpu39>;
+				};
+			};
+
+			cluster10 {
+				core0 {
+					cpu = <&cpu40>;
+				};
+				core1 {
+					cpu = <&cpu41>;
+				};
+				core2 {
+					cpu = <&cpu42>;
+				};
+				core3 {
+					cpu = <&cpu43>;
+				};
+			};
+
+			cluster11 {
+				core0 {
+					cpu = <&cpu44>;
+				};
+				core1 {
+					cpu = <&cpu45>;
+				};
+				core2 {
+					cpu = <&cpu46>;
+				};
+				core3 {
+					cpu = <&cpu47>;
+				};
+			};
+
+			cluster12 {
+				core0 {
+					cpu = <&cpu48>;
+				};
+				core1 {
+					cpu = <&cpu49>;
+				};
+				core2 {
+					cpu = <&cpu50>;
+				};
+				core3 {
+					cpu = <&cpu51>;
+				};
+			};
+
+			cluster13 {
+				core0 {
+					cpu = <&cpu52>;
+				};
+				core1 {
+					cpu = <&cpu53>;
+				};
+				core2 {
+					cpu = <&cpu54>;
+				};
+				core3 {
+					cpu = <&cpu55>;
+				};
+			};
+
+			cluster14 {
+				core0 {
+					cpu = <&cpu56>;
+				};
+				core1 {
+					cpu = <&cpu57>;
+				};
+				core2 {
+					cpu = <&cpu58>;
+				};
+				core3 {
+					cpu = <&cpu59>;
+				};
+			};
+
+			cluster15 {
+				core0 {
+					cpu = <&cpu60>;
+				};
+				core1 {
+					cpu = <&cpu61>;
+				};
+				core2 {
+					cpu = <&cpu62>;
+				};
+				core3 {
+					cpu = <&cpu63>;
+				};
+			};
+		};
+
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x0>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+		};
+
+		cpu1: cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x1>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+		};
+
+		cpu2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x2>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+		};
+
+		cpu3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x3>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+		};
+
+		cpu4: cpu@100 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x100>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+		};
+
+		cpu5: cpu@101 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x101>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+		};
+
+		cpu6: cpu@102 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x102>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+		};
+
+		cpu7: cpu@103 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x103>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+		};
+
+		cpu8: cpu@200 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x200>;
+			enable-method = "psci";
+			numa-node-id = <1>;
+		};
+
+		cpu9: cpu@201 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x201>;
+			enable-method = "psci";
+			numa-node-id = <1>;
+		};
+
+		cpu10: cpu@202 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x202>;
+			enable-method = "psci";
+			numa-node-id = <1>;
+		};
+
+		cpu11: cpu@203 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x203>;
+			enable-method = "psci";
+			numa-node-id = <1>;
+		};
+
+		cpu12: cpu@300 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x300>;
+			enable-method = "psci";
+			numa-node-id = <1>;
+		};
+
+		cpu13: cpu@301 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x301>;
+			enable-method = "psci";
+			numa-node-id = <1>;
+		};
+
+		cpu14: cpu@302 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x302>;
+			enable-method = "psci";
+			numa-node-id = <1>;
+		};
+
+		cpu15: cpu@303 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x303>;
+			enable-method = "psci";
+			numa-node-id = <1>;
+		};
+
+		cpu16: cpu@400 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x400>;
+			enable-method = "psci";
+			numa-node-id = <2>;
+		};
+
+		cpu17: cpu@401 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x401>;
+			enable-method = "psci";
+			numa-node-id = <2>;
+		};
+
+		cpu18: cpu@402 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x402>;
+			enable-method = "psci";
+			numa-node-id = <2>;
+		};
+
+		cpu19: cpu@403 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x403>;
+			enable-method = "psci";
+			numa-node-id = <2>;
+		};
+
+		cpu20: cpu@500 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x500>;
+			enable-method = "psci";
+			numa-node-id = <2>;
+		};
+
+		cpu21: cpu@501 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x501>;
+			enable-method = "psci";
+			numa-node-id = <2>;
+		};
+
+		cpu22: cpu@502 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x502>;
+			enable-method = "psci";
+			numa-node-id = <2>;
+		};
+
+		cpu23: cpu@503 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x503>;
+			enable-method = "psci";
+			numa-node-id = <2>;
+		};
+
+		cpu24: cpu@600 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x600>;
+			enable-method = "psci";
+			numa-node-id = <3>;
+		};
+
+		cpu25: cpu@601 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x601>;
+			enable-method = "psci";
+			numa-node-id = <3>;
+		};
+
+		cpu26: cpu@602 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x602>;
+			enable-method = "psci";
+			numa-node-id = <3>;
+		};
+
+		cpu27: cpu@603 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x603>;
+			enable-method = "psci";
+			numa-node-id = <3>;
+		};
+
+		cpu28: cpu@700 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x700>;
+			enable-method = "psci";
+			numa-node-id = <3>;
+		};
+
+		cpu29: cpu@701 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x701>;
+			enable-method = "psci";
+			numa-node-id = <3>;
+		};
+
+		cpu30: cpu@702 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x702>;
+			enable-method = "psci";
+			numa-node-id = <3>;
+		};
+
+		cpu31: cpu@703 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x703>;
+			enable-method = "psci";
+			numa-node-id = <3>;
+		};
+
+		cpu32: cpu@800 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x800>;
+			enable-method = "psci";
+			numa-node-id = <4>;
+		};
+
+		cpu33: cpu@801 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x801>;
+			enable-method = "psci";
+			numa-node-id = <4>;
+		};
+
+		cpu34: cpu@802 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x802>;
+			enable-method = "psci";
+			numa-node-id = <4>;
+		};
+
+		cpu35: cpu@803 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x803>;
+			enable-method = "psci";
+			numa-node-id = <4>;
+		};
+
+		cpu36: cpu@900 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x900>;
+			enable-method = "psci";
+			numa-node-id = <4>;
+		};
+
+		cpu37: cpu@901 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x901>;
+			enable-method = "psci";
+			numa-node-id = <4>;
+		};
+
+		cpu38: cpu@902 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x902>;
+			enable-method = "psci";
+			numa-node-id = <4>;
+		};
+
+		cpu39: cpu@903 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x903>;
+			enable-method = "psci";
+			numa-node-id = <4>;
+		};
+
+		cpu40: cpu@a00 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xa00>;
+			enable-method = "psci";
+			numa-node-id = <5>;
+		};
+
+		cpu41: cpu@a01 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xa01>;
+			enable-method = "psci";
+			numa-node-id = <5>;
+		};
+
+		cpu42: cpu@a02 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xa02>;
+			enable-method = "psci";
+			numa-node-id = <5>;
+		};
+
+		cpu43: cpu@a03 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xa03>;
+			enable-method = "psci";
+			numa-node-id = <5>;
+		};
+
+		cpu44: cpu@b00 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xb00>;
+			enable-method = "psci";
+			numa-node-id = <5>;
+		};
+
+		cpu45: cpu@b01 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xb01>;
+			enable-method = "psci";
+			numa-node-id = <5>;
+		};
+
+		cpu46: cpu@b02 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xb02>;
+			enable-method = "psci";
+			numa-node-id = <5>;
+		};
+
+		cpu47: cpu@b03 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xb03>;
+			enable-method = "psci";
+			numa-node-id = <5>;
+		};
+
+		cpu48: cpu@c00 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xc00>;
+			enable-method = "psci";
+			numa-node-id = <6>;
+		};
+
+		cpu49: cpu@c01 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xc01>;
+			enable-method = "psci";
+			numa-node-id = <6>;
+		};
+
+		cpu50: cpu@c02 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xc02>;
+			enable-method = "psci";
+			numa-node-id = <6>;
+		};
+
+		cpu51: cpu@c03 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xc03>;
+			enable-method = "psci";
+			numa-node-id = <6>;
+		};
+
+		cpu52: cpu@d00 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xd00>;
+			enable-method = "psci";
+			numa-node-id = <6>;
+		};
+
+		cpu53: cpu@d01 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xd01>;
+			enable-method = "psci";
+			numa-node-id = <6>;
+		};
+
+		cpu54: cpu@d02 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xd02>;
+			enable-method = "psci";
+			numa-node-id = <6>;
+		};
+
+		cpu55: cpu@d03 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xd03>;
+			enable-method = "psci";
+			numa-node-id = <6>;
+		};
+
+		cpu56: cpu@e00 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xe00>;
+			enable-method = "psci";
+			numa-node-id = <7>;
+		};
+
+		cpu57: cpu@e01 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xe01>;
+			enable-method = "psci";
+			numa-node-id = <7>;
+		};
+
+		cpu58: cpu@e02 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xe02>;
+			enable-method = "psci";
+			numa-node-id = <7>;
+		};
+
+		cpu59: cpu@e03 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xe03>;
+			enable-method = "psci";
+			numa-node-id = <7>;
+		};
+
+		cpu60: cpu@f00 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xf00>;
+			enable-method = "psci";
+			numa-node-id = <7>;
+		};
+
+		cpu61: cpu@f01 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xf01>;
+			enable-method = "psci";
+			numa-node-id = <7>;
+		};
+
+		cpu62: cpu@f02 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xf02>;
+			enable-method = "psci";
+			numa-node-id = <7>;
+		};
+
+		cpu63: cpu@f03 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0xf03>;
+			enable-method = "psci";
+			numa-node-id = <7>;
+		};
+	};
+
+	distance-map {
+		compatible = "numa-distance-map-v1";
+		distance-matrix = <0x0 0x0 0x0a>,
+				  <0x0 0x1 0x14>,
+				  <0x0 0x2 0x28>,
+				  <0x0 0x3 0x1e>,
+				  <0x0 0x4 0x14>,
+				  <0x0 0x5 0x1e>,
+				  <0x0 0x6 0x32>,
+				  <0x0 0x7 0x28>,
+				  <0x1 0x0 0x14>,
+				  <0x1 0x1 0x0a>,
+				  <0x1 0x2 0x1e>,
+				  <0x1 0x3 0x14>,
+				  <0x1 0x4 0x1e>,
+				  <0x1 0x5 0x14>,
+				  <0x1 0x6 0x28>,
+				  <0x1 0x7 0x1e>,
+				  <0x2 0x0 0x28>,
+				  <0x2 0x1 0x1e>,
+				  <0x2 0x2 0x0a>,
+				  <0x2 0x3 0x14>,
+				  <0x2 0x4 0x32>,
+				  <0x2 0x5 0x28>,
+				  <0x2 0x6 0x14>,
+				  <0x2 0x7 0x1e>,
+				  <0x3 0x0 0x1e>,
+				  <0x3 0x1 0x14>,
+				  <0x3 0x2 0x14>,
+				  <0x3 0x3 0x0a>,
+				  <0x3 0x4 0x28>,
+				  <0x3 0x5 0x1e>,
+				  <0x3 0x6 0x1e>,
+				  <0x3 0x7 0x14>,
+				  <0x4 0x0 0x14>,
+				  <0x4 0x1 0x1e>,
+				  <0x4 0x2 0x32>,
+				  <0x4 0x3 0x28>,
+				  <0x4 0x4 0x0a>,
+				  <0x4 0x5 0x14>,
+				  <0x4 0x6 0x28>,
+				  <0x4 0x7 0x1e>,
+				  <0x5 0x0 0x1e>,
+				  <0x5 0x1 0x14>,
+				  <0x5 0x2 0x28>,
+				  <0x5 0x3 0x1e>,
+				  <0x5 0x4 0x14>,
+				  <0x5 0x5 0x0a>,
+				  <0x5 0x6 0x1e>,
+				  <0x5 0x7 0x14>,
+				  <0x6 0x0 0x32>,
+				  <0x6 0x1 0x28>,
+				  <0x6 0x2 0x14>,
+				  <0x6 0x3 0x1e>,
+				  <0x6 0x4 0x28>,
+				  <0x6 0x5 0x1e>,
+				  <0x6 0x6 0x0a>,
+				  <0x6 0x7 0x14>,
+				  <0x7 0x0 0x28>,
+				  <0x7 0x1 0x1e>,
+				  <0x7 0x2 0x1e>,
+				  <0x7 0x3 0x14>,
+				  <0x7 0x4 0x1e>,
+				  <0x7 0x5 0x14>,
+				  <0x7 0x6 0x14>,
+				  <0x7 0x7 0x0a>;
+	};
+
+
+	gic: interrupt-controller@8002a000000 {
+		compatible = "arm,gic-v3";
+                #interrupt-cells = <3>;
+                #address-cells = <2>;
+                #size-cells = <2>;
+		ranges;
+		interrupt-controller;
+		reg = <0x0800 0x2a000000 0 0x10000>,    /* GICD */
+		      <0x0800 0x2a800000 0 0x800000>,   /* GICR */
+		      <0x0800 0x29c00000 0 0x10000>,    /* GICC */
+		      <0x0800 0x29c10000 0 0x10000>,    /* GICH */
+		      <0x0800 0x29c20000 0 0x10000>;    /* GICV */
+		interrupts = <GIC_PPI 9 IRQ_TYPE_LEVEL_HIGH>;
+
+                its: gic-its@8002a020000 {
+                        compatible = "arm,gic-v3-its";
+                        msi-controller;
+                        reg = <0x0800 0x2a020000 0x0 0x20000>;
+                };
+	};
+
+        timer {
+                compatible = "arm,armv8-timer";
+                interrupts = <GIC_PPI 13 IRQ_TYPE_LEVEL_LOW>,
+                             <GIC_PPI 14 IRQ_TYPE_LEVEL_LOW>,
+                             <GIC_PPI 11 IRQ_TYPE_LEVEL_LOW>,
+                             <GIC_PPI 10 IRQ_TYPE_LEVEL_LOW>;
+                clock-frequency = <50000000>;
+        };
+
+	soc {
+		compatible = "simple-bus";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		dma-coherent;
+		ranges;
+
+                uart0: serial@28000000 {
+                        compatible = "snps,dw-apb-uart";
+                        reg = <0x800 0x28000000 0x0 0x1000>;
+                        clock-frequency = <50000000>;
+                        interrupts = <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>;
+                        reg-shift = <2>;
+                        reg-io-width = <4>;
+                        status = "disabled";
+                };
+
+                uart1: serial@28001000 {
+                        compatible = "snps,dw-apb-uart";
+                        reg = <0x800 0x28001000 0x0 0x1000>;
+                        clock-frequency = <50000000>;
+                        interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
+                        reg-shift = <2>;
+                        reg-io-width = <4>;
+                        status = "disabled";
+                };
+
+		gpio0:gpio@80028006000 {
+			compatible = "snps,dw-apb-gpio";
+			reg = <0x800 0x28006000 0x0 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "ok";
+
+			gpio-controller@0 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <0x2>;
+				snps,nr-gpios = <0x8>;
+				reg = <0x0>;
+			};
+
+			gpio-controller@1 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <0x2>;
+				snps,nr-gpios = <0x8>;
+				reg = <0x1>;
+			};
+
+			gpio-controller@2 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <0x2>;
+				snps,nr-gpios = <0x8>;
+				reg = <0x2>;
+			};
+
+			gpio-controller@3 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <0x2>;
+				snps,nr-gpios = <0x8>;
+				reg = <0x3>;
+			};
+		};
+
+		i2c0: i2c@80028002000 {
+			compatible = "snps,designware-i2c";
+			reg = <0x800 0x28002000 0x0 0x1000>;
+                        interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
+			clock-frequency = <100000>;
+			status = "ok";
+		};
+
+		i2c1: i2c@80028003000 {
+			compatible = "snps,designware-i2c";
+			reg = <0x800 0x28003000 0x0 0x1000>;
+                        interrupts = <GIC_SPI 37 IRQ_TYPE_LEVEL_HIGH>;
+			clock-frequency = <100000>;
+			status = "ok";
+		};
+
+		pcie0: pcie@80040000000 {
+			compatible = "pci-host-ecam-generic";
+			device_type = "pci";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			#interrupt-cells = <1>;
+			reg = <0x800 0x40000000 0 0x10000000>;
+			msi-parent = <&its>;
+			bus-range = <0 0xff>;
+			interrupt-map-mask = <0x0 0x0 0x0 0x7>;
+			interrupt-map = <0x0 0x0 0x0 0x1 &gic 0x0 0x0 GIC_SPI 0x33 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x2 &gic 0x0 0x0 GIC_SPI 0x34 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x3 &gic 0x0 0x0 GIC_SPI 0x35 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x4 &gic 0x0 0x0 GIC_SPI 0x36 IRQ_TYPE_LEVEL_HIGH>;
+			ranges = <0x01000000 0x00 0x00000000 0x800 0x50000000 0x00 0x00f00000>,
+				 <0x02000000 0x00 0x60000000 0x800 0x60000000 0x00 0x20000000>,
+				 <0x03000000 0x20 0x00000000 0x820 0x00000000 0x20 0x00000000>;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/phytium/ft2004-devboard-d4-dsk.dts b/arch/arm64/boot/dts/phytium/ft2004-devboard-d4-dsk.dts
new file mode 100755
index 000000000000..5bef2e886292
--- /dev/null
+++ b/arch/arm64/boot/dts/phytium/ft2004-devboard-d4-dsk.dts
@@ -0,0 +1,73 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * DTS file for phytium FT-2000/4 devboard (FT-2000/4-D4-DSK series)
+ *
+ * Copyright (C) 2018-2019, Phytium Technology Co., Ltd.
+ */
+
+/dts-v1/;
+/memreserve/ 0x80000000 0x10000;
+
+#include "ft2004-generic-psci-soc.dtsi"
+
+/{
+	model = "FT-2000/4-D4-DSK Development Board";
+	compatible = "phytium,ft-2004";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	chosen {
+		stdout-path = "uart1:115200n8";
+	};
+
+	memory@00{
+		device_type = "memory";
+		reg = <0x0 0x80000000 0x1 0x00000000>;
+	};
+
+	memory@01{
+		device_type = "memory";
+		reg = <0x20 0x00000000 0x1 0x00000000>;
+	};
+
+	firmware {
+		optee {
+			compatible = "linaro,optee-tz";
+			method = "smc";
+		};
+	};
+};
+
+&rtc0 {
+	status = "ok";
+};
+
+&uart1 {
+	status = "ok";
+};
+
+&gmac0 {
+	status = "ok";
+	phy-mode = "rgmii-rxid";
+};
+
+&gmac1 {
+	status = "ok";
+	phy-mode = "rgmii-rxid";
+};
+
+&spi0 {
+	status = "ok";
+};
+
+&qspi {
+	status = "ok";
+};
+
+&i2c0 {
+	status = "ok";
+};
+
+&i2c1 {
+	status = "ok";
+};
diff --git a/arch/arm64/boot/dts/phytium/ft2004-generic-psci-soc.dtsi b/arch/arm64/boot/dts/phytium/ft2004-generic-psci-soc.dtsi
new file mode 100755
index 000000000000..9d28335ddaef
--- /dev/null
+++ b/arch/arm64/boot/dts/phytium/ft2004-generic-psci-soc.dtsi
@@ -0,0 +1,474 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * dts file for FT-2000/4 SoC
+ *
+ * Copyright (C) 2018-2019, Phytium Technology Co., Ltd.
+ */
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+
+/ {
+	compatible = "phytium,ft2004";
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	aliases {
+		ethernet0 = &gmac0;
+		ethernet1 = &gmac1;
+	};
+
+	psci {
+		compatible   = "arm,psci-1.0";
+		method       = "smc";
+		cpu_suspend  = <0xc4000001>;
+		cpu_off      = <0x84000002>;
+		cpu_on       = <0xc4000003>;
+		sys_poweroff = <0x84000008>;
+		sys_reset    = <0x84000009>;
+	};
+
+	cpus {
+		#address-cells = <0x2>;
+		#size-cells = <0x0>;
+
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x0>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+			clocks = <&scpi_dvfs 0>;
+		};
+
+		cpu1: cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x1>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+			clocks = <&scpi_dvfs 0>;
+		};
+
+		cpu2: cpu@100 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x100>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+			clocks = <&scpi_dvfs 1>;
+		};
+
+		cpu3: cpu@101 {
+			device_type = "cpu";
+			compatible = "arm,armv8";
+			reg = <0x0 0x101>;
+			enable-method = "psci";
+			numa-node-id = <0>;
+			clocks = <&scpi_dvfs 1>;
+		};
+	};
+
+	gic: interrupt-controller@29900000 {
+		compatible = "arm,gic-v3";
+		#interrupt-cells = <3>;
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		interrupt-controller;
+		reg = <0x0 0x29900000 0 0x20000>,       /* GICD */
+		      <0x0 0x29980000 0 0x80000>,       /* GICR */
+		      <0x0 0x29c00000 0 0x10000>,       /* GICC */
+		      <0x0 0x29c10000 0 0x10000>,       /* GICH */
+		      <0x0 0x29c20000 0 0x10000>;       /* GICV */
+		interrupts = <GIC_PPI 9 IRQ_TYPE_LEVEL_HIGH>;
+
+		its: gic-its@29920000 {
+			compatible = "arm,gic-v3-its";
+			msi-controller;
+			reg = <0x0 0x29920000 0x0 0x20000>;
+		};
+	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		interrupts = <GIC_PPI 13 IRQ_TYPE_LEVEL_LOW>,
+			     <GIC_PPI 14 IRQ_TYPE_LEVEL_LOW>,
+			     <GIC_PPI 11 IRQ_TYPE_LEVEL_LOW>,
+			     <GIC_PPI 10 IRQ_TYPE_LEVEL_LOW>;
+		clock-frequency = <48000000>;
+	};
+
+	pmu {
+		compatible = "arm,armv8-pmuv3";
+		interrupts = <GIC_PPI 7 IRQ_TYPE_LEVEL_LOW>;
+	};
+
+	clocks {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		clk250mhz: clk250mhz {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <250000000>;
+		};
+
+		sysclk_48mhz: clk48mhz {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <48000000>;
+		};
+
+		sysclk_600mhz: clk600mhz {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <600000000>;
+		};
+	};
+
+	soc {
+		compatible = "simple-bus";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		dma-coherent;
+		ranges;
+
+		gpio0: gpio@28004000 {
+			compatible = "phytium,gpio";
+			reg = <0x0 0x28004000 0x0 0x1000>;
+			interrupts = <GIC_SPI 10 IRQ_TYPE_LEVEL_HIGH>;
+			gpio-controller;
+			#gpio-cells = <2>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			porta {
+				compatible = "phytium,gpio-port";
+				reg = <0>;
+				nr-gpios = <8>;
+			};
+
+			portb {
+				compatible = "phytium,gpio-port";
+				reg = <1>;
+				nr-gpios = <8>;
+			};
+		};
+
+		gpio1: gpio@28005000 {
+			compatible = "phytium,gpio";
+			reg = <0x0 0x28005000 0x0 0x1000>;
+			interrupts = <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>;
+			gpio-controller;
+			#gpio-cells = <2>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			porta {
+				compatible = "phytium,gpio-port";
+				reg = <0>;
+				nr-gpios = <8>;
+			};
+
+			portb {
+				compatible = "phytium,gpio-port";
+				reg = <1>;
+				nr-gpios = <8>;
+			};
+		};
+
+		uart0: uart@28000000 {
+			compatible = "arm,pl011", "arm,primecell";
+			reg = <0x0 0x28000000 0x0 0x1000>;
+			baud = <115200>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			interrupts = <GIC_SPI 6 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_48mhz &sysclk_48mhz>;
+			clock-names = "uartclk", "apb_pclk";
+		};
+
+		uart1: uart@28001000 {
+			compatible = "arm,pl011", "arm,primecell";
+			reg = <0x0 0x28001000 0x0 0x1000>;
+			baud = <115200>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			interrupts = <GIC_SPI 7 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_48mhz &sysclk_48mhz>;
+			clock-names = "uartclk", "apb_pclk";
+		};
+
+		uart2: uart@28002000 {
+			compatible = "arm,pl011", "arm,primecell";
+			reg = <0x0 0x28002000 0x0 0x1000>;
+			baud = <115200>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			interrupts = <GIC_SPI 8 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_48mhz &sysclk_48mhz>;
+			clock-names = "uartclk", "apb_pclk";
+		};
+
+		uart3: uart@28003000 {
+			compatible = "arm,pl011", "arm,primecell";
+			reg = <0x0 0x28003000 0x0 0x1000>;
+			baud = <115200>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			interrupts = <GIC_SPI 9 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_48mhz &sysclk_48mhz>;
+			clock-names = "uartclk", "apb_pclk";
+		};
+
+		sdci: sdci@28207c00 {
+			compatible = "phytium,sdci";
+			reg = <0x0 0x28207c00 0x0 0x100>;
+			interrupts = <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 22 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_600mhz &sysclk_600mhz>;
+			clock-names = "phytium_sdc_clk";
+			no-sdio;
+			no-mmc;
+			no-dma-coherent;
+		};
+
+		watchdog0: watchdog@2800a000 {
+			compatible = "arm,sbsa-gwdt";
+			reg = <0x0 0x2800b000 0x0 0x1000>,
+			      <0x0 0x2800a000 0x0 0x1000>;
+			interrupts = <GIC_SPI 16 IRQ_TYPE_LEVEL_HIGH>;
+			timeout-sec = <30>;
+		};
+
+		watchdog1: watchdog@28016000 {
+			compatible = "arm,sbsa-gwdt";
+			reg = <0x0 0x28017000 0x0 0x1000>,
+			      <0x0 0x28016000 0x0 0x1000>;
+			interrupts = <GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH>;
+			timeout-sec = <30>;
+		};
+
+		rtc0: rtc@2800d000 {
+			compatible = "phytium,rtc";
+			reg = <0x0 0x2800d000 0x0 0x1000>;
+			clocks = <&sysclk_48mhz>;
+			clock-names = "rtc_pclk";
+			interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		i2c0: i2c@28006000 {
+			compatible = "snps,designware-i2c";
+			reg = <0x0 0x28006000 0x0 0x1000>;
+			interrupts = <GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_48mhz>;
+			status = "disabled";
+		};
+
+		i2c1: i2c@28007000 {
+			compatible = "snps,designware-i2c";
+			reg = <0x0 0x28007000 0x0 0x1000>;
+			interrupts = <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_48mhz>;
+			status = "disabled";
+		};
+
+		i2c2: i2c@28008000 {
+			compatible = "snps,designware-i2c";
+			reg = <0x0 0x28008000 0x0 0x1000>;
+			interrupts = <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_48mhz>;
+			status = "disabled";
+		};
+
+		i2c3: i2c@28009000 {
+			compatible = "snps,designware-i2c";
+			reg = <0x0 0x28009000 0x0 0x1000>;
+			interrupts = <GIC_SPI 15 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_48mhz>;
+			status = "disabled";
+		};
+
+		spi0: spi@2800c000 {
+			compatible = "phytium,spi";
+			interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>;
+			reg = <0x0 0x2800c000 0x0 0x1000>;
+			clocks = <&sysclk_48mhz>;
+			num-cs = <4>;
+		};
+
+		spi1: spi@28013000 {
+			compatible = "phytium,spi";
+			interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>;
+			reg = <0x0 0x28013000 0x0 0x1000>;
+			clocks = <&sysclk_48mhz>;
+			num-cs = <4>;
+		};
+
+		qspi: qspi@28014000 {
+			compatible = "phytium,qspi";
+			reg = <0x0 0x28014000 0x0     0x1000>,
+			      <0x0        0x0 0x0 0x02000000>;
+			reg-names = "qspi", "qspi_mm";
+			clocks = <&sysclk_600mhz>;
+
+			flash@0 {
+				spi-rx-bus-width = <1>;
+				spi-max-frequency = <600000000>;
+			};
+		};
+
+		pcie: pcie {
+			compatible = "pci-host-ecam-generic";
+			device_type = "pci";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			#interrupt-cells = <1>;
+			reg = <0x0 0x40000000 0x0 0x10000000>;
+			msi-parent = <&its>;
+			bus-range = <0x0 0xff>;
+			interrupt-map-mask = <0x0 0x0 0x0 0x7>;
+			interrupt-map = <0x0 0x0 0x0 0x1 &gic 0x0 0x0 GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x2 &gic 0x0 0x0 GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x3 &gic 0x0 0x0 GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>,
+					<0x0 0x0 0x0 0x4 &gic 0x0 0x0 GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>;
+			ranges = <0x01000000 0x00 0x00000000 0x0  0x50000000  0x0  0x00f00000>,
+				 <0x02000000 0x00 0x58000000 0x0  0x58000000  0x0  0x28000000>,
+				 <0x03000000 0x10 0x00000000 0x10 0x00000000 0x10  0x00000000>;
+		};
+
+		phytium_axi_setup: stmmac-axi-config {
+			snps,wr_osr_lmt = <0>;
+			snps,rd_osr_lmt = <0>;
+			snps,blen = <0 0 0 0 16 8 4>;
+		};
+
+		gmac0: eth@2820c000 {
+			compatible = "snps,dwmac";
+			reg = <0x0 0x2820c000 0x0 0x2000>;
+			interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq";
+			clocks = <&clk250mhz>;
+			clock-names = "stmmaceth";
+			status = "disabled";
+
+			snps,pbl = <16>;
+			snps,fixed-burst;
+			snps,axi-config = <&phytium_axi_setup>;
+			snps,force_sf_dma_mode;
+			snps,multicast-filter-bins = <64>;
+			snps,perfect-filter-entries = <128>;
+			tx-fifo-depth = <4096>;
+			rx-fifo-depth = <4096>;
+			max-frame-size = <9000>;
+		};
+
+		gmac1: eth@28210000 {
+			compatible = "snps,dwmac";
+			reg = <0x0 0x28210000 0x0 0x2000>;
+			interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq";
+			clocks = <&clk250mhz>;
+			clock-names = "stmmaceth";
+			status = "disabled";
+
+			snps,pbl = <16>;
+			snps,fixed-burst;
+			snps,axi-config = <&phytium_axi_setup>;
+			snps,force_sf_dma_mode;
+			snps,multicast-filter-bins = <64>;
+			snps,perfect-filter-entries = <128>;
+			snps,rx-queues-to-use = <2>;
+			tx-fifo-depth = <4096>;
+			rx-fifo-depth = <4096>;
+			max-frame-size = <9000>;
+		};
+
+		can0: can@28207000 {
+			compatible = "phytium,can";
+			reg = <0x0 0x28207000 0x0 0x400>;
+			interrupts = <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_600mhz>;
+			clock-names = "phytium_can_clk";
+			tx-fifo-depth = <0x40>;
+			rx-fifo-depth = <0x40>;
+		};
+
+		can1: can@28207400 {
+			compatible = "phytium,can";
+			reg = <0x0 0x28207400 0x0 0x400>;
+			interrupts = <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_600mhz>;
+			clock-names = "phytium_can_clk";
+			tx-fifo-depth = <0x40>;
+			rx-fifo-depth = <0x40>;
+		};
+
+		can2: can@028207800 {
+			compatible = "phytium,can";
+			reg = <0x0 0x28207800 0x0 0x400>;
+			interrupts = <GIC_SPI 92 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_600mhz>;
+			clock-names = "phytium_can_clk";
+			tx-fifo-depth = <0x40>;
+			rx-fifo-depth = <0x40>;
+		};
+
+		hda: hda@28206000 {
+			compatible = "phytium,hda";
+			reg = <0 0x28206000 0x0 0x1000>;
+			interrupts = <GIC_SPI 23 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk_48mhz>;
+			clock-names = "phytium_hda_clk";
+		};
+
+		mbox: mailbox@2a000000 {
+			compatible = "phytium,mbox";
+			reg = <0x0 0x2a000000 0x0 0x1000>;
+			interrupts = <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
+			#mbox-cells = <1>;
+			clocks = <&sysclk_48mhz>;
+			clock-names = "apb_pclk";
+		};
+
+		sram: sram@2a006000 {
+			compatible = "phytium,ft2004-sram-ns","mmio-sram";
+			reg = <0x0 0x2a006000 0x0 0x2000>;
+
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x0 0x0 0x2a006000 0x2000>;
+
+			scpi_lpri: scpi-shmem@0 {
+				compatible = "phytium,ft2004-scpi-shmem";
+				reg = <0x1000 0x800>;
+			};
+		};
+
+		scpi_protocol: scpi {
+			compatible = "arm,scpi";
+			mboxes = <&mbox 0>;
+			shmem = <&scpi_lpri>;
+
+			clocks {
+				compatible = "arm,scpi-clocks";
+
+				scpi_dvfs: scpi_clocks@0 {
+					compatible = "arm,scpi-dvfs-clocks";
+					#clock-cells = <1>;
+					clock-indices = <0>, <1>;
+					clock-output-names = "c0", "c1";
+				};
+			};
+
+			scpi_sensors: sensors {
+				compatible = "arm,scpi-sensors";
+				#thermal-sensor-cells = <1>;
+			};
+		};
+	};
+};
diff --git a/arch/arm64/include/asm/cputype.h b/arch/arm64/include/asm/cputype.h
index ef5b040dee44..599365b21417 100644
--- a/arch/arm64/include/asm/cputype.h
+++ b/arch/arm64/include/asm/cputype.h
@@ -57,6 +57,7 @@
 #define ARM_CPU_IMP_BRCM		0x42
 #define ARM_CPU_IMP_QCOM		0x51
 #define ARM_CPU_IMP_NVIDIA		0x4E
+#define ARM_CPU_IMP_PHYTIUM             0x70
 #define ARM_CPU_IMP_FUJITSU		0x46
 #define ARM_CPU_IMP_HISI		0x48
 
@@ -95,6 +96,8 @@
 #define NVIDIA_CPU_PART_DENVER		0x003
 #define NVIDIA_CPU_PART_CARMEL		0x004
 
+#define PHYTIUM_CPU_PART_FTC662         0x662
+
 #define FUJITSU_CPU_PART_A64FX		0x001
 
 #define HISI_CPU_PART_TSV110		0xD01
@@ -133,6 +136,8 @@
 #define MIDR_FUJITSU_ERRATUM_010001_MASK	(~MIDR_CPU_VAR_REV(1, 0))
 #define TCR_CLEAR_FUJITSU_ERRATUM_010001	(TCR_NFD1 | TCR_NFD0)
 
+#define MIDR_PHYTIUM_FT2000PLUS MIDR_CPU_MODEL(ARM_CPU_IMP_PHYTIUM, PHYTIUM_CPU_PART_FTC662)
+
 #ifndef __ASSEMBLY__
 
 #include <asm/sysreg.h>
diff --git a/arch/arm64/include/asm/smp.h b/arch/arm64/include/asm/smp.h
index 8c5d2d650b8a..1ed70ee9fa82 100644
--- a/arch/arm64/include/asm/smp.h
+++ b/arch/arm64/include/asm/smp.h
@@ -55,6 +55,8 @@ static inline void set_cpu_logical_map(int cpu, u64 hwid)
 
 struct seq_file;
 
+extern void handle_IPI(int ipinr, struct pt_regs *regs);
+extern void set_smp_cross_call(void (*)(const struct cpumask *, unsigned int));
 /*
  * Discover the set of possible CPUs and determine their
  * SMP operations.
diff --git a/arch/arm64/kernel/smp.c b/arch/arm64/kernel/smp.c
index fb6007dab18c..b47e98fdb661 100644
--- a/arch/arm64/kernel/smp.c
+++ b/arch/arm64/kernel/smp.c
@@ -966,6 +966,13 @@ void __init smp_prepare_cpus(unsigned int max_cpus)
 	}
 }
 
+void (*__smp_cross_call)(const struct cpumask *, unsigned int);
+
+void __init set_smp_cross_call(void (*fn)(const struct cpumask *, unsigned int))
+{
+	__smp_cross_call = fn;
+}
+
 static const char *ipi_types[NR_IPI] __tracepoint_string = {
 #define S(x,s)	[x] = s
 	S(IPI_RESCHEDULE, "Rescheduling interrupts"),
@@ -1151,6 +1158,80 @@ static irqreturn_t ipi_handler(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
+/*
+ * Main handler for inter-processor interrupts
+ */
+void handle_IPI(int ipinr, struct pt_regs *regs)
+{
+	unsigned int cpu = smp_processor_id();
+	struct pt_regs *old_regs = set_irq_regs(regs);
+
+	if ((unsigned)ipinr < NR_IPI) {
+		trace_ipi_entry_rcuidle(ipi_types[ipinr]);
+//		__inc_irq_stat(cpu, ipi_irqs[ipinr]);
+	}
+
+	switch (ipinr) {
+	case IPI_RESCHEDULE:
+		scheduler_ipi();
+		break;
+
+	case IPI_CALL_FUNC:
+//		irq_enter();
+		generic_smp_call_function_interrupt();
+//		irq_exit();
+		break;
+
+	case IPI_CPU_STOP:
+//		irq_enter();
+//		ipi_cpu_stop(cpu);
+//		irq_exit();
+		local_cpu_stop();
+		break;
+
+	case IPI_CPU_CRASH_STOP:
+		if (IS_ENABLED(CONFIG_KEXEC_CORE)) {
+//			irq_enter();
+			ipi_cpu_crash_stop(cpu, regs);
+
+			unreachable();
+		}
+		break;
+
+#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST
+	case IPI_TIMER:
+//		irq_enter();
+		tick_receive_broadcast();
+//		irq_exit();
+		break;
+#endif
+
+#ifdef CONFIG_IRQ_WORK
+	case IPI_IRQ_WORK:
+//		irq_enter();
+		irq_work_run();
+//		irq_exit();
+		break;
+#endif
+
+#ifdef CONFIG_ARM64_ACPI_PARKING_PROTOCOL
+	case IPI_WAKEUP:
+		WARN_ONCE(!acpi_parking_protocol_valid(cpu),
+			  "CPU%u: Wake-up IPI outside the ACPI parking protocol\n",
+			  cpu);
+		break;
+#endif
+
+	default:
+		pr_crit("CPU%u: Unknown IPI message 0x%x\n", cpu, ipinr);
+		break;
+	}
+
+	if ((unsigned)ipinr < NR_IPI)
+		trace_ipi_exit_rcuidle(ipi_types[ipinr]);
+	set_irq_regs(old_regs);
+}
+
 static void smp_cross_call(const struct cpumask *target, unsigned int ipinr)
 {
 	trace_ipi_raise(target, ipi_types[ipinr]);
diff --git a/drivers/acpi/acpi_apd.c b/drivers/acpi/acpi_apd.c
index 645e82a66bb0..831c2398e554 100644
--- a/drivers/acpi/acpi_apd.c
+++ b/drivers/acpi/acpi_apd.c
@@ -158,6 +158,11 @@ static const struct apd_device_desc hip08_lite_i2c_desc = {
 	.fixed_clk_rate = 125000000,
 };
 
+static const struct apd_device_desc phytium_i2c_desc = {
+	.setup = acpi_apd_setup,
+	.fixed_clk_rate = 200000000,
+};
+
 static const struct apd_device_desc thunderx2_i2c_desc = {
 	.setup = acpi_apd_setup,
 	.fixed_clk_rate = 125000000,
@@ -241,6 +246,7 @@ static const struct acpi_device_id acpi_apd_device_ids[] = {
 	{ "HISI02A3", APD_ADDR(hip08_lite_i2c_desc) },
 	{ "HISI0173", APD_ADDR(hip08_spi_desc) },
 	{ "NXP0001", APD_ADDR(nxp_i2c_desc) },
+	{ "PHYT0003", APD_ADDR(phytium_i2c_desc) },
 #endif
 	{ }
 };
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index 630a7dd257b1..64196e19d2eb 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -457,6 +457,15 @@ config GPIO_OMAP
 	help
 	  Say yes here to enable GPIO support for TI OMAP SoCs.
 
+config GPIO_PHYTIUM
+        tristate "Phytium GPIO support"
+        default y if ARCH_PHYTIUM
+        depends on ARM64
+        select IRQ_DOMAIN
+        select GENERIC_IRQ_CHIP
+        help
+          Say yes here to enable GPIO support for Phytium SoCs.
+
 config GPIO_PL061
 	tristate "PrimeCell PL061 GPIO support"
 	depends on ARM_AMBA
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index a66b89e3d0c3..008921fb0e28 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -95,6 +95,7 @@ obj-$(CONFIG_GPIO_MC33880)		+= gpio-mc33880.o
 obj-$(CONFIG_GPIO_MC9S08DZ60)		+= gpio-mc9s08dz60.o
 obj-$(CONFIG_GPIO_MENZ127)		+= gpio-menz127.o
 obj-$(CONFIG_GPIO_MERRIFIELD)		+= gpio-merrifield.o
+obj-$(CONFIG_GPIO_PHYTIUM)              += gpio-phytium.o
 obj-$(CONFIG_GPIO_ML_IOH)		+= gpio-ml-ioh.o
 obj-$(CONFIG_GPIO_MLXBF)		+= gpio-mlxbf.o
 obj-$(CONFIG_GPIO_MLXBF2)		+= gpio-mlxbf2.o
diff --git a/drivers/gpio/gpio-phytium.c b/drivers/gpio/gpio-phytium.c
new file mode 100755
index 000000000000..ae3993e17837
--- /dev/null
+++ b/drivers/gpio/gpio-phytium.c
@@ -0,0 +1,618 @@
+/*
+ * Support functions for Phytium GPIO
+ *
+ * Copyright (c) 2019, Phytium Corporation.
+ * Written by Chen Baozi <chenbaozi@phytium.com.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/acpi.h>
+#include <linux/err.h>
+#include <linux/gpio/driver.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/bitops.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/property.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+
+#include "gpiolib.h"
+
+#define GPIO_SWPORTA_DR		0x00 /* WR Port A Output Data Register */
+#define GPIO_SWPORTA_DDR	0x04 /* WR Port A Data Direction Register */
+#define GPIO_EXT_PORTA		0x08 /* RO Port A Input Data Register */
+#define GPIO_SWPORTB_DR		0x0c /* WR Port B Output Data Register */
+#define GPIO_SWPORTB_DDR	0x10 /* WR Port B Data Direction Register */
+#define GPIO_EXT_PORTB		0x14 /* RO Port B Input Data Register */
+
+#define GPIO_INTEN		0x18 /* WR Port A Interrput Enable Register */
+#define GPIO_INTMASK		0x1c /* WR Port A Interrupt Mask Register */
+#define GPIO_INTTYPE_LEVEL	0x20 /* WR Port A Interrupt Level Register */
+#define GPIO_INT_POLARITY	0x24 /* WR Port A Interrupt Polarity Register */
+#define GPIO_INTSTATUS		0x28 /* RO Port A Interrupt Status Register */
+#define GPIO_RAW_INTSTATUS	0x2c /* RO Port A Raw Interrupt Status Register */
+#define GPIO_LS_SYNC		0x30 /* WR Level-sensitive Synchronization Enable Register */
+#define GPIO_DEBOUNCE		0x34 /* WR Debounce Enable Register */
+#define GPIO_PORTA_EOI		0x38 /* WO Port A Clear Interrupt Register */
+
+#define MAX_NPORTS		2
+#define NGPIO_DEFAULT		8
+#define NGPIO_MAX		32
+#define GPIO_PORT_STRIDE	(GPIO_EXT_PORTB - GPIO_EXT_PORTA)
+
+struct pin_loc {
+	unsigned port;
+	unsigned offset;
+};
+
+#ifdef CONFIG_PM_SLEEP
+struct phytium_gpio_ctx {
+	u32 swporta_dr;
+	u32 swporta_ddr;
+	u32 ext_porta;
+	u32 swportb_dr;
+	u32 swportb_ddr;
+	u32 ext_portb;
+	u32 inten;
+	u32 intmask;
+	u32 inttype_level;
+	u32 int_polarity;
+	u32 intstatus;
+	u32 raw_intstatus;
+	u32 ls_sync;
+	u32 debounce;
+};
+#endif
+
+struct phytium_gpio {
+	raw_spinlock_t		lock;
+	void __iomem		*regs;
+	struct gpio_chip	gc;
+	unsigned int		ngpio[2];
+	int			irq;
+#ifdef CONFIG_PM_SLEEP
+	struct phytium_gpio_ctx	ctx;
+#endif
+};
+
+static int get_pin_location(struct phytium_gpio *gpio, unsigned int offset,
+			    struct pin_loc *pl)
+{
+	int ret;
+
+	if (offset < gpio->ngpio[0]) {
+		pl->port = 0;
+		pl->offset = offset;
+		ret = 0;
+	} else if (offset < (gpio->ngpio[0] + gpio->ngpio[1])) {
+		pl->port = 1;
+		pl->offset = offset - gpio->ngpio[0];
+		ret = 0;
+	} else {
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static void phytium_gpio_toggle_trigger(struct phytium_gpio *gpio,
+					unsigned int offset)
+{
+	struct gpio_chip *gc;
+	u32 pol;
+	int val;
+
+	/* Only port A can provide interrupt source */
+	if (offset >= gpio->ngpio[0])
+		return;
+
+	gc = &gpio->gc;
+
+	pol = readl(gpio->regs + GPIO_INT_POLARITY);
+	/* Just read the current value right out of the data register */
+	val = gc->get(gc, offset);
+	if (val)
+		pol &= ~BIT(offset);
+	else
+		pol |= ~BIT(offset);
+
+	writel(pol, gpio->regs + GPIO_INT_POLARITY);
+}
+
+static void phytium_gpio_irq_ack(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct phytium_gpio *gpio = gpiochip_get_data(gc);
+	u32 val = BIT(irqd_to_hwirq(d));
+
+	raw_spin_lock(&gpio->lock);
+
+	writel(val , gpio->regs + GPIO_PORTA_EOI);
+
+	raw_spin_unlock(&gpio->lock);
+}
+
+static void phytium_gpio_irq_mask(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct phytium_gpio *gpio = gpiochip_get_data(gc);
+	u32 val;
+
+	/* Only port A can provide interrupt source */
+	if (irqd_to_hwirq(d) >= gpio->ngpio[0])
+		return;
+
+	raw_spin_lock(&gpio->lock);
+
+	val = readl(gpio->regs + GPIO_INTMASK);
+	val |= BIT(irqd_to_hwirq(d));
+	writel(val, gpio->regs + GPIO_INTMASK);
+
+	raw_spin_unlock(&gpio->lock);
+}
+
+static void phytium_gpio_irq_unmask(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct phytium_gpio *gpio = gpiochip_get_data(gc);
+	u32 val;
+
+	/* Only port A can provide interrupt source */
+	if (irqd_to_hwirq(d) >= gpio->ngpio[0])
+		return;
+
+	raw_spin_lock(&gpio->lock);
+
+	val = readl(gpio->regs + GPIO_INTMASK);
+	val &= ~BIT(irqd_to_hwirq(d));
+	writel(val, gpio->regs + GPIO_INTMASK);
+
+	raw_spin_unlock(&gpio->lock);
+}
+
+static int phytium_gpio_irq_set_type(struct irq_data *d, unsigned int flow_type)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct phytium_gpio *gpio = gpiochip_get_data(gc);
+	int hwirq = irqd_to_hwirq(d);
+	unsigned long flags, lvl, pol;
+
+	if (hwirq < 0 || hwirq >= gpio->ngpio[0])
+		return -EINVAL;
+
+	if ((flow_type & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW)) &&
+	    (flow_type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING))) {
+		dev_err(gc->parent,
+			"trying to configure line %d for both level and edge "
+			"detection, choose one!\n",
+			hwirq);
+		return -EINVAL;
+	}
+
+	raw_spin_lock_irqsave(&gpio->lock, flags);
+
+	lvl = readl(gpio->regs + GPIO_INTTYPE_LEVEL);
+	pol = readl(gpio->regs + GPIO_INT_POLARITY);
+
+	switch (flow_type) {
+	case IRQ_TYPE_EDGE_BOTH:
+		lvl |= BIT(hwirq);
+		phytium_gpio_toggle_trigger(gpio, hwirq);
+		irq_set_handler_locked(d, handle_edge_irq);
+		dev_dbg(gc->parent, "line %d: IRQ on both edges\n", hwirq);
+		break;
+	case IRQ_TYPE_EDGE_RISING:
+		lvl |= BIT(hwirq);
+		pol |= BIT(hwirq);
+		irq_set_handler_locked(d, handle_edge_irq);
+		dev_dbg(gc->parent, "line %d: IRQ on RISING edge\n", hwirq);
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		lvl |= BIT(hwirq);
+		pol &= ~BIT(hwirq);
+		irq_set_handler_locked(d, handle_edge_irq);
+		dev_dbg(gc->parent, "line %d: IRQ on FALLING edge\n", hwirq);
+		break;
+	case IRQ_TYPE_LEVEL_HIGH:
+		lvl &= ~BIT(hwirq);
+		pol |= BIT(hwirq);
+		irq_set_handler_locked(d, handle_level_irq);
+		dev_dbg(gc->parent, "line %d: IRQ on HIGH level\n", hwirq);
+		break;
+	case IRQ_TYPE_LEVEL_LOW:
+		lvl &= ~BIT(hwirq);
+		pol &= ~BIT(hwirq);
+		irq_set_handler_locked(d, handle_level_irq);
+		dev_dbg(gc->parent, "line %d: IRQ on LOW level\n", hwirq);
+		break;
+	}
+
+	writel(lvl, gpio->regs + GPIO_INTTYPE_LEVEL);
+	if (flow_type != IRQ_TYPE_EDGE_BOTH)
+		writel(pol, gpio->regs + GPIO_INT_POLARITY);
+
+	raw_spin_unlock_irqrestore(&gpio->lock, flags);
+
+	return 0;
+}
+
+static void phytium_gpio_irq_enable(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct phytium_gpio *gpio = gpiochip_get_data(gc);
+	unsigned long flags;
+	u32 val;
+
+	/* Only port A can provide interrupt source */
+	if (irqd_to_hwirq(d) >= gpio->ngpio[0])
+		return;
+
+	raw_spin_lock_irqsave(&gpio->lock, flags);
+
+	val = readl(gpio->regs + GPIO_INTEN);
+	val |= BIT(irqd_to_hwirq(d));
+	writel(val, gpio->regs + GPIO_INTEN);
+
+	raw_spin_unlock_irqrestore(&gpio->lock, flags);
+}
+
+static void phytium_gpio_irq_disable(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct phytium_gpio *gpio = gpiochip_get_data(gc);
+	unsigned long flags;
+	u32 val;
+
+	/* Only port A can provide interrupt source */
+	if (irqd_to_hwirq(d) >= gpio->ngpio[0])
+		return;
+
+	raw_spin_lock_irqsave(&gpio->lock, flags);
+
+	val = readl(gpio->regs + GPIO_INTEN);
+	val &= ~BIT(irqd_to_hwirq(d));
+	writel(val, gpio->regs + GPIO_INTEN);
+
+	raw_spin_unlock_irqrestore(&gpio->lock, flags);
+}
+
+static void phytium_gpio_irq_handler(struct irq_desc *desc)
+{
+	struct gpio_chip *gc = irq_desc_get_handler_data(desc);
+	struct phytium_gpio *gpio = gpiochip_get_data(gc);
+	struct irq_chip *irqchip = irq_desc_get_chip(desc);
+	unsigned long pending;
+	int offset;
+
+	chained_irq_enter(irqchip, desc);
+
+	pending = readl(gpio->regs + GPIO_INTSTATUS);
+	if (pending) {
+		for_each_set_bit(offset, &pending, gpio->ngpio[0]) {
+			int gpio_irq = irq_find_mapping(gc->irq.domain,
+							offset);
+			generic_handle_irq(gpio_irq);
+
+			if ((irq_get_trigger_type(gpio_irq) &
+			    IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH)
+				phytium_gpio_toggle_trigger(gpio, offset);
+		}
+	}
+
+	chained_irq_exit(irqchip, desc);
+}
+
+static struct irq_chip phytium_gpio_irqchip = {
+	.name 			= "phytium_gpio",
+	.irq_ack		= phytium_gpio_irq_ack,
+	.irq_mask		= phytium_gpio_irq_mask,
+	.irq_unmask		= phytium_gpio_irq_unmask,
+	.irq_set_type		= phytium_gpio_irq_set_type,
+	.irq_enable		= phytium_gpio_irq_enable,
+	.irq_disable		= phytium_gpio_irq_disable,
+};
+
+static const struct of_device_id phytium_gpio_of_match[] = {
+	{ .compatible = "phytium,gpio", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, phytium_gpio_of_match);
+
+static const struct acpi_device_id phytium_gpio_acpi_match[] = {
+	{ "PHYT0001", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, phytium_gpio_acpi_match);
+
+static int phytium_gpio_get_direction(struct gpio_chip *gc, unsigned offset)
+{
+	struct phytium_gpio *gpio = gpiochip_get_data(gc);
+	struct pin_loc loc;
+	void __iomem *ddr;
+
+	if (get_pin_location(gpio, offset, &loc))
+		return -EINVAL;
+	ddr = gpio->regs + GPIO_SWPORTA_DDR + (loc.port * GPIO_PORT_STRIDE);
+
+	return !(readl(ddr) & BIT(loc.offset));
+}
+
+static int phytium_gpio_direction_input(struct gpio_chip *gc, unsigned offset)
+{
+	struct phytium_gpio *gpio = gpiochip_get_data(gc);
+	struct pin_loc loc;
+	unsigned long flags;
+	void __iomem *ddr;
+
+	if (get_pin_location(gpio, offset, &loc))
+		return -EINVAL;
+	ddr = gpio->regs + GPIO_SWPORTA_DDR + (loc.port * GPIO_PORT_STRIDE);
+
+	raw_spin_lock_irqsave(&gpio->lock, flags);
+
+	writel(readl(ddr) & ~(BIT(loc.offset)), ddr);
+
+	raw_spin_unlock_irqrestore(&gpio->lock, flags);
+
+	return 0;
+}
+
+static void phytium_gpio_set(struct gpio_chip *gc, unsigned offset, int value)
+{
+	struct phytium_gpio *gpio = gpiochip_get_data(gc);
+	struct pin_loc loc;
+	void __iomem *dr;
+	unsigned long flags;
+	u32 mask;
+
+	if (get_pin_location(gpio, offset, &loc))
+		return;
+	dr = gpio->regs + GPIO_SWPORTA_DR + (loc.port * GPIO_PORT_STRIDE);
+
+	raw_spin_lock_irqsave(&gpio->lock, flags);
+
+	if (value)
+		mask = readl(dr) | BIT(loc.offset);
+	else
+		mask = readl(dr) & ~BIT(loc.offset);
+
+	writel(mask, dr);
+
+	raw_spin_unlock_irqrestore(&gpio->lock, flags);
+
+	return;
+}
+
+static int phytium_gpio_direction_output(struct gpio_chip *gc, unsigned offset,
+					 int value)
+{
+	struct phytium_gpio *gpio = gpiochip_get_data(gc);
+	struct pin_loc loc;
+	unsigned long flags;
+	void __iomem *ddr;
+
+	if (get_pin_location(gpio, offset, &loc))
+		return -EINVAL;
+	ddr = gpio->regs + GPIO_SWPORTA_DDR + (loc.port * GPIO_PORT_STRIDE);
+
+	raw_spin_lock_irqsave(&gpio->lock, flags);
+
+	writel(readl(ddr) | BIT(loc.offset), ddr);
+
+	raw_spin_unlock_irqrestore(&gpio->lock, flags);
+
+	phytium_gpio_set(gc, offset, value);
+
+	return 0;
+}
+
+static int phytium_gpio_get(struct gpio_chip *gc, unsigned offset)
+{
+	struct phytium_gpio *gpio = gpiochip_get_data(gc);
+	struct pin_loc loc;
+	void __iomem *dat;
+
+	if (get_pin_location(gpio, offset, &loc))
+		return -EINVAL;
+
+	dat = gpio->regs + GPIO_EXT_PORTA + (loc.port * GPIO_PORT_STRIDE);
+
+	return !!(readl(dat) & BIT(loc.offset));
+}
+
+static int phytium_gpio_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	struct phytium_gpio *gpio;
+	struct gpio_irq_chip *girq;
+	struct fwnode_handle *fwnode;
+	int err;
+
+	gpio = devm_kzalloc(&pdev->dev, sizeof(*gpio), GFP_KERNEL);
+	if (!gpio)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	gpio->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(gpio->regs))
+		return PTR_ERR(gpio->regs);
+
+	gpio->irq = -ENXIO;
+	gpio->irq = platform_get_irq(pdev, 0);
+	if (gpio->irq < 0)
+		dev_warn(dev, "no irq is found.\n");
+
+	if (!device_get_child_node_count(dev))
+		return -ENODEV;
+
+	device_for_each_child_node(dev, fwnode) {
+		int idx;
+
+		if (fwnode_property_read_u32(fwnode, "reg", &idx) ||
+		    idx >= MAX_NPORTS) {
+			dev_err(dev, "missing/invalid port index\n");
+			fwnode_handle_put(fwnode);
+			return -EINVAL;
+		}
+
+		if (fwnode_property_read_u32(fwnode, "nr-gpios",
+					     &gpio->ngpio[idx])) {
+			dev_info(dev,
+				 "failed to get number of gpios for Port%c\n",
+				 idx ? 'B' : 'A');
+			gpio->ngpio[idx] = NGPIO_DEFAULT;
+		}
+	}
+
+	/* irq_chip support */
+	raw_spin_lock_init(&gpio->lock);
+
+	gpio->gc.base = -1;
+	gpio->gc.get_direction = phytium_gpio_get_direction;
+	gpio->gc.direction_input = phytium_gpio_direction_input;
+	gpio->gc.direction_output = phytium_gpio_direction_output;
+	gpio->gc.get = phytium_gpio_get;
+	gpio->gc.set = phytium_gpio_set;
+	gpio->gc.ngpio = gpio->ngpio[0] + gpio->ngpio[1];
+	gpio->gc.label = dev_name(dev);
+	gpio->gc.parent = dev;
+	gpio->gc.owner = THIS_MODULE;
+
+	girq = &(gpio->gc.irq);
+	girq->chip = &phytium_gpio_irqchip;
+	girq->parent_handler = phytium_gpio_irq_handler;
+	girq->num_parents = 1;
+	girq->parents = devm_kcalloc(&pdev->dev, 1,
+                                     sizeof(*girq->parents),
+                                     GFP_KERNEL);
+        if (!girq->parents) {
+                err = -ENOMEM;
+                goto err1;
+        }
+	girq->parents[0] = gpio->irq;
+        girq->default_type = IRQ_TYPE_NONE;
+        girq->handler = handle_bad_irq;
+
+	err = gpiochip_add_data(&gpio->gc, gpio);
+	if (err) {
+		dev_err(dev, "failed to register gpiochip\n");
+		goto err1;
+	}
+
+/*	err = gpiochip_irqchip_add(&gpio->gc, &phytium_gpio_irqchip,
+				   0, handle_bad_irq, IRQ_TYPE_NONE);
+	if (err) {
+		dev_info(dev, "could not add irqchip\n");
+		goto err0;
+	}
+	gpiochip_set_chained_irqchip(&gpio->gc, &phytium_gpio_irqchip,
+				     gpio->irq,
+				     phytium_gpio_irq_handler);
+*/
+
+
+	platform_set_drvdata(pdev, gpio);
+	dev_info(dev, "Phytium GPIO controller @%pa registered\n",
+		&res->start);
+
+	return 0;
+
+err1:
+	gpiochip_remove(&gpio->gc);
+err0:
+	return err;
+}
+
+static int phytium_gpio_remove(struct platform_device *pdev)
+{
+	struct phytium_gpio *gpio = platform_get_drvdata(pdev);
+
+	gpiochip_remove(&gpio->gc);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int phytium_gpio_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct phytium_gpio *gpio = platform_get_drvdata(pdev);
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&gpio->lock, flags);
+
+	gpio->ctx.swporta_dr = readl(gpio->regs + GPIO_SWPORTA_DR);
+	gpio->ctx.swporta_ddr = readl(gpio->regs + GPIO_SWPORTA_DDR);
+	gpio->ctx.ext_porta = readl(gpio->regs + GPIO_EXT_PORTA);
+	gpio->ctx.swportb_dr = readl(gpio->regs + GPIO_SWPORTB_DR);
+	gpio->ctx.swportb_ddr = readl(gpio->regs + GPIO_SWPORTB_DDR);
+	gpio->ctx.ext_portb = readl(gpio->regs + GPIO_EXT_PORTB);
+
+	gpio->ctx.inten = readl(gpio->regs + GPIO_INTEN);
+	gpio->ctx.intmask = readl(gpio->regs + GPIO_INTMASK);
+	gpio->ctx.inttype_level = readl(gpio->regs + GPIO_INTTYPE_LEVEL);
+	gpio->ctx.int_polarity = readl(gpio->regs + GPIO_INT_POLARITY);
+	gpio->ctx.debounce = readl(gpio->regs + GPIO_DEBOUNCE);
+
+	raw_spin_unlock_irqrestore(&gpio->lock, flags);
+
+	return 0;
+}
+
+static int phytium_gpio_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct phytium_gpio *gpio = platform_get_drvdata(pdev);
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&gpio->lock, flags);
+
+	writel(gpio->ctx.swporta_dr, gpio->regs + GPIO_SWPORTA_DR);
+	writel(gpio->ctx.swporta_ddr, gpio->regs + GPIO_SWPORTA_DDR);
+	writel(gpio->ctx.ext_porta, gpio->regs + GPIO_EXT_PORTA);
+	writel(gpio->ctx.swportb_dr, gpio->regs + GPIO_SWPORTB_DR);
+	writel(gpio->ctx.swportb_ddr, gpio->regs + GPIO_SWPORTB_DDR);
+	writel(gpio->ctx.ext_portb, gpio->regs + GPIO_EXT_PORTB);
+
+	writel(gpio->ctx.inten, gpio->regs + GPIO_INTEN);
+	writel(gpio->ctx.intmask, gpio->regs + GPIO_INTMASK);
+	writel(gpio->ctx.inttype_level, gpio->regs + GPIO_INTTYPE_LEVEL);
+	writel(gpio->ctx.int_polarity, gpio->regs + GPIO_INT_POLARITY);
+	writel(gpio->ctx.debounce, gpio->regs + GPIO_DEBOUNCE);
+
+	writel(0xffffffff, gpio->regs + GPIO_PORTA_EOI);
+
+	raw_spin_unlock_irqrestore(&gpio->lock, flags);
+
+	return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(phytium_gpio_pm_ops, phytium_gpio_suspend,
+			 phytium_gpio_resume);
+
+static struct platform_driver phytium_gpio_driver = {
+	.driver		= {
+		.name	= "gpio-phytium",
+		.pm	= &phytium_gpio_pm_ops,
+		.of_match_table = of_match_ptr(phytium_gpio_of_match),
+		.acpi_match_table = ACPI_PTR(phytium_gpio_acpi_match),
+	},
+	.probe		= phytium_gpio_probe,
+	.remove		= phytium_gpio_remove,
+};
+
+module_platform_driver(phytium_gpio_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Chen Baozi <chenbaozi@phytium.com.cn>");
+MODULE_DESCRIPTION("Phytium GPIO driver");
diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_device.c b/drivers/gpu/drm/amd/amdkfd/kfd_device.c
index 903170e59342..7ac58a9841ee 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_device.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_device.c
@@ -560,6 +560,7 @@ struct kfd_dev *kgd2kfd_probe(struct kgd_dev *kgd,
 	 * 32 and 64-bit requests are possible and must be
 	 * supported.
 	 */
+#ifndef CONFIG_ARCH_PHYTIUM
 	kfd->pci_atomic_requested = amdgpu_amdkfd_have_atomics_support(kgd);
 	if (device_info->needs_pci_atomics &&
 	    !kfd->pci_atomic_requested) {
@@ -569,6 +570,7 @@ struct kfd_dev *kgd2kfd_probe(struct kgd_dev *kgd,
 		kfree(kfd);
 		return NULL;
 	}
+#endif
 
 	kfd->kgd = kgd;
 	kfd->device_info = device_info;
diff --git a/drivers/iommu/arm/arm-smmu/arm-smmu.c b/drivers/iommu/arm/arm-smmu/arm-smmu.c
index bcbacf22331d..4b087ddb81b8 100644
--- a/drivers/iommu/arm/arm-smmu/arm-smmu.c
+++ b/drivers/iommu/arm/arm-smmu/arm-smmu.c
@@ -924,6 +924,11 @@ static void arm_smmu_write_smr(struct arm_smmu_device *smmu, int idx)
 	if (!(smmu->features & ARM_SMMU_FEAT_EXIDS) && smr->valid)
 		reg |= ARM_SMMU_SMR_VALID;
 	arm_smmu_gr0_write(smmu, ARM_SMMU_GR0_SMR(idx), reg);
+
+	if ((read_cpuid_id() & MIDR_CPU_MODEL_MASK) == MIDR_PHYTIUM_FT2000PLUS) {
+                u32 tmp = 0xf0000000 | ((reg & 0xffff) >> 3);
+        	arm_smmu_gr0_write(smmu, ARM_SMMU_GR0_SMR(idx + 32), tmp);
+	}
 }
 
 static void arm_smmu_write_s2cr(struct arm_smmu_device *smmu, int idx)
@@ -944,6 +949,9 @@ static void arm_smmu_write_s2cr(struct arm_smmu_device *smmu, int idx)
 	    smmu->smrs[idx].valid)
 		reg |= ARM_SMMU_S2CR_EXIDVALID;
 	arm_smmu_gr0_write(smmu, ARM_SMMU_GR0_S2CR(idx), reg);
+
+	if ((read_cpuid_id() & MIDR_CPU_MODEL_MASK) == MIDR_PHYTIUM_FT2000PLUS)
+		arm_smmu_gr0_write(smmu, ARM_SMMU_GR0_S2CR(idx+32), reg);
 }
 
 static void arm_smmu_write_sme(struct arm_smmu_device *smmu, int idx)
diff --git a/drivers/iommu/iommu.c b/drivers/iommu/iommu.c
index 9b8664d388af..860f33efaaef 100644
--- a/drivers/iommu/iommu.c
+++ b/drivers/iommu/iommu.c
@@ -25,6 +25,10 @@
 #include <linux/module.h>
 #include <trace/events/iommu.h>
 
+#ifdef CONFIG_ARCH_PHYTIUM
+#include <asm/cputype.h>
+#endif
+
 static struct kset *iommu_group_kset;
 static DEFINE_IDA(iommu_group_ida);
 
@@ -314,11 +318,23 @@ static int __init iommu_set_def_domain_type(char *str)
 	if (ret)
 		return ret;
 
+#ifdef CONFIG_ARCH_PHYTIUM
+        /*
+         * Always set default iommu type to IOMMU_DOMAIN_IDENTITY
+         * on Phytium FT-2000+ SoC to avoid unnecessary troubles
+         * introduced by the SMMU workaround.
+         */
+        if ((read_cpuid_id() & MIDR_CPU_MODEL_MASK) == MIDR_PHYTIUM_FT2000PLUS)
+                iommu_def_domain_type = IOMMU_DOMAIN_IDENTITY;
+        else
+                iommu_def_domain_type = pt ? IOMMU_DOMAIN_IDENTITY : IOMMU_DOMAIN_DMA;
+#else
+
 	if (pt)
 		iommu_set_default_passthrough(true);
 	else
 		iommu_set_default_translated(true);
-
+#endif
 	return 0;
 }
 early_param("iommu.passthrough", iommu_set_def_domain_type);
@@ -1842,6 +1858,16 @@ int bus_set_iommu(struct bus_type *bus, const struct iommu_ops *ops)
 
 	bus->iommu_ops = ops;
 
+#ifdef CONFIG_ARCH_PHYTIUM
+        /*
+         * Always set default iommu type to IOMMU_DOMAIN_IDENTITY
+         * on Phytium FT-2000+ SoC to avoid unnecessary troubles
+         * introduced by the SMMU workaround.
+         */
+        if ((read_cpuid_id() & MIDR_CPU_MODEL_MASK) == MIDR_PHYTIUM_FT2000PLUS)
+                iommu_def_domain_type = IOMMU_DOMAIN_IDENTITY;
+#endif
+
 	/* Do IOMMU specific setup for this bus-type */
 	err = iommu_bus_init(bus, ops);
 	if (err)
diff --git a/drivers/irqchip/Kconfig b/drivers/irqchip/Kconfig
index 6156a065681b..ded9759c7589 100644
--- a/drivers/irqchip/Kconfig
+++ b/drivers/irqchip/Kconfig
@@ -56,6 +56,15 @@ config ARM_GIC_V3_ITS_FSL_MC
 	depends on FSL_MC_BUS
 	default ARM_GIC_V3_ITS
 
+config ARM_GIC_PHYTIUM_2500
+	bool
+	select IRQ_DOMAIN
+	select GENERIC_IRQ_MULTI_HANDLER
+	select IRQ_DOMAIN_HIERARCHY
+	select PARTITION_PERCPU
+	select GENERIC_IRQ_EFFECTIVE_AFF_MASK
+	select GENERIC_MSI_IRQ_DOMAIN
+
 config ARM_NVIC
 	bool
 	select IRQ_DOMAIN_HIERARCHY
@@ -438,6 +447,14 @@ config QCOM_PDC
 	  Power Domain Controller driver to manage and configure wakeup
 	  IRQs for Qualcomm Technologies Inc (QTI) mobile chips.
 
+config PHYTIUM_IXIC
+        bool "Phytium D2000 SoC PCI Legacy Interrupt Controller"
+        depends on ARCH_PHYTIUM
+        select IRQ_DOMAIN
+        select IRQ_DOMAIN_HIERARCHY
+        help
+          This enables support PCI Legacy Interrupt on Phytium D2000 SoC.
+
 config CSKY_MPINTC
 	bool "C-SKY Multi Processor Interrupt Controller"
 	depends on CSKY
diff --git a/drivers/irqchip/Makefile b/drivers/irqchip/Makefile
index 94c2885882ee..a58174e737b0 100644
--- a/drivers/irqchip/Makefile
+++ b/drivers/irqchip/Makefile
@@ -34,6 +34,7 @@ obj-$(CONFIG_ARM_GIC_V3)		+= irq-gic-v3.o irq-gic-v3-mbi.o irq-gic-common.o
 obj-$(CONFIG_ARM_GIC_V3_ITS)		+= irq-gic-v3-its.o irq-gic-v3-its-platform-msi.o irq-gic-v4.o
 obj-$(CONFIG_ARM_GIC_V3_ITS_PCI)	+= irq-gic-v3-its-pci-msi.o
 obj-$(CONFIG_ARM_GIC_V3_ITS_FSL_MC)	+= irq-gic-v3-its-fsl-mc-msi.o
+obj-$(CONFIG_ARM_GIC_PHYTIUM_2500)      += irq-gic-phytium-2500.o irq-gic-phytium-2500-its.o
 obj-$(CONFIG_PARTITION_PERCPU)		+= irq-partition-percpu.o
 obj-$(CONFIG_HISILICON_IRQ_MBIGEN)	+= irq-mbigen.o
 obj-$(CONFIG_ARM_NVIC)			+= irq-nvic.o
@@ -100,6 +101,7 @@ obj-$(CONFIG_CSKY_MPINTC)		+= irq-csky-mpintc.o
 obj-$(CONFIG_CSKY_APB_INTC)		+= irq-csky-apb-intc.o
 obj-$(CONFIG_RISCV_INTC)		+= irq-riscv-intc.o
 obj-$(CONFIG_SIFIVE_PLIC)		+= irq-sifive-plic.o
+obj-$(CONFIG_PHYTIUM_IXIC)              += irq-phytium-ixic.o
 obj-$(CONFIG_IMX_IRQSTEER)		+= irq-imx-irqsteer.o
 obj-$(CONFIG_IMX_INTMUX)		+= irq-imx-intmux.o
 obj-$(CONFIG_MADERA_IRQ)		+= irq-madera.o
diff --git a/drivers/irqchip/irq-gic-phytium-2500-its.c b/drivers/irqchip/irq-gic-phytium-2500-its.c
new file mode 100644
index 000000000000..67fcd9e06606
--- /dev/null
+++ b/drivers/irqchip/irq-gic-phytium-2500-its.c
@@ -0,0 +1,4159 @@
+/*
+ * Copyright (C) 2020 Phytium Corporation.
+ * Author: Wang Yinfeng <wangyinfeng@phytium.com.cn>
+ *         Chen Baozi <chenbaozi@phytium.com.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/acpi.h>
+#include <linux/acpi_iort.h>
+#include <linux/bitmap.h>
+#include <linux/cpu.h>
+#include <linux/crash_dump.h>
+#include <linux/delay.h>
+#include <linux/dma-iommu.h>
+#include <linux/efi.h>
+#include <linux/interrupt.h>
+#include <linux/irqdomain.h>
+#include <linux/list.h>
+#include <linux/list_sort.h>
+#include <linux/log2.h>
+#include <linux/memblock.h>
+#include <linux/mm.h>
+#include <linux/msi.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_pci.h>
+#include <linux/of_platform.h>
+#include <linux/percpu.h>
+#include <linux/slab.h>
+#include <linux/syscore_ops.h>
+
+#include <linux/irqchip.h>
+#include <linux/irqchip/arm-gic-phytium-2500.h>
+#include <linux/irqchip/arm-gic-v4.h>
+
+#include <asm/cputype.h>
+#include <asm/exception.h>
+#include <asm/smp_plat.h>
+
+#include "irq-gic-common.h"
+
+#define ITS_FLAGS_CMDQ_NEEDS_FLUSHING		(1ULL << 0)
+#define ITS_FLAGS_WORKAROUND_CAVIUM_22375	(1ULL << 1)
+#define ITS_FLAGS_WORKAROUND_CAVIUM_23144	(1ULL << 2)
+#define ITS_FLAGS_SAVE_SUSPEND_STATE		(1ULL << 3)
+
+#define RDIST_FLAGS_PROPBASE_NEEDS_FLUSHING	(1 << 0)
+#define RDIST_FLAGS_RD_TABLES_PREALLOCATED	(1 << 1)
+
+static u32 lpi_id_bits;
+
+/*
+ * We allocate memory for PROPBASE to cover 2 ^ lpi_id_bits LPIs to
+ * deal with (one configuration byte per interrupt). PENDBASE has to
+ * be 64kB aligned (one bit per LPI, plus 8192 bits for SPI/PPI/SGI).
+ */
+#define LPI_NRBITS		lpi_id_bits
+#define LPI_PROPBASE_SZ		ALIGN(BIT(LPI_NRBITS), SZ_64K)
+#define LPI_PENDBASE_SZ		ALIGN(BIT(LPI_NRBITS) / 8, SZ_64K)
+
+#define LPI_PROP_DEFAULT_PRIO	0xa0
+
+/*
+ * Collection structure - just an ID, and a redistributor address to
+ * ping. We use one per CPU as a bag of interrupts assigned to this
+ * CPU.
+ */
+struct its_collection {
+	u64			target_address;
+	u16			col_id;
+};
+
+/*
+ * The ITS_BASER structure - contains memory information, cached
+ * value of BASER register configuration and ITS page size.
+ */
+struct its_baser {
+	void		*base;
+	u64		val;
+	u32		order;
+	u32		psz;
+};
+
+struct its_device;
+
+/*
+ * The ITS structure - contains most of the infrastructure, with the
+ * top-level MSI domain, the command queue, the collections, and the
+ * list of devices writing to it.
+ */
+struct its_node {
+	raw_spinlock_t		lock;
+	struct list_head	entry;
+	void __iomem		*base;
+	phys_addr_t		phys_base;
+	struct its_cmd_block	*cmd_base;
+	struct its_cmd_block	*cmd_write;
+	struct its_baser	tables[GITS_BASER_NR_REGS];
+	struct its_collection	*collections;
+	struct fwnode_handle	*fwnode_handle;
+	u64			(*get_msi_base)(struct its_device *its_dev);
+	u64			cbaser_save;
+	u32			ctlr_save;
+	struct list_head	its_device_list;
+	u64			flags;
+	unsigned long		list_nr;
+	u32			ite_size;
+	u32			device_ids;
+	int			numa_node;
+	unsigned int		msi_domain_flags;
+	u32			pre_its_base; /* for Socionext Synquacer */
+	bool			is_v4;
+	int			vlpi_redist_offset;
+};
+
+#define ITS_ITT_ALIGN		SZ_256
+
+/* The maximum number of VPEID bits supported by VLPI commands */
+#define ITS_MAX_VPEID_BITS	(16)
+#define ITS_MAX_VPEID		(1 << (ITS_MAX_VPEID_BITS))
+
+/* Convert page order to size in bytes */
+#define PAGE_ORDER_TO_SIZE(o)	(PAGE_SIZE << (o))
+
+struct event_lpi_map {
+	unsigned long		*lpi_map;
+	u16			*col_map;
+	irq_hw_number_t		lpi_base;
+	int			nr_lpis;
+	struct mutex		vlpi_lock;
+	struct its_vm		*vm;
+	struct its_vlpi_map	*vlpi_maps;
+	int			nr_vlpis;
+};
+
+/*
+ * The ITS view of a device - belongs to an ITS, owns an interrupt
+ * translation table, and a list of interrupts.  If it some of its
+ * LPIs are injected into a guest (GICv4), the event_map.vm field
+ * indicates which one.
+ */
+struct its_device {
+	struct list_head	entry;
+	struct its_node		*its;
+	struct event_lpi_map	event_map;
+	void			*itt;
+	u32			nr_ites;
+	u32			device_id;
+};
+
+static struct {
+	raw_spinlock_t		lock;
+	struct its_device	*dev;
+	struct its_vpe		**vpes;
+	int			next_victim;
+} vpe_proxy;
+
+struct cpu_lpi_count {
+	atomic_t	managed;
+	atomic_t	unmanaged;
+};
+
+static DEFINE_PER_CPU(struct cpu_lpi_count, cpu_lpi_count);
+
+static LIST_HEAD(its_nodes);
+static DEFINE_RAW_SPINLOCK(its_lock);
+static struct rdists *gic_rdists;
+static struct irq_domain *its_parent;
+
+static unsigned long its_list_map;
+static u16 vmovp_seq_num;
+static DEFINE_RAW_SPINLOCK(vmovp_lock);
+
+static DEFINE_IDA(its_vpeid_ida);
+
+#define gic_data_rdist()		(raw_cpu_ptr(gic_rdists->rdist))
+#define gic_data_rdist_cpu(cpu)		(per_cpu_ptr(gic_rdists->rdist, cpu))
+#define gic_data_rdist_rd_base()	(gic_data_rdist()->rd_base)
+#define gic_data_rdist_vlpi_base()	(gic_data_rdist_rd_base() + SZ_128K)
+
+static struct its_collection *dev_event_to_col(struct its_device *its_dev,
+					       u32 event)
+{
+	struct its_node *its = its_dev->its;
+
+	return its->collections + its_dev->event_map.col_map[event];
+}
+
+static struct its_collection *valid_col(struct its_collection *col)
+{
+	if (WARN_ON_ONCE(col->target_address & __GENMASK_ULL(0, 15)))
+		return NULL;
+
+	return col;
+}
+
+static struct its_vpe *valid_vpe(struct its_node *its, struct its_vpe *vpe)
+{
+	if (valid_col(its->collections + vpe->col_idx))
+		return vpe;
+
+	return NULL;
+}
+
+/*
+ * ITS command descriptors - parameters to be encoded in a command
+ * block.
+ */
+struct its_cmd_desc {
+	union {
+		struct {
+			struct its_device *dev;
+			u32 event_id;
+		} its_inv_cmd;
+
+		struct {
+			struct its_device *dev;
+			u32 event_id;
+		} its_clear_cmd;
+
+		struct {
+			struct its_device *dev;
+			u32 event_id;
+		} its_int_cmd;
+
+		struct {
+			struct its_device *dev;
+			int valid;
+		} its_mapd_cmd;
+
+		struct {
+			struct its_collection *col;
+			int valid;
+		} its_mapc_cmd;
+
+		struct {
+			struct its_device *dev;
+			u32 phys_id;
+			u32 event_id;
+		} its_mapti_cmd;
+
+		struct {
+			struct its_device *dev;
+			struct its_collection *col;
+			u32 event_id;
+		} its_movi_cmd;
+
+		struct {
+			struct its_device *dev;
+			u32 event_id;
+		} its_discard_cmd;
+
+		struct {
+			struct its_collection *col;
+		} its_invall_cmd;
+
+		struct {
+			struct its_vpe *vpe;
+		} its_vinvall_cmd;
+
+		struct {
+			struct its_vpe *vpe;
+			struct its_collection *col;
+			bool valid;
+		} its_vmapp_cmd;
+
+		struct {
+			struct its_vpe *vpe;
+			struct its_device *dev;
+			u32 virt_id;
+			u32 event_id;
+			bool db_enabled;
+		} its_vmapti_cmd;
+
+		struct {
+			struct its_vpe *vpe;
+			struct its_device *dev;
+			u32 event_id;
+			bool db_enabled;
+		} its_vmovi_cmd;
+
+		struct {
+			struct its_vpe *vpe;
+			struct its_collection *col;
+			u16 seq_num;
+			u16 its_list;
+		} its_vmovp_cmd;
+	};
+};
+
+/*
+ * The ITS command block, which is what the ITS actually parses.
+ */
+struct its_cmd_block {
+	u64	raw_cmd[4];
+};
+
+#define ITS_CMD_QUEUE_SZ		SZ_64K
+#define ITS_CMD_QUEUE_NR_ENTRIES	(ITS_CMD_QUEUE_SZ / sizeof(struct its_cmd_block))
+
+typedef struct its_collection *(*its_cmd_builder_t)(struct its_node *,
+						    struct its_cmd_block *,
+						    struct its_cmd_desc *);
+
+typedef struct its_vpe *(*its_cmd_vbuilder_t)(struct its_node *,
+					      struct its_cmd_block *,
+					      struct its_cmd_desc *);
+
+static void its_mask_encode(u64 *raw_cmd, u64 val, int h, int l)
+{
+	u64 mask = GENMASK_ULL(h, l);
+	*raw_cmd &= ~mask;
+	*raw_cmd |= (val << l) & mask;
+}
+
+static void its_encode_cmd(struct its_cmd_block *cmd, u8 cmd_nr)
+{
+	its_mask_encode(&cmd->raw_cmd[0], cmd_nr, 7, 0);
+}
+
+static void its_encode_devid(struct its_cmd_block *cmd, u32 devid)
+{
+	its_mask_encode(&cmd->raw_cmd[0], devid, 63, 32);
+}
+
+static void its_encode_event_id(struct its_cmd_block *cmd, u32 id)
+{
+	its_mask_encode(&cmd->raw_cmd[1], id, 31, 0);
+}
+
+static void its_encode_phys_id(struct its_cmd_block *cmd, u32 phys_id)
+{
+	its_mask_encode(&cmd->raw_cmd[1], phys_id, 63, 32);
+}
+
+static void its_encode_size(struct its_cmd_block *cmd, u8 size)
+{
+	its_mask_encode(&cmd->raw_cmd[1], size, 4, 0);
+}
+
+static void its_encode_itt(struct its_cmd_block *cmd, u64 itt_addr)
+{
+	its_mask_encode(&cmd->raw_cmd[2], itt_addr >> 8, 51, 8);
+}
+
+static void its_encode_valid(struct its_cmd_block *cmd, int valid)
+{
+	its_mask_encode(&cmd->raw_cmd[2], !!valid, 63, 63);
+}
+
+static void its_encode_target(struct its_cmd_block *cmd, u64 target_addr)
+{
+	its_mask_encode(&cmd->raw_cmd[2], target_addr >> 16, 51, 16);
+}
+
+static void its_encode_collection(struct its_cmd_block *cmd, u16 col)
+{
+	its_mask_encode(&cmd->raw_cmd[2], col, 15, 0);
+}
+
+static void its_encode_vpeid(struct its_cmd_block *cmd, u16 vpeid)
+{
+	its_mask_encode(&cmd->raw_cmd[1], vpeid, 47, 32);
+}
+
+static void its_encode_virt_id(struct its_cmd_block *cmd, u32 virt_id)
+{
+	its_mask_encode(&cmd->raw_cmd[2], virt_id, 31, 0);
+}
+
+static void its_encode_db_phys_id(struct its_cmd_block *cmd, u32 db_phys_id)
+{
+	its_mask_encode(&cmd->raw_cmd[2], db_phys_id, 63, 32);
+}
+
+static void its_encode_db_valid(struct its_cmd_block *cmd, bool db_valid)
+{
+	its_mask_encode(&cmd->raw_cmd[2], db_valid, 0, 0);
+}
+
+static void its_encode_seq_num(struct its_cmd_block *cmd, u16 seq_num)
+{
+	its_mask_encode(&cmd->raw_cmd[0], seq_num, 47, 32);
+}
+
+static void its_encode_its_list(struct its_cmd_block *cmd, u16 its_list)
+{
+	its_mask_encode(&cmd->raw_cmd[1], its_list, 15, 0);
+}
+
+static void its_encode_vpt_addr(struct its_cmd_block *cmd, u64 vpt_pa)
+{
+	its_mask_encode(&cmd->raw_cmd[3], vpt_pa >> 16, 51, 16);
+}
+
+static void its_encode_vpt_size(struct its_cmd_block *cmd, u8 vpt_size)
+{
+	its_mask_encode(&cmd->raw_cmd[3], vpt_size, 4, 0);
+}
+
+static inline void its_fixup_cmd(struct its_cmd_block *cmd)
+{
+	/* Let's fixup BE commands */
+	cmd->raw_cmd[0] = cpu_to_le64(cmd->raw_cmd[0]);
+	cmd->raw_cmd[1] = cpu_to_le64(cmd->raw_cmd[1]);
+	cmd->raw_cmd[2] = cpu_to_le64(cmd->raw_cmd[2]);
+	cmd->raw_cmd[3] = cpu_to_le64(cmd->raw_cmd[3]);
+}
+
+static struct its_collection *its_build_mapd_cmd(struct its_node *its,
+						 struct its_cmd_block *cmd,
+						 struct its_cmd_desc *desc)
+{
+	unsigned long itt_addr;
+	u8 size = ilog2(desc->its_mapd_cmd.dev->nr_ites);
+
+	itt_addr = virt_to_phys(desc->its_mapd_cmd.dev->itt);
+	itt_addr = ALIGN(itt_addr, ITS_ITT_ALIGN);
+
+	its_encode_cmd(cmd, GITS_CMD_MAPD);
+	its_encode_devid(cmd, desc->its_mapd_cmd.dev->device_id);
+	its_encode_size(cmd, size - 1);
+	its_encode_itt(cmd, itt_addr);
+	its_encode_valid(cmd, desc->its_mapd_cmd.valid);
+
+	its_fixup_cmd(cmd);
+
+	return NULL;
+}
+
+static struct its_collection *its_build_mapc_cmd(struct its_node *its,
+						 struct its_cmd_block *cmd,
+						 struct its_cmd_desc *desc)
+{
+	its_encode_cmd(cmd, GITS_CMD_MAPC);
+	its_encode_collection(cmd, desc->its_mapc_cmd.col->col_id);
+	its_encode_target(cmd, desc->its_mapc_cmd.col->target_address);
+	its_encode_valid(cmd, desc->its_mapc_cmd.valid);
+
+	its_fixup_cmd(cmd);
+
+	return desc->its_mapc_cmd.col;
+}
+
+static struct its_collection *its_build_mapti_cmd(struct its_node *its,
+						  struct its_cmd_block *cmd,
+						  struct its_cmd_desc *desc)
+{
+	struct its_collection *col;
+
+	col = dev_event_to_col(desc->its_mapti_cmd.dev,
+			       desc->its_mapti_cmd.event_id);
+	if (is_kdump_kernel())
+		col->col_id = col->col_id % 65;
+	else
+		col->col_id = col->col_id % 64;
+
+	its_encode_cmd(cmd, GITS_CMD_MAPTI);
+	its_encode_devid(cmd, desc->its_mapti_cmd.dev->device_id);
+	its_encode_event_id(cmd, desc->its_mapti_cmd.event_id);
+	its_encode_phys_id(cmd, desc->its_mapti_cmd.phys_id);
+	its_encode_collection(cmd, col->col_id);
+
+	its_fixup_cmd(cmd);
+
+	return valid_col(col);
+}
+
+static struct its_collection *its_build_movi_cmd(struct its_node *its,
+						 struct its_cmd_block *cmd,
+						 struct its_cmd_desc *desc)
+{
+	struct its_collection *col;
+
+	col = dev_event_to_col(desc->its_movi_cmd.dev,
+			       desc->its_movi_cmd.event_id);
+
+	its_encode_cmd(cmd, GITS_CMD_MOVI);
+	its_encode_devid(cmd, desc->its_movi_cmd.dev->device_id);
+	its_encode_event_id(cmd, desc->its_movi_cmd.event_id);
+	its_encode_collection(cmd, desc->its_movi_cmd.col->col_id);
+
+	its_fixup_cmd(cmd);
+
+	return valid_col(col);
+}
+
+static struct its_collection *its_build_discard_cmd(struct its_node *its,
+						    struct its_cmd_block *cmd,
+						    struct its_cmd_desc *desc)
+{
+	struct its_collection *col;
+
+	col = dev_event_to_col(desc->its_discard_cmd.dev,
+			       desc->its_discard_cmd.event_id);
+
+	its_encode_cmd(cmd, GITS_CMD_DISCARD);
+	its_encode_devid(cmd, desc->its_discard_cmd.dev->device_id);
+	its_encode_event_id(cmd, desc->its_discard_cmd.event_id);
+
+	its_fixup_cmd(cmd);
+
+	return valid_col(col);
+}
+
+static struct its_collection *its_build_inv_cmd(struct its_node *its,
+						struct its_cmd_block *cmd,
+						struct its_cmd_desc *desc)
+{
+	struct its_collection *col;
+
+	col = dev_event_to_col(desc->its_inv_cmd.dev,
+			       desc->its_inv_cmd.event_id);
+
+	its_encode_cmd(cmd, GITS_CMD_INV);
+	its_encode_devid(cmd, desc->its_inv_cmd.dev->device_id);
+	its_encode_event_id(cmd, desc->its_inv_cmd.event_id);
+
+	its_fixup_cmd(cmd);
+
+	return valid_col(col);
+}
+
+static struct its_collection *its_build_int_cmd(struct its_node *its,
+						struct its_cmd_block *cmd,
+						struct its_cmd_desc *desc)
+{
+	struct its_collection *col;
+
+	col = dev_event_to_col(desc->its_int_cmd.dev,
+			       desc->its_int_cmd.event_id);
+
+	its_encode_cmd(cmd, GITS_CMD_INT);
+	its_encode_devid(cmd, desc->its_int_cmd.dev->device_id);
+	its_encode_event_id(cmd, desc->its_int_cmd.event_id);
+
+	its_fixup_cmd(cmd);
+
+	return valid_col(col);
+}
+
+static struct its_collection *its_build_clear_cmd(struct its_node *its,
+						  struct its_cmd_block *cmd,
+						  struct its_cmd_desc *desc)
+{
+	struct its_collection *col;
+
+	col = dev_event_to_col(desc->its_clear_cmd.dev,
+			       desc->its_clear_cmd.event_id);
+
+	its_encode_cmd(cmd, GITS_CMD_CLEAR);
+	its_encode_devid(cmd, desc->its_clear_cmd.dev->device_id);
+	its_encode_event_id(cmd, desc->its_clear_cmd.event_id);
+
+	its_fixup_cmd(cmd);
+
+	return valid_col(col);
+}
+
+static struct its_collection *its_build_invall_cmd(struct its_node *its,
+						   struct its_cmd_block *cmd,
+						   struct its_cmd_desc *desc)
+{
+	its_encode_cmd(cmd, GITS_CMD_INVALL);
+	its_encode_collection(cmd, desc->its_mapc_cmd.col->col_id);
+
+	its_fixup_cmd(cmd);
+
+	return NULL;
+}
+
+static struct its_vpe *its_build_vinvall_cmd(struct its_node *its,
+					     struct its_cmd_block *cmd,
+					     struct its_cmd_desc *desc)
+{
+	its_encode_cmd(cmd, GITS_CMD_VINVALL);
+	its_encode_vpeid(cmd, desc->its_vinvall_cmd.vpe->vpe_id);
+
+	its_fixup_cmd(cmd);
+
+	return valid_vpe(its, desc->its_vinvall_cmd.vpe);
+}
+
+static struct its_vpe *its_build_vmapp_cmd(struct its_node *its,
+					   struct its_cmd_block *cmd,
+					   struct its_cmd_desc *desc)
+{
+	unsigned long vpt_addr;
+	u64 target;
+
+	vpt_addr = virt_to_phys(page_address(desc->its_vmapp_cmd.vpe->vpt_page));
+	target = desc->its_vmapp_cmd.col->target_address + its->vlpi_redist_offset;
+
+	its_encode_cmd(cmd, GITS_CMD_VMAPP);
+	its_encode_vpeid(cmd, desc->its_vmapp_cmd.vpe->vpe_id);
+	its_encode_valid(cmd, desc->its_vmapp_cmd.valid);
+	its_encode_target(cmd, target);
+	its_encode_vpt_addr(cmd, vpt_addr);
+	its_encode_vpt_size(cmd, LPI_NRBITS - 1);
+
+	its_fixup_cmd(cmd);
+
+	return valid_vpe(its, desc->its_vmapp_cmd.vpe);
+}
+
+static struct its_vpe *its_build_vmapti_cmd(struct its_node *its,
+					    struct its_cmd_block *cmd,
+					    struct its_cmd_desc *desc)
+{
+	u32 db;
+
+	if (desc->its_vmapti_cmd.db_enabled)
+		db = desc->its_vmapti_cmd.vpe->vpe_db_lpi;
+	else
+		db = 1023;
+
+	its_encode_cmd(cmd, GITS_CMD_VMAPTI);
+	its_encode_devid(cmd, desc->its_vmapti_cmd.dev->device_id);
+	its_encode_vpeid(cmd, desc->its_vmapti_cmd.vpe->vpe_id);
+	its_encode_event_id(cmd, desc->its_vmapti_cmd.event_id);
+	its_encode_db_phys_id(cmd, db);
+	its_encode_virt_id(cmd, desc->its_vmapti_cmd.virt_id);
+
+	its_fixup_cmd(cmd);
+
+	return valid_vpe(its, desc->its_vmapti_cmd.vpe);
+}
+
+static struct its_vpe *its_build_vmovi_cmd(struct its_node *its,
+					   struct its_cmd_block *cmd,
+					   struct its_cmd_desc *desc)
+{
+	u32 db;
+
+	if (desc->its_vmovi_cmd.db_enabled)
+		db = desc->its_vmovi_cmd.vpe->vpe_db_lpi;
+	else
+		db = 1023;
+
+	its_encode_cmd(cmd, GITS_CMD_VMOVI);
+	its_encode_devid(cmd, desc->its_vmovi_cmd.dev->device_id);
+	its_encode_vpeid(cmd, desc->its_vmovi_cmd.vpe->vpe_id);
+	its_encode_event_id(cmd, desc->its_vmovi_cmd.event_id);
+	its_encode_db_phys_id(cmd, db);
+	its_encode_db_valid(cmd, true);
+
+	its_fixup_cmd(cmd);
+
+	return valid_vpe(its, desc->its_vmovi_cmd.vpe);
+}
+
+static struct its_vpe *its_build_vmovp_cmd(struct its_node *its,
+					   struct its_cmd_block *cmd,
+					   struct its_cmd_desc *desc)
+{
+	u64 target;
+
+	target = desc->its_vmovp_cmd.col->target_address + its->vlpi_redist_offset;
+	its_encode_cmd(cmd, GITS_CMD_VMOVP);
+	its_encode_seq_num(cmd, desc->its_vmovp_cmd.seq_num);
+	its_encode_its_list(cmd, desc->its_vmovp_cmd.its_list);
+	its_encode_vpeid(cmd, desc->its_vmovp_cmd.vpe->vpe_id);
+	its_encode_target(cmd, target);
+
+	its_fixup_cmd(cmd);
+
+	return valid_vpe(its, desc->its_vmovp_cmd.vpe);
+}
+
+static u64 its_cmd_ptr_to_offset(struct its_node *its,
+				 struct its_cmd_block *ptr)
+{
+	return (ptr - its->cmd_base) * sizeof(*ptr);
+}
+
+static int its_queue_full(struct its_node *its)
+{
+	int widx;
+	int ridx;
+
+	widx = its->cmd_write - its->cmd_base;
+	ridx = readl_relaxed(its->base + GITS_CREADR) / sizeof(struct its_cmd_block);
+
+	/* This is incredibly unlikely to happen, unless the ITS locks up. */
+	if (((widx + 1) % ITS_CMD_QUEUE_NR_ENTRIES) == ridx)
+		return 1;
+
+	return 0;
+}
+
+static struct its_cmd_block *its_allocate_entry(struct its_node *its)
+{
+	struct its_cmd_block *cmd;
+	u32 count = 1000000;	/* 1s! */
+
+	while (its_queue_full(its)) {
+		count--;
+		if (!count) {
+			pr_err_ratelimited("ITS queue not draining\n");
+			return NULL;
+		}
+		cpu_relax();
+		udelay(1);
+	}
+
+	cmd = its->cmd_write++;
+
+	/* Handle queue wrapping */
+	if (its->cmd_write == (its->cmd_base + ITS_CMD_QUEUE_NR_ENTRIES))
+		its->cmd_write = its->cmd_base;
+
+	/* Clear command  */
+	cmd->raw_cmd[0] = 0;
+	cmd->raw_cmd[1] = 0;
+	cmd->raw_cmd[2] = 0;
+	cmd->raw_cmd[3] = 0;
+
+	return cmd;
+}
+
+static struct its_cmd_block *its_post_commands(struct its_node *its)
+{
+	u64 wr = its_cmd_ptr_to_offset(its, its->cmd_write);
+
+	writel_relaxed(wr, its->base + GITS_CWRITER);
+
+	return its->cmd_write;
+}
+
+static void its_flush_cmd(struct its_node *its, struct its_cmd_block *cmd)
+{
+	/*
+	 * Make sure the commands written to memory are observable by
+	 * the ITS.
+	 */
+	if (its->flags & ITS_FLAGS_CMDQ_NEEDS_FLUSHING)
+		gic_flush_dcache_to_poc(cmd, sizeof(*cmd));
+	else
+		dsb(ishst);
+}
+
+static int its_wait_for_range_completion(struct its_node *its,
+					 struct its_cmd_block *from,
+					 struct its_cmd_block *to)
+{
+	u64 rd_idx, from_idx, to_idx;
+	u32 count = 1000000;	/* 1s! */
+
+	from_idx = its_cmd_ptr_to_offset(its, from);
+	to_idx = its_cmd_ptr_to_offset(its, to);
+
+	while (1) {
+		rd_idx = readl_relaxed(its->base + GITS_CREADR);
+
+		/* Direct case */
+		if (from_idx < to_idx && rd_idx >= to_idx)
+			break;
+
+		/* Wrapped case */
+		if (from_idx >= to_idx && rd_idx >= to_idx && rd_idx < from_idx)
+			break;
+
+		count--;
+		if (!count) {
+			pr_err_ratelimited("ITS queue timeout (%llu %llu %llu)\n",
+					   from_idx, to_idx, rd_idx);
+			return -1;
+		}
+		cpu_relax();
+		udelay(1);
+	}
+
+	return 0;
+}
+
+/* Warning, macro hell follows */
+#define BUILD_SINGLE_CMD_FUNC(name, buildtype, synctype, buildfn)	\
+void name(struct its_node *its,						\
+	  buildtype builder,						\
+	  struct its_cmd_desc *desc)					\
+{									\
+	struct its_cmd_block *cmd, *sync_cmd, *next_cmd;		\
+	synctype *sync_obj;						\
+	unsigned long flags;						\
+									\
+	raw_spin_lock_irqsave(&its->lock, flags);			\
+									\
+	cmd = its_allocate_entry(its);					\
+	if (!cmd) {		/* We're soooooo screewed... */		\
+		raw_spin_unlock_irqrestore(&its->lock, flags);		\
+		return;							\
+	}								\
+	sync_obj = builder(its, cmd, desc);				\
+	its_flush_cmd(its, cmd);					\
+									\
+	if (sync_obj) {							\
+		sync_cmd = its_allocate_entry(its);			\
+		if (!sync_cmd)						\
+			goto post;					\
+									\
+		buildfn(its, sync_cmd, sync_obj);			\
+		its_flush_cmd(its, sync_cmd);				\
+	}								\
+									\
+post:									\
+	next_cmd = its_post_commands(its);				\
+	raw_spin_unlock_irqrestore(&its->lock, flags);			\
+									\
+	if (its_wait_for_range_completion(its, cmd, next_cmd))		\
+		pr_err_ratelimited("ITS cmd %ps failed\n", builder);	\
+}
+
+static void its_build_sync_cmd(struct its_node *its,
+			       struct its_cmd_block *sync_cmd,
+			       struct its_collection *sync_col)
+{
+	its_encode_cmd(sync_cmd, GITS_CMD_SYNC);
+	its_encode_target(sync_cmd, sync_col->target_address);
+
+	its_fixup_cmd(sync_cmd);
+}
+
+static BUILD_SINGLE_CMD_FUNC(its_send_single_command, its_cmd_builder_t,
+			     struct its_collection, its_build_sync_cmd)
+
+static void its_build_vsync_cmd(struct its_node *its,
+				struct its_cmd_block *sync_cmd,
+				struct its_vpe *sync_vpe)
+{
+	its_encode_cmd(sync_cmd, GITS_CMD_VSYNC);
+	its_encode_vpeid(sync_cmd, sync_vpe->vpe_id);
+
+	its_fixup_cmd(sync_cmd);
+}
+
+static BUILD_SINGLE_CMD_FUNC(its_send_single_vcommand, its_cmd_vbuilder_t,
+			     struct its_vpe, its_build_vsync_cmd)
+
+static void its_send_int(struct its_device *dev, u32 event_id)
+{
+	struct its_cmd_desc desc;
+
+	desc.its_int_cmd.dev = dev;
+	desc.its_int_cmd.event_id = event_id;
+
+	its_send_single_command(dev->its, its_build_int_cmd, &desc);
+}
+
+static void its_send_clear(struct its_device *dev, u32 event_id)
+{
+	struct its_cmd_desc desc;
+
+	desc.its_clear_cmd.dev = dev;
+	desc.its_clear_cmd.event_id = event_id;
+
+	its_send_single_command(dev->its, its_build_clear_cmd, &desc);
+}
+
+static void its_send_inv(struct its_device *dev, u32 event_id)
+{
+	struct its_cmd_desc desc;
+
+	desc.its_inv_cmd.dev = dev;
+	desc.its_inv_cmd.event_id = event_id;
+
+	its_send_single_command(dev->its, its_build_inv_cmd, &desc);
+}
+
+static void its_send_mapd(struct its_device *dev, int valid)
+{
+	struct its_cmd_desc desc;
+
+	desc.its_mapd_cmd.dev = dev;
+	desc.its_mapd_cmd.valid = !!valid;
+
+	its_send_single_command(dev->its, its_build_mapd_cmd, &desc);
+}
+
+static void its_send_mapc(struct its_node *its, struct its_collection *col,
+			  int valid)
+{
+	struct its_cmd_desc desc;
+
+	desc.its_mapc_cmd.col = col;
+	desc.its_mapc_cmd.valid = !!valid;
+
+	its_send_single_command(its, its_build_mapc_cmd, &desc);
+}
+
+static void its_send_mapti(struct its_device *dev, u32 irq_id, u32 id)
+{
+	struct its_cmd_desc desc;
+
+	desc.its_mapti_cmd.dev = dev;
+	desc.its_mapti_cmd.phys_id = irq_id;
+	desc.its_mapti_cmd.event_id = id;
+
+	its_send_single_command(dev->its, its_build_mapti_cmd, &desc);
+}
+
+static void its_send_movi(struct its_device *dev,
+			  struct its_collection *col, u32 id)
+{
+	struct its_cmd_desc desc;
+
+	desc.its_movi_cmd.dev = dev;
+	desc.its_movi_cmd.col = col;
+	desc.its_movi_cmd.event_id = id;
+
+	its_send_single_command(dev->its, its_build_movi_cmd, &desc);
+}
+
+static void its_send_discard(struct its_device *dev, u32 id)
+{
+	struct its_cmd_desc desc;
+
+	desc.its_discard_cmd.dev = dev;
+	desc.its_discard_cmd.event_id = id;
+
+	its_send_single_command(dev->its, its_build_discard_cmd, &desc);
+}
+
+static void its_send_invall(struct its_node *its, struct its_collection *col)
+{
+	struct its_cmd_desc desc;
+
+	desc.its_invall_cmd.col = col;
+
+	its_send_single_command(its, its_build_invall_cmd, &desc);
+}
+
+static void its_send_vmapti(struct its_device *dev, u32 id)
+{
+	struct its_vlpi_map *map = &dev->event_map.vlpi_maps[id];
+	struct its_cmd_desc desc;
+
+	desc.its_vmapti_cmd.vpe = map->vpe;
+	desc.its_vmapti_cmd.dev = dev;
+	desc.its_vmapti_cmd.virt_id = map->vintid;
+	desc.its_vmapti_cmd.event_id = id;
+	desc.its_vmapti_cmd.db_enabled = map->db_enabled;
+
+	its_send_single_vcommand(dev->its, its_build_vmapti_cmd, &desc);
+}
+
+static void its_send_vmovi(struct its_device *dev, u32 id)
+{
+	struct its_vlpi_map *map = &dev->event_map.vlpi_maps[id];
+	struct its_cmd_desc desc;
+
+	desc.its_vmovi_cmd.vpe = map->vpe;
+	desc.its_vmovi_cmd.dev = dev;
+	desc.its_vmovi_cmd.event_id = id;
+	desc.its_vmovi_cmd.db_enabled = map->db_enabled;
+
+	its_send_single_vcommand(dev->its, its_build_vmovi_cmd, &desc);
+}
+
+static void its_send_vmapp(struct its_node *its,
+			   struct its_vpe *vpe, bool valid)
+{
+	struct its_cmd_desc desc;
+
+	desc.its_vmapp_cmd.vpe = vpe;
+	desc.its_vmapp_cmd.valid = valid;
+	desc.its_vmapp_cmd.col = &its->collections[vpe->col_idx];
+
+	its_send_single_vcommand(its, its_build_vmapp_cmd, &desc);
+}
+
+static void its_send_vmovp(struct its_vpe *vpe)
+{
+	struct its_cmd_desc desc;
+	struct its_node *its;
+	unsigned long flags;
+	int col_id = vpe->col_idx;
+
+	desc.its_vmovp_cmd.vpe = vpe;
+	desc.its_vmovp_cmd.its_list = (u16)its_list_map;
+
+	if (!its_list_map) {
+		its = list_first_entry(&its_nodes, struct its_node, entry);
+		desc.its_vmovp_cmd.seq_num = 0;
+		desc.its_vmovp_cmd.col = &its->collections[col_id];
+		its_send_single_vcommand(its, its_build_vmovp_cmd, &desc);
+		return;
+	}
+
+	/*
+	 * Yet another marvel of the architecture. If using the
+	 * its_list "feature", we need to make sure that all ITSs
+	 * receive all VMOVP commands in the same order. The only way
+	 * to guarantee this is to make vmovp a serialization point.
+	 *
+	 * Wall <-- Head.
+	 */
+	raw_spin_lock_irqsave(&vmovp_lock, flags);
+
+	desc.its_vmovp_cmd.seq_num = vmovp_seq_num++;
+
+	/* Emit VMOVPs */
+	list_for_each_entry(its, &its_nodes, entry) {
+		if (!its->is_v4)
+			continue;
+
+		if (!vpe->its_vm->vlpi_count[its->list_nr])
+			continue;
+
+		desc.its_vmovp_cmd.col = &its->collections[col_id];
+		its_send_single_vcommand(its, its_build_vmovp_cmd, &desc);
+	}
+
+	raw_spin_unlock_irqrestore(&vmovp_lock, flags);
+}
+
+static void its_send_vinvall(struct its_node *its, struct its_vpe *vpe)
+{
+	struct its_cmd_desc desc;
+
+	desc.its_vinvall_cmd.vpe = vpe;
+	its_send_single_vcommand(its, its_build_vinvall_cmd, &desc);
+}
+
+/*
+ * irqchip functions - assumes MSI, mostly.
+ */
+
+static inline u32 its_get_event_id(struct irq_data *d)
+{
+	struct its_device *its_dev = irq_data_get_irq_chip_data(d);
+	return d->hwirq - its_dev->event_map.lpi_base;
+}
+
+static void lpi_write_config(struct irq_data *d, u8 clr, u8 set)
+{
+	irq_hw_number_t hwirq;
+	void *va;
+	u8 *cfg;
+
+	if (irqd_is_forwarded_to_vcpu(d)) {
+		struct its_device *its_dev = irq_data_get_irq_chip_data(d);
+		u32 event = its_get_event_id(d);
+		struct its_vlpi_map *map;
+
+		va = page_address(its_dev->event_map.vm->vprop_page);
+		map = &its_dev->event_map.vlpi_maps[event];
+		hwirq = map->vintid;
+
+		/* Remember the updated property */
+		map->properties &= ~clr;
+		map->properties |= set | LPI_PROP_GROUP1;
+	} else {
+		va = gic_rdists->prop_table_va;
+		hwirq = d->hwirq;
+	}
+
+	cfg = va + hwirq - 8192;
+	*cfg &= ~clr;
+	*cfg |= set | LPI_PROP_GROUP1;
+
+	/*
+	 * Make the above write visible to the redistributors.
+	 * And yes, we're flushing exactly: One. Single. Byte.
+	 * Humpf...
+	 */
+	if (gic_rdists->flags & RDIST_FLAGS_PROPBASE_NEEDS_FLUSHING)
+		gic_flush_dcache_to_poc(cfg, sizeof(*cfg));
+	else
+		dsb(ishst);
+}
+
+static void lpi_update_config(struct irq_data *d, u8 clr, u8 set)
+{
+	struct its_device *its_dev = irq_data_get_irq_chip_data(d);
+
+	lpi_write_config(d, clr, set);
+	its_send_inv(its_dev, its_get_event_id(d));
+}
+
+static void its_vlpi_set_doorbell(struct irq_data *d, bool enable)
+{
+	struct its_device *its_dev = irq_data_get_irq_chip_data(d);
+	u32 event = its_get_event_id(d);
+
+	if (its_dev->event_map.vlpi_maps[event].db_enabled == enable)
+		return;
+
+	its_dev->event_map.vlpi_maps[event].db_enabled = enable;
+
+	/*
+	 * More fun with the architecture:
+	 *
+	 * Ideally, we'd issue a VMAPTI to set the doorbell to its LPI
+	 * value or to 1023, depending on the enable bit. But that
+	 * would be issueing a mapping for an /existing/ DevID+EventID
+	 * pair, which is UNPREDICTABLE. Instead, let's issue a VMOVI
+	 * to the /same/ vPE, using this opportunity to adjust the
+	 * doorbell. Mouahahahaha. We loves it, Precious.
+	 */
+	its_send_vmovi(its_dev, event);
+}
+
+static void its_mask_irq(struct irq_data *d)
+{
+	if (irqd_is_forwarded_to_vcpu(d))
+		its_vlpi_set_doorbell(d, false);
+
+	lpi_update_config(d, LPI_PROP_ENABLED, 0);
+}
+
+static void its_unmask_irq(struct irq_data *d)
+{
+	if (irqd_is_forwarded_to_vcpu(d))
+		its_vlpi_set_doorbell(d, true);
+
+	lpi_update_config(d, 0, LPI_PROP_ENABLED);
+}
+
+static __maybe_unused u32 its_read_lpi_count(struct irq_data *d, int cpu)
+{
+	if (irqd_affinity_is_managed(d))
+		return atomic_read(&per_cpu_ptr(&cpu_lpi_count, cpu)->managed);
+
+	return atomic_read(&per_cpu_ptr(&cpu_lpi_count, cpu)->unmanaged);
+}
+
+static void its_inc_lpi_count(struct irq_data *d, int cpu)
+{
+	if (irqd_affinity_is_managed(d))
+		atomic_inc(&per_cpu_ptr(&cpu_lpi_count, cpu)->managed);
+	else
+		atomic_inc(&per_cpu_ptr(&cpu_lpi_count, cpu)->unmanaged);
+}
+
+static void its_dec_lpi_count(struct irq_data *d, int cpu)
+{
+	if (irqd_affinity_is_managed(d))
+		atomic_dec(&per_cpu_ptr(&cpu_lpi_count, cpu)->managed);
+	else
+		atomic_dec(&per_cpu_ptr(&cpu_lpi_count, cpu)->unmanaged);
+}
+
+static unsigned int cpumask_pick_least_loaded(unsigned int target_cpu, struct irq_data *d,
+					      const struct cpumask *cpu_mask)
+{
+	unsigned int cpu = target_cpu, tmp, target_skt, dest_skt;
+	int count = S32_MAX;
+
+	target_skt = (cpu_logical_map(target_cpu) >> 16) & 0xff;
+
+	for_each_cpu(tmp, cpu_mask) {
+		int this_count = its_read_lpi_count(d, tmp);
+		dest_skt = (cpu_logical_map(tmp) >> 16) & 0xff;
+
+		if ((this_count < count) && (dest_skt == target_skt)) {
+			cpu = tmp;
+			count = this_count;
+		}
+	}
+
+	return cpu;
+}
+
+/*
+ * As suggested by Thomas Gleixner in:
+ * https://lore.kernel.org/r/87h80q2aoc.fsf@nanos.tec.linutronix.de
+ */
+static int its_select_cpu(unsigned int target_cpu, struct irq_data *d,
+			  const struct cpumask *aff_mask)
+{
+	struct its_device *its_dev = irq_data_get_irq_chip_data(d);
+	cpumask_var_t tmpmask;
+	int cpu = target_cpu, node;
+
+	if (!alloc_cpumask_var(&tmpmask, GFP_ATOMIC))
+		return -ENOMEM;
+
+	node = its_dev->its->numa_node;
+
+	if (!irqd_affinity_is_managed(d)) {
+		/* First try the NUMA node */
+		if (node != NUMA_NO_NODE) {
+			/*
+			 * Try the intersection of the affinity mask and the
+			 * node mask (and the online mask, just to be safe).
+			 */
+			cpumask_and(tmpmask, cpumask_of_node(node), aff_mask);
+			cpumask_and(tmpmask, tmpmask, cpu_online_mask);
+
+			/*
+			 * Ideally, we would check if the mask is empty, and
+			 * try again on the full node here.
+			 *
+			 * But it turns out that the way ACPI describes the
+			 * affinity for ITSs only deals about memory, and
+			 * not target CPUs, so it cannot describe a single
+			 * ITS placed next to two NUMA nodes.
+			 *
+			 * Instead, just fallback on the online mask. This
+			 * diverges from Thomas' suggestion above.
+			 */
+			cpu = cpumask_pick_least_loaded(target_cpu, d, tmpmask);
+			if (cpu < nr_cpu_ids)
+				goto out;
+
+			/* If we can't cross sockets, give up */
+			if ((its_dev->its->flags &
+			     ITS_FLAGS_WORKAROUND_CAVIUM_23144))
+				goto out;
+
+			/* If the above failed, expand the search */
+		}
+
+		/* Try the intersection of the affinity and online masks */
+		cpumask_and(tmpmask, aff_mask, cpu_online_mask);
+
+		/* If that doesn't fly, the online mask is the last resort */
+		if (cpumask_empty(tmpmask))
+			cpumask_copy(tmpmask, cpu_online_mask);
+
+		cpu = cpumask_pick_least_loaded(target_cpu, d, tmpmask);
+	} else {
+		cpumask_and(tmpmask, irq_data_get_affinity_mask(d),
+			    cpu_online_mask);
+
+		/* If we cannot cross sockets, limit the search to that node */
+		if ((its_dev->its->flags & ITS_FLAGS_WORKAROUND_CAVIUM_23144) &&
+		    node != NUMA_NO_NODE)
+			cpumask_and(tmpmask, tmpmask, cpumask_of_node(node));
+
+		cpu = cpumask_pick_least_loaded(target_cpu, d, tmpmask);
+	}
+out:
+	free_cpumask_var(tmpmask);
+
+	pr_debug("IRQ%d -> %*pbl CPU%d\n", d->irq,
+		 cpumask_pr_args(aff_mask), cpu);
+	return cpu;
+}
+
+#define MAX_MARS3_SKT_COUNT	8
+
+static int its_cpumask_select(struct its_device *its_dev,
+			      const struct cpumask *mask_val,
+			      const struct cpumask *cpu_mask)
+{
+	unsigned int skt, skt_id, i;
+	phys_addr_t its_phys_base;
+	unsigned int cpu, cpus = 0;
+
+	unsigned int skt_cpu_cnt[MAX_MARS3_SKT_COUNT] = {0};
+
+	its_phys_base = its_dev->its->phys_base;
+	skt_id = (its_phys_base >> 41) & 0x7;
+
+	for (i = 0; i < nr_cpu_ids; i++) {
+		skt = (cpu_logical_map(i) >> 16) & 0xff;
+		if ((skt >= 0) && (skt < MAX_MARS3_SKT_COUNT)) {
+			if ((is_kdump_kernel()) && (skt_id == skt)) {
+				return i;
+			}
+
+			skt_cpu_cnt[skt]++;
+		}
+		else if (skt != 0xff)
+			pr_err("socket address: %d is out of range.", skt);
+	}
+
+	if (0 != skt_id) {
+		for (i = 0; i < skt_id; i++)
+			cpus += skt_cpu_cnt[i];
+	}
+
+	cpu = cpumask_any_and(mask_val, cpu_mask);
+	if ((cpu > cpus) && (cpu < (cpus + skt_cpu_cnt[skt_id])))
+		cpus = cpu;
+
+	return cpus;
+}
+
+static int its_set_affinity(struct irq_data *d, const struct cpumask *mask_val,
+			    bool force)
+{
+	unsigned int cpu, target_cpu;
+	const struct cpumask *cpu_mask = cpu_online_mask;
+	struct its_device *its_dev = irq_data_get_irq_chip_data(d);
+	struct its_collection *target_col;
+	u32 id = its_get_event_id(d);
+	int prev_cpu;
+
+	/* A forwarded interrupt should use irq_set_vcpu_affinity */
+	if (irqd_is_forwarded_to_vcpu(d))
+		return -EINVAL;
+
+	prev_cpu = its_dev->event_map.col_map[id];
+	its_dec_lpi_count(d, prev_cpu);
+
+	target_cpu = its_cpumask_select(its_dev, mask_val, cpu_mask);
+	if (!force)
+		cpu = its_select_cpu(target_cpu, d, mask_val);
+	else
+		cpu = cpumask_pick_least_loaded(target_cpu, d, mask_val);
+
+	if (cpu < 0 || cpu >= nr_cpu_ids)
+		goto err;
+
+	/* don't set the affinity when the target cpu is same as current one */
+	if (cpu != prev_cpu) {
+		target_col = &its_dev->its->collections[cpu];
+		its_send_movi(its_dev, target_col, id);
+		its_dev->event_map.col_map[id] = cpu;
+		irq_data_update_effective_affinity(d, cpumask_of(cpu));
+	}
+
+	its_inc_lpi_count(d, cpu);
+
+	return IRQ_SET_MASK_OK_DONE;
+
+err:
+	its_inc_lpi_count(d, prev_cpu);
+	return -EINVAL;
+}
+
+static u64 its_irq_get_msi_base(struct its_device *its_dev)
+{
+	struct its_node *its = its_dev->its;
+
+	return its->phys_base + GITS_TRANSLATER;
+}
+
+static void its_irq_compose_msi_msg(struct irq_data *d, struct msi_msg *msg)
+{
+	struct its_device *its_dev = irq_data_get_irq_chip_data(d);
+	struct its_node *its;
+	u64 addr;
+
+	its = its_dev->its;
+	addr = its->get_msi_base(its_dev);
+
+	msg->address_lo		= lower_32_bits(addr);
+	msg->address_hi		= upper_32_bits(addr);
+	msg->data		= its_get_event_id(d);
+}
+
+static int its_irq_set_irqchip_state(struct irq_data *d,
+				     enum irqchip_irq_state which,
+				     bool state)
+{
+	struct its_device *its_dev = irq_data_get_irq_chip_data(d);
+	u32 event = its_get_event_id(d);
+
+	if (which != IRQCHIP_STATE_PENDING)
+		return -EINVAL;
+
+	if (state)
+		its_send_int(its_dev, event);
+	else
+		its_send_clear(its_dev, event);
+
+	return 0;
+}
+
+static void its_map_vm(struct its_node *its, struct its_vm *vm)
+{
+	unsigned long flags;
+
+	/* Not using the ITS list? Everything is always mapped. */
+	if (!its_list_map)
+		return;
+
+	raw_spin_lock_irqsave(&vmovp_lock, flags);
+
+	/*
+	 * If the VM wasn't mapped yet, iterate over the vpes and get
+	 * them mapped now.
+	 */
+	vm->vlpi_count[its->list_nr]++;
+
+	if (vm->vlpi_count[its->list_nr] == 1) {
+		int i;
+
+		for (i = 0; i < vm->nr_vpes; i++) {
+			struct its_vpe *vpe = vm->vpes[i];
+			struct irq_data *d = irq_get_irq_data(vpe->irq);
+
+			/* Map the VPE to the first possible CPU */
+			vpe->col_idx = cpumask_first(cpu_online_mask);
+			its_send_vmapp(its, vpe, true);
+			its_send_vinvall(its, vpe);
+			irq_data_update_effective_affinity(d, cpumask_of(vpe->col_idx));
+		}
+	}
+
+	raw_spin_unlock_irqrestore(&vmovp_lock, flags);
+}
+
+static void its_unmap_vm(struct its_node *its, struct its_vm *vm)
+{
+	unsigned long flags;
+
+	/* Not using the ITS list? Everything is always mapped. */
+	if (!its_list_map)
+		return;
+
+	raw_spin_lock_irqsave(&vmovp_lock, flags);
+
+	if (!--vm->vlpi_count[its->list_nr]) {
+		int i;
+
+		for (i = 0; i < vm->nr_vpes; i++)
+			its_send_vmapp(its, vm->vpes[i], false);
+	}
+
+	raw_spin_unlock_irqrestore(&vmovp_lock, flags);
+}
+
+static int its_vlpi_map(struct irq_data *d, struct its_cmd_info *info)
+{
+	struct its_device *its_dev = irq_data_get_irq_chip_data(d);
+	u32 event = its_get_event_id(d);
+	int ret = 0;
+
+	if (!info->map)
+		return -EINVAL;
+
+	mutex_lock(&its_dev->event_map.vlpi_lock);
+
+	if (!its_dev->event_map.vm) {
+		struct its_vlpi_map *maps;
+
+		maps = kcalloc(its_dev->event_map.nr_lpis, sizeof(*maps),
+			       GFP_KERNEL);
+		if (!maps) {
+			ret = -ENOMEM;
+			goto out;
+		}
+
+		its_dev->event_map.vm = info->map->vm;
+		its_dev->event_map.vlpi_maps = maps;
+	} else if (its_dev->event_map.vm != info->map->vm) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* Get our private copy of the mapping information */
+	its_dev->event_map.vlpi_maps[event] = *info->map;
+
+	if (irqd_is_forwarded_to_vcpu(d)) {
+		/* Already mapped, move it around */
+		its_send_vmovi(its_dev, event);
+	} else {
+		/* Ensure all the VPEs are mapped on this ITS */
+		its_map_vm(its_dev->its, info->map->vm);
+
+		/*
+		 * Flag the interrupt as forwarded so that we can
+		 * start poking the virtual property table.
+		 */
+		irqd_set_forwarded_to_vcpu(d);
+
+		/* Write out the property to the prop table */
+		lpi_write_config(d, 0xff, info->map->properties);
+
+		/* Drop the physical mapping */
+		its_send_discard(its_dev, event);
+
+		/* and install the virtual one */
+		its_send_vmapti(its_dev, event);
+
+		/* Increment the number of VLPIs */
+		its_dev->event_map.nr_vlpis++;
+	}
+
+out:
+	mutex_unlock(&its_dev->event_map.vlpi_lock);
+	return ret;
+}
+
+static int its_vlpi_get(struct irq_data *d, struct its_cmd_info *info)
+{
+	struct its_device *its_dev = irq_data_get_irq_chip_data(d);
+	u32 event = its_get_event_id(d);
+	int ret = 0;
+
+	mutex_lock(&its_dev->event_map.vlpi_lock);
+
+	if (!its_dev->event_map.vm ||
+	    !its_dev->event_map.vlpi_maps[event].vm) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* Copy our mapping information to the incoming request */
+	*info->map = its_dev->event_map.vlpi_maps[event];
+
+out:
+	mutex_unlock(&its_dev->event_map.vlpi_lock);
+	return ret;
+}
+
+static int its_vlpi_unmap(struct irq_data *d)
+{
+	struct its_device *its_dev = irq_data_get_irq_chip_data(d);
+	u32 event = its_get_event_id(d);
+	int ret = 0;
+
+	mutex_lock(&its_dev->event_map.vlpi_lock);
+
+	if (!its_dev->event_map.vm || !irqd_is_forwarded_to_vcpu(d)) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* Drop the virtual mapping */
+	its_send_discard(its_dev, event);
+
+	/* and restore the physical one */
+	irqd_clr_forwarded_to_vcpu(d);
+	its_send_mapti(its_dev, d->hwirq, event);
+	lpi_update_config(d, 0xff, (LPI_PROP_DEFAULT_PRIO |
+				    LPI_PROP_ENABLED |
+				    LPI_PROP_GROUP1));
+
+	/* Potentially unmap the VM from this ITS */
+	its_unmap_vm(its_dev->its, its_dev->event_map.vm);
+
+	/*
+	 * Drop the refcount and make the device available again if
+	 * this was the last VLPI.
+	 */
+	if (!--its_dev->event_map.nr_vlpis) {
+		its_dev->event_map.vm = NULL;
+		kfree(its_dev->event_map.vlpi_maps);
+	}
+
+out:
+	mutex_unlock(&its_dev->event_map.vlpi_lock);
+	return ret;
+}
+
+static int its_vlpi_prop_update(struct irq_data *d, struct its_cmd_info *info)
+{
+	struct its_device *its_dev = irq_data_get_irq_chip_data(d);
+
+	if (!its_dev->event_map.vm || !irqd_is_forwarded_to_vcpu(d))
+		return -EINVAL;
+
+	if (info->cmd_type == PROP_UPDATE_AND_INV_VLPI)
+		lpi_update_config(d, 0xff, info->config);
+	else
+		lpi_write_config(d, 0xff, info->config);
+	its_vlpi_set_doorbell(d, !!(info->config & LPI_PROP_ENABLED));
+
+	return 0;
+}
+
+static int its_irq_set_vcpu_affinity(struct irq_data *d, void *vcpu_info)
+{
+	struct its_device *its_dev = irq_data_get_irq_chip_data(d);
+	struct its_cmd_info *info = vcpu_info;
+
+	/* Need a v4 ITS */
+	if (!its_dev->its->is_v4)
+		return -EINVAL;
+
+	/* Unmap request? */
+	if (!info)
+		return its_vlpi_unmap(d);
+
+	switch (info->cmd_type) {
+	case MAP_VLPI:
+		return its_vlpi_map(d, info);
+
+	case GET_VLPI:
+		return its_vlpi_get(d, info);
+
+	case PROP_UPDATE_VLPI:
+	case PROP_UPDATE_AND_INV_VLPI:
+		return its_vlpi_prop_update(d, info);
+
+	default:
+		return -EINVAL;
+	}
+}
+
+static int its_irq_retrigger(struct irq_data *d)
+{
+	return !its_irq_set_irqchip_state(d, IRQCHIP_STATE_PENDING, true);
+}
+
+static struct irq_chip its_irq_chip = {
+	.name			= "ITS",
+	.irq_mask		= its_mask_irq,
+	.irq_unmask		= its_unmask_irq,
+	.irq_eoi		= irq_chip_eoi_parent,
+	.irq_set_affinity	= its_set_affinity,
+	.irq_compose_msi_msg	= its_irq_compose_msi_msg,
+	.irq_set_irqchip_state	= its_irq_set_irqchip_state,
+	.irq_retrigger      = its_irq_retrigger,
+	.irq_set_vcpu_affinity	= its_irq_set_vcpu_affinity,
+};
+
+
+/*
+ * How we allocate LPIs:
+ *
+ * lpi_range_list contains ranges of LPIs that are to available to
+ * allocate from. To allocate LPIs, just pick the first range that
+ * fits the required allocation, and reduce it by the required
+ * amount. Once empty, remove the range from the list.
+ *
+ * To free a range of LPIs, add a free range to the list, sort it and
+ * merge the result if the new range happens to be adjacent to an
+ * already free block.
+ *
+ * The consequence of the above is that allocation is cost is low, but
+ * freeing is expensive. We assumes that freeing rarely occurs.
+ */
+#define ITS_MAX_LPI_NRBITS	16 /* 64K LPIs */
+
+static DEFINE_MUTEX(lpi_range_lock);
+static LIST_HEAD(lpi_range_list);
+
+struct lpi_range {
+	struct list_head	entry;
+	u32			base_id;
+	u32			span;
+};
+
+static struct lpi_range *mk_lpi_range(u32 base, u32 span)
+{
+	struct lpi_range *range;
+
+	range = kzalloc(sizeof(*range), GFP_KERNEL);
+	if (range) {
+		INIT_LIST_HEAD(&range->entry);
+		range->base_id = base;
+		range->span = span;
+	}
+
+	return range;
+}
+
+static int lpi_range_cmp(void *priv, struct list_head *a, struct list_head *b)
+{
+	struct lpi_range *ra, *rb;
+
+	ra = container_of(a, struct lpi_range, entry);
+	rb = container_of(b, struct lpi_range, entry);
+
+	return rb->base_id - ra->base_id;
+}
+
+static void merge_lpi_ranges(void)
+{
+	struct lpi_range *range, *tmp;
+
+	list_for_each_entry_safe(range, tmp, &lpi_range_list, entry) {
+		if (!list_is_last(&range->entry, &lpi_range_list) &&
+		    (tmp->base_id == (range->base_id + range->span))) {
+			tmp->base_id = range->base_id;
+			tmp->span += range->span;
+			list_del(&range->entry);
+			kfree(range);
+		}
+	}
+}
+
+static int alloc_lpi_range(u32 nr_lpis, u32 *base)
+{
+	struct lpi_range *range, *tmp;
+	int err = -ENOSPC;
+
+	mutex_lock(&lpi_range_lock);
+
+	list_for_each_entry_safe(range, tmp, &lpi_range_list, entry) {
+		if (range->span >= nr_lpis) {
+			*base = range->base_id;
+			range->base_id += nr_lpis;
+			range->span -= nr_lpis;
+
+			if (range->span == 0) {
+				list_del(&range->entry);
+				kfree(range);
+			}
+
+			err = 0;
+			break;
+		}
+	}
+
+	mutex_unlock(&lpi_range_lock);
+
+	pr_debug("ITS: alloc %u:%u\n", *base, nr_lpis);
+	return err;
+}
+
+static int free_lpi_range(u32 base, u32 nr_lpis)
+{
+	struct lpi_range *new;
+	int err = 0;
+
+	mutex_lock(&lpi_range_lock);
+
+	new = mk_lpi_range(base, nr_lpis);
+	if (!new) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	list_add(&new->entry, &lpi_range_list);
+	list_sort(NULL, &lpi_range_list, lpi_range_cmp);
+	merge_lpi_ranges();
+out:
+	mutex_unlock(&lpi_range_lock);
+	return err;
+}
+
+static int __init its_lpi_init(u32 id_bits)
+{
+	u32 lpis = (1UL << id_bits) - 8192;
+	u32 numlpis;
+	int err;
+
+	numlpis = 1UL << GICD_TYPER_NUM_LPIS(gic_rdists->gicd_typer);
+
+	if (numlpis > 2 && !WARN_ON(numlpis > lpis)) {
+		lpis = numlpis;
+		pr_info("ITS: Using hypervisor restricted LPI range [%u]\n",
+			lpis);
+	}
+
+	/*
+	 * Initializing the allocator is just the same as freeing the
+	 * full range of LPIs.
+	 */
+	err = free_lpi_range(8192, lpis);
+	pr_debug("ITS: Allocator initialized for %u LPIs\n", lpis);
+	return err;
+}
+
+static unsigned long *its_lpi_alloc(int nr_irqs, u32 *base, int *nr_ids)
+{
+	unsigned long *bitmap = NULL;
+	int err = 0;
+
+	do {
+		err = alloc_lpi_range(nr_irqs, base);
+		if (!err)
+			break;
+
+		nr_irqs /= 2;
+	} while (nr_irqs > 0);
+
+	if (err)
+		goto out;
+
+	bitmap = kcalloc(BITS_TO_LONGS(nr_irqs), sizeof (long), GFP_ATOMIC);
+	if (!bitmap)
+		goto out;
+
+	*nr_ids = nr_irqs;
+
+out:
+	if (!bitmap)
+		*base = *nr_ids = 0;
+
+	return bitmap;
+}
+
+static void its_lpi_free(unsigned long *bitmap, u32 base, u32 nr_ids)
+{
+	WARN_ON(free_lpi_range(base, nr_ids));
+	kfree(bitmap);
+}
+
+static void gic_reset_prop_table(void *va)
+{
+	/* Priority 0xa0, Group-1, disabled */
+	memset(va, LPI_PROP_DEFAULT_PRIO | LPI_PROP_GROUP1, LPI_PROPBASE_SZ);
+
+	/* Make sure the GIC will observe the written configuration */
+	gic_flush_dcache_to_poc(va, LPI_PROPBASE_SZ);
+}
+
+static struct page *its_allocate_prop_table(gfp_t gfp_flags)
+{
+	struct page *prop_page;
+
+	prop_page = alloc_pages(gfp_flags, get_order(LPI_PROPBASE_SZ));
+	if (!prop_page)
+		return NULL;
+
+	gic_reset_prop_table(page_address(prop_page));
+
+	return prop_page;
+}
+
+static void its_free_prop_table(struct page *prop_page)
+{
+	free_pages((unsigned long)page_address(prop_page),
+		   get_order(LPI_PROPBASE_SZ));
+}
+
+static bool gic_check_reserved_range(phys_addr_t addr, unsigned long size)
+{
+	phys_addr_t start, end, addr_end;
+	u64 i;
+
+	/*
+	 * We don't bother checking for a kdump kernel as by
+	 * construction, the LPI tables are out of this kernel's
+	 * memory map.
+	 */
+	if (is_kdump_kernel())
+		return true;
+
+	addr_end = addr + size - 1;
+
+	for_each_reserved_mem_range(i, &start, &end) {
+		if (addr >= start && addr_end <= end)
+			return true;
+	}
+
+	/* Not found, not a good sign... */
+	pr_warn("GICv3: Expected reserved range [%pa:%pa], not found\n",
+		&addr, &addr_end);
+	add_taint(TAINT_CRAP, LOCKDEP_STILL_OK);
+	return false;
+}
+
+static int gic_reserve_range(phys_addr_t addr, unsigned long size)
+{
+	if (efi_enabled(EFI_CONFIG_TABLES))
+		return efi_mem_reserve_persistent(addr, size);
+
+	return 0;
+}
+static int __init its_setup_lpi_prop_table(void)
+{
+	if (gic_rdists->flags & RDIST_FLAGS_RD_TABLES_PREALLOCATED) {
+		u64 val;
+
+		val = gicr_read_propbaser(gic_data_rdist_rd_base() + GICR_PROPBASER);
+		lpi_id_bits = (val & GICR_PROPBASER_IDBITS_MASK) + 1;
+
+		gic_rdists->prop_table_pa = val & GENMASK_ULL(51, 12);
+		gic_rdists->prop_table_va = memremap(gic_rdists->prop_table_pa,
+						     LPI_PROPBASE_SZ,
+						     MEMREMAP_WB);
+		gic_reset_prop_table(gic_rdists->prop_table_va);
+	} else {
+		struct page *page;
+
+		lpi_id_bits = min_t(u32,
+				    GICD_TYPER_ID_BITS(gic_rdists->gicd_typer),
+				    ITS_MAX_LPI_NRBITS);
+		page = its_allocate_prop_table(GFP_NOWAIT);
+		if (!page) {
+			pr_err("Failed to allocate PROPBASE\n");
+			return -ENOMEM;
+		}
+
+		gic_rdists->prop_table_pa = page_to_phys(page);
+		gic_rdists->prop_table_va = page_address(page);
+		WARN_ON(gic_reserve_range(gic_rdists->prop_table_pa,
+					  LPI_PROPBASE_SZ));
+	}
+
+	pr_info("GICv-2500: using LPI property table @%pa\n",
+		&gic_rdists->prop_table_pa);
+
+	return its_lpi_init(lpi_id_bits);
+}
+
+static const char *its_base_type_string[] = {
+	[GITS_BASER_TYPE_DEVICE]	= "Devices",
+	[GITS_BASER_TYPE_VCPU]		= "Virtual CPUs",
+	[GITS_BASER_TYPE_RESERVED3]	= "Reserved (3)",
+	[GITS_BASER_TYPE_COLLECTION]	= "Interrupt Collections",
+	[GITS_BASER_TYPE_RESERVED5] 	= "Reserved (5)",
+	[GITS_BASER_TYPE_RESERVED6] 	= "Reserved (6)",
+	[GITS_BASER_TYPE_RESERVED7] 	= "Reserved (7)",
+};
+
+static u64 its_read_baser(struct its_node *its, struct its_baser *baser)
+{
+	u32 idx = baser - its->tables;
+
+	return gits_read_baser(its->base + GITS_BASER + (idx << 3));
+}
+
+static void its_write_baser(struct its_node *its, struct its_baser *baser,
+			    u64 val)
+{
+	u32 idx = baser - its->tables;
+
+	gits_write_baser(val, its->base + GITS_BASER + (idx << 3));
+	baser->val = its_read_baser(its, baser);
+}
+
+static int its_setup_baser(struct its_node *its, struct its_baser *baser,
+			   u64 cache, u64 shr, u32 psz, u32 order,
+			   bool indirect)
+{
+	u64 val = its_read_baser(its, baser);
+	u64 esz = GITS_BASER_ENTRY_SIZE(val);
+	u64 type = GITS_BASER_TYPE(val);
+	u64 baser_phys, tmp;
+	u32 alloc_pages;
+	void *base;
+
+retry_alloc_baser:
+	alloc_pages = (PAGE_ORDER_TO_SIZE(order) / psz);
+	if (alloc_pages > GITS_BASER_PAGES_MAX) {
+		pr_warn("ITS@%pa: %s too large, reduce ITS pages %u->%u\n",
+			&its->phys_base, its_base_type_string[type],
+			alloc_pages, GITS_BASER_PAGES_MAX);
+		alloc_pages = GITS_BASER_PAGES_MAX;
+		order = get_order(GITS_BASER_PAGES_MAX * psz);
+	}
+
+	base = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, order);
+	if (!base)
+		return -ENOMEM;
+
+	baser_phys = virt_to_phys(base);
+
+	/* Check if the physical address of the memory is above 48bits */
+	if (IS_ENABLED(CONFIG_ARM64_64K_PAGES) && (baser_phys >> 48)) {
+
+		/* 52bit PA is supported only when PageSize=64K */
+		if (psz != SZ_64K) {
+			pr_err("ITS: no 52bit PA support when psz=%d\n", psz);
+			free_pages((unsigned long)base, order);
+			return -ENXIO;
+		}
+
+		/* Convert 52bit PA to 48bit field */
+		baser_phys = GITS_BASER_PHYS_52_to_48(baser_phys);
+	}
+
+retry_baser:
+	val = (baser_phys					 |
+		(type << GITS_BASER_TYPE_SHIFT)			 |
+		((esz - 1) << GITS_BASER_ENTRY_SIZE_SHIFT)	 |
+		((alloc_pages - 1) << GITS_BASER_PAGES_SHIFT)	 |
+		cache						 |
+		shr						 |
+		GITS_BASER_VALID);
+
+	val |=	indirect ? GITS_BASER_INDIRECT : 0x0;
+
+	switch (psz) {
+	case SZ_4K:
+		val |= GITS_BASER_PAGE_SIZE_4K;
+		break;
+	case SZ_16K:
+		val |= GITS_BASER_PAGE_SIZE_16K;
+		break;
+	case SZ_64K:
+		val |= GITS_BASER_PAGE_SIZE_64K;
+		break;
+	}
+
+	its_write_baser(its, baser, val);
+	tmp = baser->val;
+
+	if ((val ^ tmp) & GITS_BASER_SHAREABILITY_MASK) {
+		/*
+		 * Shareability didn't stick. Just use
+		 * whatever the read reported, which is likely
+		 * to be the only thing this redistributor
+		 * supports. If that's zero, make it
+		 * non-cacheable as well.
+		 */
+		shr = tmp & GITS_BASER_SHAREABILITY_MASK;
+		if (!shr) {
+			cache = GITS_BASER_nC;
+			gic_flush_dcache_to_poc(base, PAGE_ORDER_TO_SIZE(order));
+		}
+		goto retry_baser;
+	}
+
+	if ((val ^ tmp) & GITS_BASER_PAGE_SIZE_MASK) {
+		/*
+		 * Page size didn't stick. Let's try a smaller
+		 * size and retry. If we reach 4K, then
+		 * something is horribly wrong...
+		 */
+		free_pages((unsigned long)base, order);
+		baser->base = NULL;
+
+		switch (psz) {
+		case SZ_16K:
+			psz = SZ_4K;
+			goto retry_alloc_baser;
+		case SZ_64K:
+			psz = SZ_16K;
+			goto retry_alloc_baser;
+		}
+	}
+
+	if (val != tmp) {
+		pr_err("ITS@%pa: %s doesn't stick: %llx %llx\n",
+		       &its->phys_base, its_base_type_string[type],
+		       val, tmp);
+		free_pages((unsigned long)base, order);
+		return -ENXIO;
+	}
+
+	baser->order = order;
+	baser->base = base;
+	baser->psz = psz;
+	tmp = indirect ? GITS_LVL1_ENTRY_SIZE : esz;
+
+	pr_info("ITS@%pa: allocated %d %s @%lx (%s, esz %d, psz %dK, shr %d)\n",
+		&its->phys_base, (int)(PAGE_ORDER_TO_SIZE(order) / (int)tmp),
+		its_base_type_string[type],
+		(unsigned long)virt_to_phys(base),
+		indirect ? "indirect" : "flat", (int)esz,
+		psz / SZ_1K, (int)shr >> GITS_BASER_SHAREABILITY_SHIFT);
+
+	return 0;
+}
+
+static bool its_parse_indirect_baser(struct its_node *its,
+				     struct its_baser *baser,
+				     u32 psz, u32 *order, u32 ids)
+{
+	u64 tmp = its_read_baser(its, baser);
+	u64 type = GITS_BASER_TYPE(tmp);
+	u64 esz = GITS_BASER_ENTRY_SIZE(tmp);
+	u64 val = GITS_BASER_InnerShareable | GITS_BASER_RaWaWb;
+	u32 new_order = *order;
+	bool indirect = false;
+
+	/* No need to enable Indirection if memory requirement < (psz*2)bytes */
+	if ((esz << ids) > (psz * 2)) {
+		/*
+		 * Find out whether hw supports a single or two-level table by
+		 * table by reading bit at offset '62' after writing '1' to it.
+		 */
+		its_write_baser(its, baser, val | GITS_BASER_INDIRECT);
+		indirect = !!(baser->val & GITS_BASER_INDIRECT);
+
+		if (indirect) {
+			/*
+			 * The size of the lvl2 table is equal to ITS page size
+			 * which is 'psz'. For computing lvl1 table size,
+			 * subtract ID bits that sparse lvl2 table from 'ids'
+			 * which is reported by ITS hardware times lvl1 table
+			 * entry size.
+			 */
+			ids -= ilog2(psz / (int)esz);
+			esz = GITS_LVL1_ENTRY_SIZE;
+		}
+	}
+
+	/*
+	 * Allocate as many entries as required to fit the
+	 * range of device IDs that the ITS can grok... The ID
+	 * space being incredibly sparse, this results in a
+	 * massive waste of memory if two-level device table
+	 * feature is not supported by hardware.
+	 */
+	new_order = max_t(u32, get_order(esz << ids), new_order);
+	if (new_order >= MAX_ORDER) {
+		new_order = MAX_ORDER - 1;
+		ids = ilog2(PAGE_ORDER_TO_SIZE(new_order) / (int)esz);
+		pr_warn("ITS@%pa: %s Table too large, reduce ids %u->%u\n",
+			&its->phys_base, its_base_type_string[type],
+			its->device_ids, ids);
+	}
+
+	*order = new_order;
+
+	return indirect;
+}
+
+static void its_free_tables(struct its_node *its)
+{
+	int i;
+
+	for (i = 0; i < GITS_BASER_NR_REGS; i++) {
+		if (its->tables[i].base) {
+			free_pages((unsigned long)its->tables[i].base,
+				   its->tables[i].order);
+			its->tables[i].base = NULL;
+		}
+	}
+}
+
+static int its_alloc_tables(struct its_node *its)
+{
+	u64 shr = GITS_BASER_InnerShareable;
+	u64 cache = GITS_BASER_RaWaWb;
+	u32 psz = SZ_64K;
+	int err, i;
+
+	if (its->flags & ITS_FLAGS_WORKAROUND_CAVIUM_22375)
+		/* erratum 24313: ignore memory access type */
+		cache = GITS_BASER_nCnB;
+
+	for (i = 0; i < GITS_BASER_NR_REGS; i++) {
+		struct its_baser *baser = its->tables + i;
+		u64 val = its_read_baser(its, baser);
+		u64 type = GITS_BASER_TYPE(val);
+		u32 order = get_order(psz);
+		bool indirect = false;
+
+		switch (type) {
+		case GITS_BASER_TYPE_NONE:
+			continue;
+
+		case GITS_BASER_TYPE_DEVICE:
+			indirect = its_parse_indirect_baser(its, baser, psz, &order, its->device_ids);
+			break;
+
+		case GITS_BASER_TYPE_VCPU:
+
+			indirect = its_parse_indirect_baser(its, baser, psz, &order, ITS_MAX_VPEID_BITS);
+			break;
+		}
+
+		err = its_setup_baser(its, baser, cache, shr, psz, order, indirect);
+		if (err < 0) {
+			its_free_tables(its);
+			return err;
+		}
+
+		/* Update settings which will be used for next BASERn */
+		psz = baser->psz;
+		cache = baser->val & GITS_BASER_CACHEABILITY_MASK;
+		shr = baser->val & GITS_BASER_SHAREABILITY_MASK;
+	}
+
+	return 0;
+}
+
+static int its_alloc_collections(struct its_node *its)
+{
+	int i;
+
+	its->collections = kcalloc(nr_cpu_ids, sizeof(*its->collections),
+				   GFP_KERNEL);
+	if (!its->collections)
+		return -ENOMEM;
+
+	for (i = 0; i < nr_cpu_ids; i++)
+		its->collections[i].target_address = ~0ULL;
+
+	return 0;
+}
+
+static struct page *its_allocate_pending_table(gfp_t gfp_flags)
+{
+	struct page *pend_page;
+
+	pend_page = alloc_pages(gfp_flags | __GFP_ZERO,
+				get_order(LPI_PENDBASE_SZ));
+	if (!pend_page)
+		return NULL;
+
+	/* Make sure the GIC will observe the zero-ed page */
+	gic_flush_dcache_to_poc(page_address(pend_page), LPI_PENDBASE_SZ);
+
+	return pend_page;
+}
+
+static void its_free_pending_table(struct page *pt)
+{
+	free_pages((unsigned long)page_address(pt), get_order(LPI_PENDBASE_SZ));
+}
+
+/*
+ * Booting with kdump and LPIs enabled is generally fine. Any other
+ * case is wrong in the absence of firmware/EFI support.
+ */
+static bool enabled_lpis_allowed(void)
+{
+	phys_addr_t addr;
+	u64 val;
+
+	/* Check whether the property table is in a reserved region */
+	val = gicr_read_propbaser(gic_data_rdist_rd_base() + GICR_PROPBASER);
+	addr = val & GENMASK_ULL(51, 12);
+
+	return gic_check_reserved_range(addr, LPI_PROPBASE_SZ);
+}
+
+static int __init allocate_lpi_tables(void)
+{
+	u64 val;
+	int err, cpu;
+
+	/*
+	 * If LPIs are enabled while we run this from the boot CPU,
+	 * flag the RD tables as pre-allocated if the stars do align.
+	 */
+	val = readl_relaxed(gic_data_rdist_rd_base() + GICR_CTLR);
+	if ((val & GICR_CTLR_ENABLE_LPIS) && enabled_lpis_allowed()) {
+		gic_rdists->flags |= (RDIST_FLAGS_RD_TABLES_PREALLOCATED |
+				      RDIST_FLAGS_PROPBASE_NEEDS_FLUSHING);
+		pr_info("GICv3: Using preallocated redistributor tables\n");
+	}
+
+	err = its_setup_lpi_prop_table();
+	if (err)
+		return err;
+
+	/*
+	 * We allocate all the pending tables anyway, as we may have a
+	 * mix of RDs that have had LPIs enabled, and some that
+	 * don't. We'll free the unused ones as each CPU comes online.
+	 */
+	for_each_possible_cpu(cpu) {
+		struct page *pend_page;
+
+		pend_page = its_allocate_pending_table(GFP_NOWAIT);
+		if (!pend_page) {
+			pr_err("Failed to allocate PENDBASE for CPU%d\n", cpu);
+			return -ENOMEM;
+		}
+
+		gic_data_rdist_cpu(cpu)->pend_page = pend_page;
+	}
+
+	return 0;
+}
+
+static void its_cpu_init_lpis(void)
+{
+	void __iomem *rbase = gic_data_rdist_rd_base();
+	struct page *pend_page;
+	phys_addr_t paddr;
+	u64 val, tmp;
+
+	if (gic_data_rdist()->lpi_enabled)
+		return;
+
+	val = readl_relaxed(rbase + GICR_CTLR);
+	if ((gic_rdists->flags & RDIST_FLAGS_RD_TABLES_PREALLOCATED) &&
+	    (val & GICR_CTLR_ENABLE_LPIS)) {
+		/*
+		 * Check that we get the same property table on all
+		 * RDs. If we don't, this is hopeless.
+		 */
+		paddr = gicr_read_propbaser(rbase + GICR_PROPBASER);
+		paddr &= GENMASK_ULL(51, 12);
+		if (WARN_ON(gic_rdists->prop_table_pa != paddr))
+			add_taint(TAINT_CRAP, LOCKDEP_STILL_OK);
+
+		paddr = gicr_read_pendbaser(rbase + GICR_PENDBASER);
+		paddr &= GENMASK_ULL(51, 16);
+
+		WARN_ON(!gic_check_reserved_range(paddr, LPI_PENDBASE_SZ));
+		its_free_pending_table(gic_data_rdist()->pend_page);
+		gic_data_rdist()->pend_page = NULL;
+
+		goto out;
+	}
+
+	pend_page = gic_data_rdist()->pend_page;
+	paddr = page_to_phys(pend_page);
+	WARN_ON(gic_reserve_range(paddr, LPI_PENDBASE_SZ));
+
+	/* set PROPBASE */
+	val = (gic_rdists->prop_table_pa |
+	       GICR_PROPBASER_InnerShareable |
+	       GICR_PROPBASER_RaWaWb |
+	       ((LPI_NRBITS - 1) & GICR_PROPBASER_IDBITS_MASK));
+
+	gicr_write_propbaser(val, rbase + GICR_PROPBASER);
+	tmp = gicr_read_propbaser(rbase + GICR_PROPBASER);
+
+	if ((tmp ^ val) & GICR_PROPBASER_SHAREABILITY_MASK) {
+		if (!(tmp & GICR_PROPBASER_SHAREABILITY_MASK)) {
+			/*
+			 * The HW reports non-shareable, we must
+			 * remove the cacheability attributes as
+			 * well.
+			 */
+			val &= ~(GICR_PROPBASER_SHAREABILITY_MASK |
+				 GICR_PROPBASER_CACHEABILITY_MASK);
+			val |= GICR_PROPBASER_nC;
+			gicr_write_propbaser(val, rbase + GICR_PROPBASER);
+		}
+		pr_info_once("GIC: using cache flushing for LPI property table\n");
+		gic_rdists->flags |= RDIST_FLAGS_PROPBASE_NEEDS_FLUSHING;
+	}
+
+	/* set PENDBASE */
+	val = (page_to_phys(pend_page) |
+	       GICR_PENDBASER_InnerShareable |
+	       GICR_PENDBASER_RaWaWb);
+
+	gicr_write_pendbaser(val, rbase + GICR_PENDBASER);
+	tmp = gicr_read_pendbaser(rbase + GICR_PENDBASER);
+
+	if (!(tmp & GICR_PENDBASER_SHAREABILITY_MASK)) {
+		/*
+		 * The HW reports non-shareable, we must remove the
+		 * cacheability attributes as well.
+		 */
+		val &= ~(GICR_PENDBASER_SHAREABILITY_MASK |
+			 GICR_PENDBASER_CACHEABILITY_MASK);
+		val |= GICR_PENDBASER_nC;
+		gicr_write_pendbaser(val, rbase + GICR_PENDBASER);
+	}
+
+	/* Enable LPIs */
+	val = readl_relaxed(rbase + GICR_CTLR);
+	val |= GICR_CTLR_ENABLE_LPIS;
+	writel_relaxed(val, rbase + GICR_CTLR);
+
+	/* Make sure the GIC has seen the above */
+	dsb(sy);
+out:
+	gic_data_rdist()->lpi_enabled = true;
+	pr_info("GICv-2500: CPU%d: using %s LPI pending table @%pa\n",
+		smp_processor_id(),
+		gic_data_rdist()->pend_page ? "allocated" : "reserved",
+		&paddr);
+}
+
+static void its_cpu_init_collection(struct its_node *its)
+{
+	int cpu = smp_processor_id();
+	unsigned long mpid, skt_id;
+	phys_addr_t its_phys_base;
+	u64 target;
+
+	/* avoid cross node collections and its mapping */
+	if (its->flags & ITS_FLAGS_WORKAROUND_CAVIUM_23144) {
+		struct device_node *cpu_node;
+
+		cpu_node = of_get_cpu_node(cpu, NULL);
+		if (its->numa_node != NUMA_NO_NODE &&
+			its->numa_node != of_node_to_nid(cpu_node))
+			return;
+	}
+
+	mpid = cpu_logical_map(cpu);
+	its_phys_base = its->phys_base;
+	skt_id = (its_phys_base >> 41) & 0x7;
+
+	/*
+	 * We now have to bind each collection to its target
+	 * redistributor.
+	 */
+	if (gic_read_typer(its->base + GITS_TYPER) & GITS_TYPER_PTA) {
+		/*
+		 * This ITS wants the physical address of the
+		 * redistributor.
+		 */
+		target = gic_data_rdist()->phys_base;
+	} else {
+		/* This ITS wants a linear CPU number. */
+		target = gic_read_typer(gic_data_rdist_rd_base() + GICR_TYPER);
+		target = GICR_TYPER_CPU_NUMBER(target) << 16;
+	}
+
+	/* Perform collection mapping */
+	its->collections[cpu].target_address = target;
+	if (is_kdump_kernel())
+		its->collections[cpu].col_id = cpu % 65;
+	else
+		its->collections[cpu].col_id = cpu % 64;
+
+	its_send_mapc(its, &its->collections[cpu], 1);
+	its_send_invall(its, &its->collections[cpu]);
+}
+
+static void its_cpu_init_collections(void)
+{
+	struct its_node *its;
+
+	raw_spin_lock(&its_lock);
+
+	list_for_each_entry(its, &its_nodes, entry)
+		its_cpu_init_collection(its);
+
+	raw_spin_unlock(&its_lock);
+}
+
+static struct its_device *its_find_device(struct its_node *its, u32 dev_id)
+{
+	struct its_device *its_dev = NULL, *tmp;
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&its->lock, flags);
+
+	list_for_each_entry(tmp, &its->its_device_list, entry) {
+		if (tmp->device_id == dev_id) {
+			its_dev = tmp;
+			break;
+		}
+	}
+
+	raw_spin_unlock_irqrestore(&its->lock, flags);
+
+	return its_dev;
+}
+
+static struct its_baser *its_get_baser(struct its_node *its, u32 type)
+{
+	int i;
+
+	for (i = 0; i < GITS_BASER_NR_REGS; i++) {
+		if (GITS_BASER_TYPE(its->tables[i].val) == type)
+			return &its->tables[i];
+	}
+
+	return NULL;
+}
+
+static bool its_alloc_table_entry(struct its_baser *baser, u32 id)
+{
+	struct page *page;
+	u32 esz, idx;
+	__le64 *table;
+
+	/* Don't allow device id that exceeds single, flat table limit */
+	esz = GITS_BASER_ENTRY_SIZE(baser->val);
+	if (!(baser->val & GITS_BASER_INDIRECT))
+		return (id < (PAGE_ORDER_TO_SIZE(baser->order) / esz));
+
+	/* Compute 1st level table index & check if that exceeds table limit */
+	idx = id >> ilog2(baser->psz / esz);
+	if (idx >= (PAGE_ORDER_TO_SIZE(baser->order) / GITS_LVL1_ENTRY_SIZE))
+		return false;
+
+	table = baser->base;
+
+	/* Allocate memory for 2nd level table */
+	if (!table[idx]) {
+		page = alloc_pages(GFP_KERNEL | __GFP_ZERO, get_order(baser->psz));
+		if (!page)
+			return false;
+
+		/* Flush Lvl2 table to PoC if hw doesn't support coherency */
+		if (!(baser->val & GITS_BASER_SHAREABILITY_MASK))
+			gic_flush_dcache_to_poc(page_address(page), baser->psz);
+
+		table[idx] = cpu_to_le64(page_to_phys(page) | GITS_BASER_VALID);
+
+		/* Flush Lvl1 entry to PoC if hw doesn't support coherency */
+		if (!(baser->val & GITS_BASER_SHAREABILITY_MASK))
+			gic_flush_dcache_to_poc(table + idx, GITS_LVL1_ENTRY_SIZE);
+
+		/* Ensure updated table contents are visible to ITS hardware */
+		dsb(sy);
+	}
+
+	return true;
+}
+
+static bool its_alloc_device_table(struct its_node *its, u32 dev_id)
+{
+	struct its_baser *baser;
+
+	baser = its_get_baser(its, GITS_BASER_TYPE_DEVICE);
+
+	/* Don't allow device id that exceeds ITS hardware limit */
+	if (!baser)
+		return (ilog2(dev_id) < its->device_ids);
+
+	return its_alloc_table_entry(baser, dev_id);
+}
+
+static bool its_alloc_vpe_table(u32 vpe_id)
+{
+	struct its_node *its;
+
+	/*
+	 * Make sure the L2 tables are allocated on *all* v4 ITSs. We
+	 * could try and only do it on ITSs corresponding to devices
+	 * that have interrupts targeted at this VPE, but the
+	 * complexity becomes crazy (and you have tons of memory
+	 * anyway, right?).
+	 */
+	list_for_each_entry(its, &its_nodes, entry) {
+		struct its_baser *baser;
+
+		if (!its->is_v4)
+			continue;
+
+		baser = its_get_baser(its, GITS_BASER_TYPE_VCPU);
+		if (!baser)
+			return false;
+
+		if (!its_alloc_table_entry(baser, vpe_id))
+			return false;
+	}
+
+	return true;
+}
+
+static struct its_device *its_create_device(struct its_node *its, u32 dev_id,
+					    int nvecs, bool alloc_lpis)
+{
+	struct its_device *dev;
+	unsigned long *lpi_map = NULL;
+	unsigned long flags;
+	u16 *col_map = NULL;
+	void *itt;
+	int lpi_base;
+	int nr_lpis;
+	int nr_ites;
+	int sz;
+
+	if (!its_alloc_device_table(its, dev_id))
+		return NULL;
+
+	if (WARN_ON(!is_power_of_2(nvecs)))
+		nvecs = roundup_pow_of_two(nvecs);
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	/*
+	 * Even if the device wants a single LPI, the ITT must be
+	 * sized as a power of two (and you need at least one bit...).
+	 */
+	nr_ites = max(2, nvecs);
+	sz = nr_ites * its->ite_size;
+	sz = max(sz, ITS_ITT_ALIGN) + ITS_ITT_ALIGN - 1;
+	itt = kzalloc(sz, GFP_KERNEL);
+	if (alloc_lpis) {
+		lpi_map = its_lpi_alloc(nvecs, &lpi_base, &nr_lpis);
+		if (lpi_map)
+			col_map = kcalloc(nr_lpis, sizeof(*col_map),
+					  GFP_KERNEL);
+	} else {
+		col_map = kcalloc(nr_ites, sizeof(*col_map), GFP_KERNEL);
+		nr_lpis = 0;
+		lpi_base = 0;
+	}
+
+	if (!dev || !itt ||  !col_map || (!lpi_map && alloc_lpis)) {
+		kfree(dev);
+		kfree(itt);
+		kfree(lpi_map);
+		kfree(col_map);
+		return NULL;
+	}
+
+	gic_flush_dcache_to_poc(itt, sz);
+
+	dev->its = its;
+	dev->itt = itt;
+	dev->nr_ites = nr_ites;
+	dev->event_map.lpi_map = lpi_map;
+	dev->event_map.col_map = col_map;
+	dev->event_map.lpi_base = lpi_base;
+	dev->event_map.nr_lpis = nr_lpis;
+	mutex_init(&dev->event_map.vlpi_lock);
+	dev->device_id = dev_id;
+	INIT_LIST_HEAD(&dev->entry);
+
+	raw_spin_lock_irqsave(&its->lock, flags);
+	list_add(&dev->entry, &its->its_device_list);
+	raw_spin_unlock_irqrestore(&its->lock, flags);
+
+	/* Map device to its ITT */
+	its_send_mapd(dev, 1);
+
+	return dev;
+}
+
+static void its_free_device(struct its_device *its_dev)
+{
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&its_dev->its->lock, flags);
+	list_del(&its_dev->entry);
+	raw_spin_unlock_irqrestore(&its_dev->its->lock, flags);
+	kfree(its_dev->itt);
+	kfree(its_dev);
+}
+
+static int its_alloc_device_irq(struct its_device *dev, irq_hw_number_t *hwirq)
+{
+	int idx;
+
+	idx = find_first_zero_bit(dev->event_map.lpi_map,
+				  dev->event_map.nr_lpis);
+	if (idx == dev->event_map.nr_lpis)
+		return -ENOSPC;
+
+	*hwirq = dev->event_map.lpi_base + idx;
+	set_bit(idx, dev->event_map.lpi_map);
+
+	return 0;
+}
+
+static int its_msi_prepare(struct irq_domain *domain, struct device *dev,
+			   int nvec, msi_alloc_info_t *info)
+{
+	struct its_node *its;
+	struct its_device *its_dev;
+	struct msi_domain_info *msi_info;
+	u32 dev_id;
+
+	/*
+	 * We ignore "dev" entierely, and rely on the dev_id that has
+	 * been passed via the scratchpad. This limits this domain's
+	 * usefulness to upper layers that definitely know that they
+	 * are built on top of the ITS.
+	 */
+	dev_id = info->scratchpad[0].ul;
+
+	msi_info = msi_get_domain_info(domain);
+	its = msi_info->data;
+
+	if (!gic_rdists->has_direct_lpi &&
+	    vpe_proxy.dev &&
+	    vpe_proxy.dev->its == its &&
+	    dev_id == vpe_proxy.dev->device_id) {
+		/* Bad luck. Get yourself a better implementation */
+		WARN_ONCE(1, "DevId %x clashes with GICv4 VPE proxy device\n",
+			  dev_id);
+		return -EINVAL;
+	}
+
+	its_dev = its_find_device(its, dev_id);
+	if (its_dev) {
+		/*
+		 * We already have seen this ID, probably through
+		 * another alias (PCI bridge of some sort). No need to
+		 * create the device.
+		 */
+		pr_debug("Reusing ITT for devID %x\n", dev_id);
+		goto out;
+	}
+
+	its_dev = its_create_device(its, dev_id, nvec, true);
+	if (!its_dev)
+		return -ENOMEM;
+
+	pr_debug("ITT %d entries, %d bits\n", nvec, ilog2(nvec));
+out:
+	info->scratchpad[0].ptr = its_dev;
+	return 0;
+}
+
+static struct msi_domain_ops its_msi_domain_ops = {
+	.msi_prepare	= its_msi_prepare,
+};
+
+static int its_irq_gic_domain_alloc(struct irq_domain *domain,
+				    unsigned int virq,
+				    irq_hw_number_t hwirq)
+{
+	struct irq_fwspec fwspec;
+
+	if (irq_domain_get_of_node(domain->parent)) {
+		fwspec.fwnode = domain->parent->fwnode;
+		fwspec.param_count = 3;
+		fwspec.param[0] = GIC_IRQ_TYPE_LPI;
+		fwspec.param[1] = hwirq;
+		fwspec.param[2] = IRQ_TYPE_EDGE_RISING;
+	} else if (is_fwnode_irqchip(domain->parent->fwnode)) {
+		fwspec.fwnode = domain->parent->fwnode;
+		fwspec.param_count = 2;
+		fwspec.param[0] = hwirq;
+		fwspec.param[1] = IRQ_TYPE_EDGE_RISING;
+	} else {
+		return -EINVAL;
+	}
+
+	return irq_domain_alloc_irqs_parent(domain, virq, 1, &fwspec);
+}
+
+static int its_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,
+				unsigned int nr_irqs, void *args)
+{
+	msi_alloc_info_t *info = args;
+	struct its_device *its_dev = info->scratchpad[0].ptr;
+	irq_hw_number_t hwirq;
+	int err;
+	int i;
+
+	for (i = 0; i < nr_irqs; i++) {
+		err = its_alloc_device_irq(its_dev, &hwirq);
+		if (err)
+			return err;
+
+		err = its_irq_gic_domain_alloc(domain, virq + i, hwirq);
+		if (err)
+			return err;
+
+		irq_domain_set_hwirq_and_chip(domain, virq + i,
+					      hwirq, &its_irq_chip, its_dev);
+		irqd_set_single_target(irq_desc_get_irq_data(irq_to_desc(virq + i)));
+		pr_debug("ID:%d pID:%d vID:%d\n",
+			 (int)(hwirq - its_dev->event_map.lpi_base),
+			 (int) hwirq, virq + i);
+	}
+
+	return 0;
+}
+
+static int its_cpumask_first(struct its_device *its_dev,
+			     const struct cpumask *cpu_mask)
+{
+	unsigned int skt, skt_id, i;
+	phys_addr_t its_phys_base;
+	unsigned int cpu, cpus = 0;
+	unsigned int skt_cpu_cnt[MAX_MARS3_SKT_COUNT] = {0};
+
+	its_phys_base = its_dev->its->phys_base;
+	skt_id = (its_phys_base >> 41) & 0x7;
+
+	for (i = 0; i < nr_cpu_ids; i++) {
+		skt = (cpu_logical_map(i) >> 16) & 0xff;
+		if ((skt >= 0) && (skt < MAX_MARS3_SKT_COUNT)) {
+			if ((is_kdump_kernel()) && (skt_id == skt)) {
+				return i;
+			}
+
+			skt_cpu_cnt[skt]++;
+		}
+		else if (0xff != skt )
+			pr_err("socket address: %d is out of range.", skt);
+	}
+
+	if (0 != skt_id) {
+		for (i = 0; i < skt_id; i++)
+			cpus += skt_cpu_cnt[i];
+	}
+
+	cpu = cpumask_first(cpu_mask);
+	if ((cpu > cpus) && (cpu < (cpus + skt_cpu_cnt[skt_id])))
+		cpus = cpu;
+
+	return cpus;
+}
+
+static int its_irq_domain_activate(struct irq_domain *domain,
+				   struct irq_data *d, bool reserve)
+{
+	struct its_device *its_dev = irq_data_get_irq_chip_data(d);
+	u32 event = its_get_event_id(d);
+	const struct cpumask *cpu_mask = cpu_online_mask;
+	int cpu;
+
+	/* get the cpu_mask of local node */
+	if (its_dev->its->numa_node >= 0)
+		cpu_mask = cpumask_of_node(its_dev->its->numa_node);
+
+	/* Bind the LPI to the first possible CPU */
+	cpu = its_cpumask_first(its_dev, cpu_mask);
+	printk("its_irq_domain_activate: MAPTI irq %d hwirq %ld on cpu %d\n",
+	       d->irq, d->hwirq, cpu);
+
+	its_inc_lpi_count(d, cpu);
+	its_dev->event_map.col_map[event] = cpu;
+	irq_data_update_effective_affinity(d, cpumask_of(cpu));
+
+	/* Map the GIC IRQ and event to the device */
+	its_send_mapti(its_dev, d->hwirq, event);
+	return 0;
+}
+
+static void its_irq_domain_deactivate(struct irq_domain *domain,
+				      struct irq_data *d)
+{
+	struct its_device *its_dev = irq_data_get_irq_chip_data(d);
+	u32 event = its_get_event_id(d);
+
+	its_dec_lpi_count(d, its_dev->event_map.col_map[event]);
+	/* Stop the delivery of interrupts */
+	its_send_discard(its_dev, event);
+}
+
+static void its_irq_domain_free(struct irq_domain *domain, unsigned int virq,
+				unsigned int nr_irqs)
+{
+	struct irq_data *d = irq_domain_get_irq_data(domain, virq);
+	struct its_device *its_dev = irq_data_get_irq_chip_data(d);
+	int i;
+
+	for (i = 0; i < nr_irqs; i++) {
+		struct irq_data *data = irq_domain_get_irq_data(domain,
+								virq + i);
+		u32 event = its_get_event_id(data);
+
+		/* Mark interrupt index as unused */
+		clear_bit(event, its_dev->event_map.lpi_map);
+
+		/* Nuke the entry in the domain */
+		irq_domain_reset_irq_data(data);
+	}
+
+	/* If all interrupts have been freed, start mopping the floor */
+	if (bitmap_empty(its_dev->event_map.lpi_map,
+			 its_dev->event_map.nr_lpis)) {
+		its_lpi_free(its_dev->event_map.lpi_map,
+			     its_dev->event_map.lpi_base,
+			     its_dev->event_map.nr_lpis);
+		kfree(its_dev->event_map.col_map);
+
+		/* Unmap device/itt */
+		its_send_mapd(its_dev, 0);
+		its_free_device(its_dev);
+	}
+
+	irq_domain_free_irqs_parent(domain, virq, nr_irqs);
+}
+
+static const struct irq_domain_ops its_domain_ops = {
+	.alloc			= its_irq_domain_alloc,
+	.free			= its_irq_domain_free,
+	.activate		= its_irq_domain_activate,
+	.deactivate		= its_irq_domain_deactivate,
+};
+
+/*
+ * This is insane.
+ *
+ * If a GICv4 doesn't implement Direct LPIs (which is extremely
+ * likely), the only way to perform an invalidate is to use a fake
+ * device to issue an INV command, implying that the LPI has first
+ * been mapped to some event on that device. Since this is not exactly
+ * cheap, we try to keep that mapping around as long as possible, and
+ * only issue an UNMAP if we're short on available slots.
+ *
+ * Broken by design(tm).
+ */
+static void its_vpe_db_proxy_unmap_locked(struct its_vpe *vpe)
+{
+	/* Already unmapped? */
+	if (vpe->vpe_proxy_event == -1)
+		return;
+
+	its_send_discard(vpe_proxy.dev, vpe->vpe_proxy_event);
+	vpe_proxy.vpes[vpe->vpe_proxy_event] = NULL;
+
+	/*
+	 * We don't track empty slots at all, so let's move the
+	 * next_victim pointer if we can quickly reuse that slot
+	 * instead of nuking an existing entry. Not clear that this is
+	 * always a win though, and this might just generate a ripple
+	 * effect... Let's just hope VPEs don't migrate too often.
+	 */
+	if (vpe_proxy.vpes[vpe_proxy.next_victim])
+		vpe_proxy.next_victim = vpe->vpe_proxy_event;
+
+	vpe->vpe_proxy_event = -1;
+}
+
+static void its_vpe_db_proxy_unmap(struct its_vpe *vpe)
+{
+	if (!gic_rdists->has_direct_lpi) {
+		unsigned long flags;
+
+		raw_spin_lock_irqsave(&vpe_proxy.lock, flags);
+		its_vpe_db_proxy_unmap_locked(vpe);
+		raw_spin_unlock_irqrestore(&vpe_proxy.lock, flags);
+	}
+}
+
+static void its_vpe_db_proxy_map_locked(struct its_vpe *vpe)
+{
+	/* Already mapped? */
+	if (vpe->vpe_proxy_event != -1)
+		return;
+
+	/* This slot was already allocated. Kick the other VPE out. */
+	if (vpe_proxy.vpes[vpe_proxy.next_victim])
+		its_vpe_db_proxy_unmap_locked(vpe_proxy.vpes[vpe_proxy.next_victim]);
+
+	/* Map the new VPE instead */
+	vpe_proxy.vpes[vpe_proxy.next_victim] = vpe;
+	vpe->vpe_proxy_event = vpe_proxy.next_victim;
+	vpe_proxy.next_victim = (vpe_proxy.next_victim + 1) % vpe_proxy.dev->nr_ites;
+
+	vpe_proxy.dev->event_map.col_map[vpe->vpe_proxy_event] = vpe->col_idx;
+	its_send_mapti(vpe_proxy.dev, vpe->vpe_db_lpi, vpe->vpe_proxy_event);
+}
+
+static void its_vpe_db_proxy_move(struct its_vpe *vpe, int from, int to)
+{
+	unsigned long flags;
+	struct its_collection *target_col;
+
+	if (gic_rdists->has_direct_lpi) {
+		void __iomem *rdbase;
+
+		rdbase = per_cpu_ptr(gic_rdists->rdist, from)->rd_base;
+		gic_write_lpir(vpe->vpe_db_lpi, rdbase + GICR_CLRLPIR);
+		while (gic_read_lpir(rdbase + GICR_SYNCR) & 1)
+			cpu_relax();
+
+		return;
+	}
+
+	raw_spin_lock_irqsave(&vpe_proxy.lock, flags);
+
+	its_vpe_db_proxy_map_locked(vpe);
+
+	target_col = &vpe_proxy.dev->its->collections[to];
+	its_send_movi(vpe_proxy.dev, target_col, vpe->vpe_proxy_event);
+	vpe_proxy.dev->event_map.col_map[vpe->vpe_proxy_event] = to;
+
+	raw_spin_unlock_irqrestore(&vpe_proxy.lock, flags);
+}
+
+static int its_vpe_set_affinity(struct irq_data *d,
+				const struct cpumask *mask_val,
+				bool force)
+{
+	struct its_vpe *vpe = irq_data_get_irq_chip_data(d);
+	int cpu = cpumask_first(mask_val);
+
+	/*
+	 * Changing affinity is mega expensive, so let's be as lazy as
+	 * we can and only do it if we really have to. Also, if mapped
+	 * into the proxy device, we need to move the doorbell
+	 * interrupt to its new location.
+	 */
+	if (vpe->col_idx != cpu) {
+		int from = vpe->col_idx;
+
+		vpe->col_idx = cpu;
+		its_send_vmovp(vpe);
+		its_vpe_db_proxy_move(vpe, from, cpu);
+	}
+
+	irq_data_update_effective_affinity(d, cpumask_of(cpu));
+
+	return IRQ_SET_MASK_OK_DONE;
+}
+
+static void its_vpe_schedule(struct its_vpe *vpe)
+{
+	void __iomem *vlpi_base = gic_data_rdist_vlpi_base();
+	u64 val;
+
+	/* Schedule the VPE */
+	val  = virt_to_phys(page_address(vpe->its_vm->vprop_page)) &
+		GENMASK_ULL(51, 12);
+	val |= (LPI_NRBITS - 1) & GICR_VPROPBASER_IDBITS_MASK;
+	val |= GICR_VPROPBASER_RaWb;
+	val |= GICR_VPROPBASER_InnerShareable;
+	gicr_write_vpropbaser(val, vlpi_base + GICR_VPROPBASER);
+
+	val  = virt_to_phys(page_address(vpe->vpt_page)) &
+		GENMASK_ULL(51, 16);
+	val |= GICR_VPENDBASER_RaWaWb;
+	val |= GICR_VPENDBASER_NonShareable;
+	/*
+	 * There is no good way of finding out if the pending table is
+	 * empty as we can race against the doorbell interrupt very
+	 * easily. So in the end, vpe->pending_last is only an
+	 * indication that the vcpu has something pending, not one
+	 * that the pending table is empty. A good implementation
+	 * would be able to read its coarse map pretty quickly anyway,
+	 * making this a tolerable issue.
+	 */
+	val |= GICR_VPENDBASER_PendingLast;
+	val |= vpe->idai ? GICR_VPENDBASER_IDAI : 0;
+	val |= GICR_VPENDBASER_Valid;
+	gicr_write_vpropbaser(val, vlpi_base + GICR_VPENDBASER);
+}
+
+static void its_vpe_deschedule(struct its_vpe *vpe)
+{
+	void __iomem *vlpi_base = gic_data_rdist_vlpi_base();
+	u32 count = 1000000;	/* 1s! */
+	bool clean;
+	u64 val;
+
+	/* We're being scheduled out */
+//	val = gits_read_vpendbaser(vlpi_base + GICR_VPENDBASER);
+	val = gicr_read_vpendbaser(vlpi_base + GICR_VPENDBASER);
+	val &= ~GICR_VPENDBASER_Valid;
+//	gits_write_vpendbaser(val, vlpi_base + GICR_VPENDBASER);
+	gicr_write_vpendbaser(val, vlpi_base + GICR_VPENDBASER);
+
+	do {
+//		val = gits_read_vpendbaser(vlpi_base + GICR_VPENDBASER);
+		 val = gicr_read_vpendbaser(vlpi_base + GICR_VPENDBASER);
+		clean = !(val & GICR_VPENDBASER_Dirty);
+		if (!clean) {
+			count--;
+			cpu_relax();
+			udelay(1);
+		}
+	} while (!clean && count);
+
+	if (unlikely(!clean && !count)) {
+		pr_err_ratelimited("ITS virtual pending table not cleaning\n");
+		vpe->idai = false;
+		vpe->pending_last = true;
+	} else {
+		vpe->idai = !!(val & GICR_VPENDBASER_IDAI);
+		vpe->pending_last = !!(val & GICR_VPENDBASER_PendingLast);
+	}
+}
+
+static void its_vpe_invall(struct its_vpe *vpe)
+{
+	struct its_node *its;
+
+	list_for_each_entry(its, &its_nodes, entry) {
+		if (!its->is_v4)
+			continue;
+
+		if (its_list_map && !vpe->its_vm->vlpi_count[its->list_nr])
+			continue;
+
+		/*
+		 * Sending a VINVALL to a single ITS is enough, as all
+		 * we need is to reach the redistributors.
+		 */
+		its_send_vinvall(its, vpe);
+		return;
+	}
+}
+
+static int its_vpe_set_vcpu_affinity(struct irq_data *d, void *vcpu_info)
+{
+	struct its_vpe *vpe = irq_data_get_irq_chip_data(d);
+	struct its_cmd_info *info = vcpu_info;
+
+	switch (info->cmd_type) {
+	case SCHEDULE_VPE:
+		its_vpe_schedule(vpe);
+		return 0;
+
+	case DESCHEDULE_VPE:
+		its_vpe_deschedule(vpe);
+		return 0;
+
+	case INVALL_VPE:
+		its_vpe_invall(vpe);
+		return 0;
+
+	default:
+		return -EINVAL;
+	}
+}
+
+static void its_vpe_send_cmd(struct its_vpe *vpe,
+			     void (*cmd)(struct its_device *, u32))
+{
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&vpe_proxy.lock, flags);
+
+	its_vpe_db_proxy_map_locked(vpe);
+	cmd(vpe_proxy.dev, vpe->vpe_proxy_event);
+
+	raw_spin_unlock_irqrestore(&vpe_proxy.lock, flags);
+}
+
+static void its_vpe_send_inv(struct irq_data *d)
+{
+	struct its_vpe *vpe = irq_data_get_irq_chip_data(d);
+
+	if (gic_rdists->has_direct_lpi) {
+		void __iomem *rdbase;
+
+		rdbase = per_cpu_ptr(gic_rdists->rdist, vpe->col_idx)->rd_base;
+		gic_write_lpir(vpe->vpe_db_lpi, rdbase + GICR_INVLPIR);
+		while (gic_read_lpir(rdbase + GICR_SYNCR) & 1)
+			cpu_relax();
+	} else {
+		its_vpe_send_cmd(vpe, its_send_inv);
+	}
+}
+
+static void its_vpe_mask_irq(struct irq_data *d)
+{
+	/*
+	 * We need to unmask the LPI, which is described by the parent
+	 * irq_data. Instead of calling into the parent (which won't
+	 * exactly do the right thing, let's simply use the
+	 * parent_data pointer. Yes, I'm naughty.
+	 */
+	lpi_write_config(d->parent_data, LPI_PROP_ENABLED, 0);
+	its_vpe_send_inv(d);
+}
+
+static void its_vpe_unmask_irq(struct irq_data *d)
+{
+	/* Same hack as above... */
+	lpi_write_config(d->parent_data, 0, LPI_PROP_ENABLED);
+	its_vpe_send_inv(d);
+}
+
+static int its_vpe_set_irqchip_state(struct irq_data *d,
+				     enum irqchip_irq_state which,
+				     bool state)
+{
+	struct its_vpe *vpe = irq_data_get_irq_chip_data(d);
+
+	if (which != IRQCHIP_STATE_PENDING)
+		return -EINVAL;
+
+	if (gic_rdists->has_direct_lpi) {
+		void __iomem *rdbase;
+
+		rdbase = per_cpu_ptr(gic_rdists->rdist, vpe->col_idx)->rd_base;
+		if (state) {
+			gic_write_lpir(vpe->vpe_db_lpi, rdbase + GICR_SETLPIR);
+		} else {
+			gic_write_lpir(vpe->vpe_db_lpi, rdbase + GICR_CLRLPIR);
+			while (gic_read_lpir(rdbase + GICR_SYNCR) & 1)
+				cpu_relax();
+		}
+	} else {
+		if (state)
+			its_vpe_send_cmd(vpe, its_send_int);
+		else
+			its_vpe_send_cmd(vpe, its_send_clear);
+	}
+
+	return 0;
+}
+
+static struct irq_chip its_vpe_irq_chip = {
+	.name			= "GICv4-vpe",
+	.irq_mask		= its_vpe_mask_irq,
+	.irq_unmask		= its_vpe_unmask_irq,
+	.irq_eoi		= irq_chip_eoi_parent,
+	.irq_set_affinity	= its_vpe_set_affinity,
+	.irq_set_irqchip_state	= its_vpe_set_irqchip_state,
+	.irq_set_vcpu_affinity	= its_vpe_set_vcpu_affinity,
+};
+
+static int its_vpe_id_alloc(void)
+{
+	return ida_simple_get(&its_vpeid_ida, 0, ITS_MAX_VPEID, GFP_KERNEL);
+}
+
+static void its_vpe_id_free(u16 id)
+{
+	ida_simple_remove(&its_vpeid_ida, id);
+}
+
+static int its_vpe_init(struct its_vpe *vpe)
+{
+	struct page *vpt_page;
+	int vpe_id;
+
+	/* Allocate vpe_id */
+	vpe_id = its_vpe_id_alloc();
+	if (vpe_id < 0)
+		return vpe_id;
+
+	/* Allocate VPT */
+	vpt_page = its_allocate_pending_table(GFP_KERNEL);
+	if (!vpt_page) {
+		its_vpe_id_free(vpe_id);
+		return -ENOMEM;
+	}
+
+	if (!its_alloc_vpe_table(vpe_id)) {
+		its_vpe_id_free(vpe_id);
+		its_free_pending_table(vpe->vpt_page);
+		return -ENOMEM;
+	}
+
+	vpe->vpe_id = vpe_id;
+	vpe->vpt_page = vpt_page;
+	vpe->vpe_proxy_event = -1;
+
+	return 0;
+}
+
+static void its_vpe_teardown(struct its_vpe *vpe)
+{
+	its_vpe_db_proxy_unmap(vpe);
+	its_vpe_id_free(vpe->vpe_id);
+	its_free_pending_table(vpe->vpt_page);
+}
+
+static void its_vpe_irq_domain_free(struct irq_domain *domain,
+				    unsigned int virq,
+				    unsigned int nr_irqs)
+{
+	struct its_vm *vm = domain->host_data;
+	int i;
+
+	irq_domain_free_irqs_parent(domain, virq, nr_irqs);
+
+	for (i = 0; i < nr_irqs; i++) {
+		struct irq_data *data = irq_domain_get_irq_data(domain,
+								virq + i);
+		struct its_vpe *vpe = irq_data_get_irq_chip_data(data);
+
+		BUG_ON(vm != vpe->its_vm);
+
+		clear_bit(data->hwirq, vm->db_bitmap);
+		its_vpe_teardown(vpe);
+		irq_domain_reset_irq_data(data);
+	}
+
+	if (bitmap_empty(vm->db_bitmap, vm->nr_db_lpis)) {
+		its_lpi_free(vm->db_bitmap, vm->db_lpi_base, vm->nr_db_lpis);
+		its_free_prop_table(vm->vprop_page);
+	}
+}
+
+static int its_vpe_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,
+				    unsigned int nr_irqs, void *args)
+{
+	struct its_vm *vm = args;
+	unsigned long *bitmap;
+	struct page *vprop_page;
+	int base, nr_ids, i, err = 0;
+
+	BUG_ON(!vm);
+
+	bitmap = its_lpi_alloc(roundup_pow_of_two(nr_irqs), &base, &nr_ids);
+	if (!bitmap)
+		return -ENOMEM;
+
+	if (nr_ids < nr_irqs) {
+		its_lpi_free(bitmap, base, nr_ids);
+		return -ENOMEM;
+	}
+
+	vprop_page = its_allocate_prop_table(GFP_KERNEL);
+	if (!vprop_page) {
+		its_lpi_free(bitmap, base, nr_ids);
+		return -ENOMEM;
+	}
+
+	vm->db_bitmap = bitmap;
+	vm->db_lpi_base = base;
+	vm->nr_db_lpis = nr_ids;
+	vm->vprop_page = vprop_page;
+
+	for (i = 0; i < nr_irqs; i++) {
+		vm->vpes[i]->vpe_db_lpi = base + i;
+		err = its_vpe_init(vm->vpes[i]);
+		if (err)
+			break;
+		err = its_irq_gic_domain_alloc(domain, virq + i,
+					       vm->vpes[i]->vpe_db_lpi);
+		if (err)
+			break;
+		irq_domain_set_hwirq_and_chip(domain, virq + i, i,
+					      &its_vpe_irq_chip, vm->vpes[i]);
+		set_bit(i, bitmap);
+	}
+
+	if (err) {
+		if (i > 0)
+			its_vpe_irq_domain_free(domain, virq, i - 1);
+
+		its_lpi_free(bitmap, base, nr_ids);
+		its_free_prop_table(vprop_page);
+	}
+
+	return err;
+}
+
+static int its_vpe_irq_domain_activate(struct irq_domain *domain,
+				       struct irq_data *d, bool reserve)
+{
+	struct its_vpe *vpe = irq_data_get_irq_chip_data(d);
+	struct its_node *its;
+
+	/* If we use the list map, we issue VMAPP on demand... */
+	if (its_list_map)
+		return 0;
+
+	/* Map the VPE to the first possible CPU */
+	vpe->col_idx = cpumask_first(cpu_online_mask);
+
+	list_for_each_entry(its, &its_nodes, entry) {
+		if (!its->is_v4)
+			continue;
+
+		its_send_vmapp(its, vpe, true);
+		its_send_vinvall(its, vpe);
+	}
+
+	irq_data_update_effective_affinity(d, cpumask_of(vpe->col_idx));
+
+	return 0;
+}
+
+static void its_vpe_irq_domain_deactivate(struct irq_domain *domain,
+					  struct irq_data *d)
+{
+	struct its_vpe *vpe = irq_data_get_irq_chip_data(d);
+	struct its_node *its;
+
+	/*
+	 * If we use the list map, we unmap the VPE once no VLPIs are
+	 * associated with the VM.
+	 */
+	if (its_list_map)
+		return;
+
+	list_for_each_entry(its, &its_nodes, entry) {
+		if (!its->is_v4)
+			continue;
+
+		its_send_vmapp(its, vpe, false);
+	}
+}
+
+static const struct irq_domain_ops its_vpe_domain_ops = {
+	.alloc			= its_vpe_irq_domain_alloc,
+	.free			= its_vpe_irq_domain_free,
+	.activate		= its_vpe_irq_domain_activate,
+	.deactivate		= its_vpe_irq_domain_deactivate,
+};
+
+static int its_force_quiescent(void __iomem *base)
+{
+	u32 count = 1000000;	/* 1s */
+	u32 val;
+
+	val = readl_relaxed(base + GITS_CTLR);
+	/*
+	 * GIC architecture specification requires the ITS to be both
+	 * disabled and quiescent for writes to GITS_BASER<n> or
+	 * GITS_CBASER to not have UNPREDICTABLE results.
+	 */
+	if ((val & GITS_CTLR_QUIESCENT) && !(val & GITS_CTLR_ENABLE))
+		return 0;
+
+	/* Disable the generation of all interrupts to this ITS */
+	val &= ~(GITS_CTLR_ENABLE | GITS_CTLR_ImDe);
+	writel_relaxed(val, base + GITS_CTLR);
+
+	/* Poll GITS_CTLR and wait until ITS becomes quiescent */
+	while (1) {
+		val = readl_relaxed(base + GITS_CTLR);
+		if (val & GITS_CTLR_QUIESCENT)
+			return 0;
+
+		count--;
+		if (!count)
+			return -EBUSY;
+
+		cpu_relax();
+		udelay(1);
+	}
+}
+
+static bool __maybe_unused its_enable_quirk_cavium_22375(void *data)
+{
+	struct its_node *its = data;
+
+	/* erratum 22375: only alloc 8MB table size */
+	its->device_ids = 0x14;		/* 20 bits, 8MB */
+	its->flags |= ITS_FLAGS_WORKAROUND_CAVIUM_22375;
+
+	return true;
+}
+
+static bool __maybe_unused its_enable_quirk_cavium_23144(void *data)
+{
+	struct its_node *its = data;
+
+	its->flags |= ITS_FLAGS_WORKAROUND_CAVIUM_23144;
+
+	return true;
+}
+
+static bool __maybe_unused its_enable_quirk_qdf2400_e0065(void *data)
+{
+	struct its_node *its = data;
+
+	/* On QDF2400, the size of the ITE is 16Bytes */
+	its->ite_size = 16;
+
+	return true;
+}
+
+static u64 its_irq_get_msi_base_pre_its(struct its_device *its_dev)
+{
+	struct its_node *its = its_dev->its;
+
+	/*
+	 * The Socionext Synquacer SoC has a so-called 'pre-ITS',
+	 * which maps 32-bit writes targeted at a separate window of
+	 * size '4 << device_id_bits' onto writes to GITS_TRANSLATER
+	 * with device ID taken from bits [device_id_bits + 1:2] of
+	 * the window offset.
+	 */
+	return its->pre_its_base + (its_dev->device_id << 2);
+}
+
+static bool __maybe_unused its_enable_quirk_socionext_synquacer(void *data)
+{
+	struct its_node *its = data;
+	u32 pre_its_window[2];
+	u32 ids;
+
+	if (!fwnode_property_read_u32_array(its->fwnode_handle,
+					   "socionext,synquacer-pre-its",
+					   pre_its_window,
+					   ARRAY_SIZE(pre_its_window))) {
+
+		its->pre_its_base = pre_its_window[0];
+		its->get_msi_base = its_irq_get_msi_base_pre_its;
+
+		ids = ilog2(pre_its_window[1]) - 2;
+		if (its->device_ids > ids)
+			its->device_ids = ids;
+
+		/* the pre-ITS breaks isolation, so disable MSI remapping */
+		its->msi_domain_flags &= ~IRQ_DOMAIN_FLAG_MSI_REMAP;
+		return true;
+	}
+	return false;
+}
+
+static bool __maybe_unused its_enable_quirk_hip07_161600802(void *data)
+{
+	struct its_node *its = data;
+
+	/*
+	 * Hip07 insists on using the wrong address for the VLPI
+	 * page. Trick it into doing the right thing...
+	 */
+	its->vlpi_redist_offset = SZ_128K;
+	return true;
+}
+
+static const struct gic_quirk its_quirks[] = {
+#ifdef CONFIG_CAVIUM_ERRATUM_22375
+	{
+		.desc	= "ITS: Cavium errata 22375, 24313",
+		.iidr	= 0xa100034c,	/* ThunderX pass 1.x */
+		.mask	= 0xffff0fff,
+		.init	= its_enable_quirk_cavium_22375,
+	},
+#endif
+#ifdef CONFIG_CAVIUM_ERRATUM_23144
+	{
+		.desc	= "ITS: Cavium erratum 23144",
+		.iidr	= 0xa100034c,	/* ThunderX pass 1.x */
+		.mask	= 0xffff0fff,
+		.init	= its_enable_quirk_cavium_23144,
+	},
+#endif
+#ifdef CONFIG_QCOM_QDF2400_ERRATUM_0065
+	{
+		.desc	= "ITS: QDF2400 erratum 0065",
+		.iidr	= 0x00001070, /* QDF2400 ITS rev 1.x */
+		.mask	= 0xffffffff,
+		.init	= its_enable_quirk_qdf2400_e0065,
+	},
+#endif
+#ifdef CONFIG_SOCIONEXT_SYNQUACER_PREITS
+	{
+		/*
+		 * The Socionext Synquacer SoC incorporates ARM's own GIC-500
+		 * implementation, but with a 'pre-ITS' added that requires
+		 * special handling in software.
+		 */
+		.desc	= "ITS: Socionext Synquacer pre-ITS",
+		.iidr	= 0x0001143b,
+		.mask	= 0xffffffff,
+		.init	= its_enable_quirk_socionext_synquacer,
+	},
+#endif
+#ifdef CONFIG_HISILICON_ERRATUM_161600802
+	{
+		.desc	= "ITS: Hip07 erratum 161600802",
+		.iidr	= 0x00000004,
+		.mask	= 0xffffffff,
+		.init	= its_enable_quirk_hip07_161600802,
+	},
+#endif
+	{
+	}
+};
+
+static void its_enable_quirks(struct its_node *its)
+{
+	u32 iidr = readl_relaxed(its->base + GITS_IIDR);
+
+	gic_enable_quirks(iidr, its_quirks, its);
+}
+
+static int its_save_disable(void)
+{
+	struct its_node *its;
+	int err = 0;
+
+	raw_spin_lock(&its_lock);
+	list_for_each_entry(its, &its_nodes, entry) {
+		void __iomem *base;
+
+		if (!(its->flags & ITS_FLAGS_SAVE_SUSPEND_STATE))
+			continue;
+
+		base = its->base;
+		its->ctlr_save = readl_relaxed(base + GITS_CTLR);
+		err = its_force_quiescent(base);
+		if (err) {
+			pr_err("ITS@%pa: failed to quiesce: %d\n",
+			       &its->phys_base, err);
+			writel_relaxed(its->ctlr_save, base + GITS_CTLR);
+			goto err;
+		}
+
+		its->cbaser_save = gits_read_cbaser(base + GITS_CBASER);
+	}
+
+err:
+	if (err) {
+		list_for_each_entry_continue_reverse(its, &its_nodes, entry) {
+			void __iomem *base;
+
+			if (!(its->flags & ITS_FLAGS_SAVE_SUSPEND_STATE))
+				continue;
+
+			base = its->base;
+			writel_relaxed(its->ctlr_save, base + GITS_CTLR);
+		}
+	}
+	raw_spin_unlock(&its_lock);
+
+	return err;
+}
+
+static void its_restore_enable(void)
+{
+	struct its_node *its;
+	int ret;
+
+	raw_spin_lock(&its_lock);
+	list_for_each_entry(its, &its_nodes, entry) {
+		void __iomem *base;
+		int i;
+
+		if (!(its->flags & ITS_FLAGS_SAVE_SUSPEND_STATE))
+			continue;
+
+		base = its->base;
+
+		/*
+		 * Make sure that the ITS is disabled. If it fails to quiesce,
+		 * don't restore it since writing to CBASER or BASER<n>
+		 * registers is undefined according to the GIC v3 ITS
+		 * Specification.
+		 */
+		ret = its_force_quiescent(base);
+		if (ret) {
+			pr_err("ITS@%pa: failed to quiesce on resume: %d\n",
+			       &its->phys_base, ret);
+			continue;
+		}
+
+		gits_write_cbaser(its->cbaser_save, base + GITS_CBASER);
+
+		/*
+		 * Writing CBASER resets CREADR to 0, so make CWRITER and
+		 * cmd_write line up with it.
+		 */
+		its->cmd_write = its->cmd_base;
+		gits_write_cwriter(0, base + GITS_CWRITER);
+
+		/* Restore GITS_BASER from the value cache. */
+		for (i = 0; i < GITS_BASER_NR_REGS; i++) {
+			struct its_baser *baser = &its->tables[i];
+
+			if (!(baser->val & GITS_BASER_VALID))
+				continue;
+
+			its_write_baser(its, baser, baser->val);
+		}
+		writel_relaxed(its->ctlr_save, base + GITS_CTLR);
+
+		/*
+		 * Reinit the collection if it's stored in the ITS. This is
+		 * indicated by the col_id being less than the HCC field.
+		 * CID < HCC as specified in the GIC v3 Documentation.
+		 */
+		if (its->collections[smp_processor_id()].col_id <
+		    GITS_TYPER_HCC(gic_read_typer(base + GITS_TYPER)))
+			its_cpu_init_collection(its);
+	}
+	raw_spin_unlock(&its_lock);
+}
+
+static struct syscore_ops its_syscore_ops = {
+	.suspend = its_save_disable,
+	.resume = its_restore_enable,
+};
+
+static int its_init_domain(struct fwnode_handle *handle, struct its_node *its)
+{
+	struct irq_domain *inner_domain;
+	struct msi_domain_info *info;
+
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	inner_domain = irq_domain_create_tree(handle, &its_domain_ops, its);
+	if (!inner_domain) {
+		kfree(info);
+		return -ENOMEM;
+	}
+
+	inner_domain->parent = its_parent;
+	irq_domain_update_bus_token(inner_domain, DOMAIN_BUS_NEXUS);
+	inner_domain->flags |= its->msi_domain_flags;
+	info->ops = &its_msi_domain_ops;
+	info->data = its;
+	inner_domain->host_data = info;
+
+	return 0;
+}
+
+static int its_init_vpe_domain(void)
+{
+	struct its_node *its;
+	u32 devid;
+	int entries;
+
+	if (gic_rdists->has_direct_lpi) {
+		pr_info("ITS: Using DirectLPI for VPE invalidation\n");
+		return 0;
+	}
+
+	/* Any ITS will do, even if not v4 */
+	its = list_first_entry(&its_nodes, struct its_node, entry);
+
+	entries = roundup_pow_of_two(nr_cpu_ids);
+	vpe_proxy.vpes = kcalloc(entries, sizeof(*vpe_proxy.vpes),
+				 GFP_KERNEL);
+	if (!vpe_proxy.vpes) {
+		pr_err("ITS: Can't allocate GICv4 proxy device array\n");
+		return -ENOMEM;
+	}
+
+	/* Use the last possible DevID */
+	devid = GENMASK(its->device_ids - 1, 0);
+	vpe_proxy.dev = its_create_device(its, devid, entries, false);
+	if (!vpe_proxy.dev) {
+		kfree(vpe_proxy.vpes);
+		pr_err("ITS: Can't allocate GICv4 proxy device\n");
+		return -ENOMEM;
+	}
+
+	BUG_ON(entries > vpe_proxy.dev->nr_ites);
+
+	raw_spin_lock_init(&vpe_proxy.lock);
+	vpe_proxy.next_victim = 0;
+	pr_info("ITS: Allocated DevID %x as GICv4 proxy device (%d slots)\n",
+		devid, vpe_proxy.dev->nr_ites);
+
+	return 0;
+}
+
+static int __init its_compute_its_list_map(struct resource *res,
+					   void __iomem *its_base)
+{
+	int its_number;
+	u32 ctlr;
+
+	/*
+	 * This is assumed to be done early enough that we're
+	 * guaranteed to be single-threaded, hence no
+	 * locking. Should this change, we should address
+	 * this.
+	 */
+	its_number = find_first_zero_bit(&its_list_map, GICv4_ITS_LIST_MAX);
+	if (its_number >= GICv4_ITS_LIST_MAX) {
+		pr_err("ITS@%pa: No ITSList entry available!\n",
+		       &res->start);
+		return -EINVAL;
+	}
+
+	ctlr = readl_relaxed(its_base + GITS_CTLR);
+	ctlr &= ~GITS_CTLR_ITS_NUMBER;
+	ctlr |= its_number << GITS_CTLR_ITS_NUMBER_SHIFT;
+	writel_relaxed(ctlr, its_base + GITS_CTLR);
+	ctlr = readl_relaxed(its_base + GITS_CTLR);
+	if ((ctlr & GITS_CTLR_ITS_NUMBER) != (its_number << GITS_CTLR_ITS_NUMBER_SHIFT)) {
+		its_number = ctlr & GITS_CTLR_ITS_NUMBER;
+		its_number >>= GITS_CTLR_ITS_NUMBER_SHIFT;
+	}
+
+	if (test_and_set_bit(its_number, &its_list_map)) {
+		pr_err("ITS@%pa: Duplicate ITSList entry %d\n",
+		       &res->start, its_number);
+		return -EINVAL;
+	}
+
+	return its_number;
+}
+
+static int __init its_probe_one(struct resource *res,
+				struct fwnode_handle *handle, int numa_node)
+{
+	struct its_node *its;
+	void __iomem *its_base;
+	u32 val, ctlr;
+	u64 baser, tmp, typer;
+	int err;
+
+	its_base = ioremap(res->start, resource_size(res));
+	if (!its_base) {
+		pr_warn("ITS@%pa: Unable to map ITS registers\n", &res->start);
+		return -ENOMEM;
+	}
+
+	val = readl_relaxed(its_base + GITS_PIDR2) & GIC_PIDR2_ARCH_MASK;
+	if (val != 0x30 && val != 0x40) {
+		pr_warn("ITS@%pa: No ITS detected, giving up\n", &res->start);
+		err = -ENODEV;
+		goto out_unmap;
+	}
+
+	err = its_force_quiescent(its_base);
+	if (err) {
+		pr_warn("ITS@%pa: Failed to quiesce, giving up\n", &res->start);
+		goto out_unmap;
+	}
+
+	pr_info("ITS %pR\n", res);
+
+	its = kzalloc(sizeof(*its), GFP_KERNEL);
+	if (!its) {
+		err = -ENOMEM;
+		goto out_unmap;
+	}
+
+	raw_spin_lock_init(&its->lock);
+	INIT_LIST_HEAD(&its->entry);
+	INIT_LIST_HEAD(&its->its_device_list);
+	typer = gic_read_typer(its_base + GITS_TYPER);
+	its->base = its_base;
+	its->phys_base = res->start;
+	its->ite_size = GITS_TYPER_ITT_ENTRY_SIZE(typer);
+	its->device_ids = GITS_TYPER_DEVBITS(typer);
+	its->is_v4 = !!(typer & GITS_TYPER_VLPIS);
+	if (its->is_v4) {
+		if (!(typer & GITS_TYPER_VMOVP)) {
+			err = its_compute_its_list_map(res, its_base);
+			if (err < 0)
+				goto out_free_its;
+
+			its->list_nr = err;
+
+			pr_info("ITS@%pa: Using ITS number %d\n",
+				&res->start, err);
+		} else {
+			pr_info("ITS@%pa: Single VMOVP capable\n", &res->start);
+		}
+	}
+
+	its->numa_node = numa_node;
+
+	its->cmd_base = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,
+						get_order(ITS_CMD_QUEUE_SZ));
+	if (!its->cmd_base) {
+		err = -ENOMEM;
+		goto out_free_its;
+	}
+	its->cmd_write = its->cmd_base;
+	its->fwnode_handle = handle;
+	its->get_msi_base = its_irq_get_msi_base;
+	its->msi_domain_flags = IRQ_DOMAIN_FLAG_MSI_REMAP;
+
+	its_enable_quirks(its);
+
+	err = its_alloc_tables(its);
+	if (err)
+		goto out_free_cmd;
+
+	err = its_alloc_collections(its);
+	if (err)
+		goto out_free_tables;
+
+	baser = (virt_to_phys(its->cmd_base)	|
+		 GITS_CBASER_RaWaWb		|
+		 GITS_CBASER_InnerShareable	|
+		 (ITS_CMD_QUEUE_SZ / SZ_4K - 1)	|
+		 GITS_CBASER_VALID);
+
+	gits_write_cbaser(baser, its->base + GITS_CBASER);
+	tmp = gits_read_cbaser(its->base + GITS_CBASER);
+
+	if ((tmp ^ baser) & GITS_CBASER_SHAREABILITY_MASK) {
+		if (!(tmp & GITS_CBASER_SHAREABILITY_MASK)) {
+			/*
+			 * The HW reports non-shareable, we must
+			 * remove the cacheability attributes as
+			 * well.
+			 */
+			baser &= ~(GITS_CBASER_SHAREABILITY_MASK |
+				   GITS_CBASER_CACHEABILITY_MASK);
+			baser |= GITS_CBASER_nC;
+			gits_write_cbaser(baser, its->base + GITS_CBASER);
+		}
+		pr_info("ITS: using cache flushing for cmd queue\n");
+		its->flags |= ITS_FLAGS_CMDQ_NEEDS_FLUSHING;
+	}
+
+	gits_write_cwriter(0, its->base + GITS_CWRITER);
+	ctlr = readl_relaxed(its->base + GITS_CTLR);
+	ctlr |= GITS_CTLR_ENABLE;
+	if (its->is_v4)
+		ctlr |= GITS_CTLR_ImDe;
+	writel_relaxed(ctlr, its->base + GITS_CTLR);
+
+	if (GITS_TYPER_HCC(typer))
+		its->flags |= ITS_FLAGS_SAVE_SUSPEND_STATE;
+
+	err = its_init_domain(handle, its);
+	if (err)
+		goto out_free_tables;
+
+	raw_spin_lock(&its_lock);
+	list_add(&its->entry, &its_nodes);
+	raw_spin_unlock(&its_lock);
+
+	return 0;
+
+out_free_tables:
+	its_free_tables(its);
+out_free_cmd:
+	free_pages((unsigned long)its->cmd_base, get_order(ITS_CMD_QUEUE_SZ));
+out_free_its:
+	kfree(its);
+out_unmap:
+	iounmap(its_base);
+	pr_err("ITS@%pa: failed probing (%d)\n", &res->start, err);
+	return err;
+}
+
+static bool gic_rdists_supports_plpis(void)
+{
+	return !!(gic_read_typer(gic_data_rdist_rd_base() + GICR_TYPER) & GICR_TYPER_PLPIS);
+}
+
+static int redist_disable_lpis(void)
+{
+	void __iomem *rbase = gic_data_rdist_rd_base();
+	u64 timeout = USEC_PER_SEC;
+	u64 val;
+
+	if (!gic_rdists_supports_plpis()) {
+		pr_info("CPU%d: LPIs not supported\n", smp_processor_id());
+		return -ENXIO;
+	}
+
+	val = readl_relaxed(rbase + GICR_CTLR);
+	if (!(val & GICR_CTLR_ENABLE_LPIS))
+		return 0;
+
+	/*
+	 * If coming via a CPU hotplug event, we don't need to disable
+	 * LPIs before trying to re-enable them. They are already
+	 * configured and all is well in the world.
+	 *
+	 * If running with preallocated tables, there is nothing to do.
+	 */
+	if (gic_data_rdist()->lpi_enabled ||
+	    (gic_rdists->flags & RDIST_FLAGS_RD_TABLES_PREALLOCATED))
+		return 0;
+
+	/*
+	 * From that point on, we only try to do some damage control.
+	 */
+	pr_warn("GICv3: CPU%d: Booted with LPIs enabled, memory probably corrupted\n",
+		smp_processor_id());
+	add_taint(TAINT_CRAP, LOCKDEP_STILL_OK);
+
+	/* Disable LPIs */
+	val &= ~GICR_CTLR_ENABLE_LPIS;
+	writel_relaxed(val, rbase + GICR_CTLR);
+
+	/* Make sure any change to GICR_CTLR is observable by the GIC */
+	dsb(sy);
+
+	/*
+	 * Software must observe RWP==0 after clearing GICR_CTLR.EnableLPIs
+	 * from 1 to 0 before programming GICR_PEND{PROP}BASER registers.
+	 * Error out if we time out waiting for RWP to clear.
+	 */
+	while (readl_relaxed(rbase + GICR_CTLR) & GICR_CTLR_RWP) {
+		if (!timeout) {
+			pr_err("CPU%d: Timeout while disabling LPIs\n",
+			       smp_processor_id());
+			return -ETIMEDOUT;
+		}
+		udelay(1);
+		timeout--;
+	}
+
+	/*
+	 * After it has been written to 1, it is IMPLEMENTATION
+	 * DEFINED whether GICR_CTLR.EnableLPI becomes RES1 or can be
+	 * cleared to 0. Error out if clearing the bit failed.
+	 */
+	if (readl_relaxed(rbase + GICR_CTLR) & GICR_CTLR_ENABLE_LPIS) {
+		pr_err("CPU%d: Failed to disable LPIs\n", smp_processor_id());
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+int phytium_its_cpu_init(void)
+{
+	if (!list_empty(&its_nodes)) {
+		int ret;
+
+		ret = redist_disable_lpis();
+		if (ret)
+			return ret;
+
+		its_cpu_init_lpis();
+		its_cpu_init_collections();
+	}
+
+	return 0;
+}
+
+static const struct of_device_id its_device_id[] = {
+	{	.compatible	= "arm,gic-v3-its",	},
+	{},
+};
+
+static int __init its_of_probe(struct device_node *node)
+{
+	struct device_node *np;
+	struct resource res;
+
+	for (np = of_find_matching_node(node, its_device_id); np;
+	     np = of_find_matching_node(np, its_device_id)) {
+		if (!of_device_is_available(np))
+			continue;
+		if (!of_property_read_bool(np, "msi-controller")) {
+			pr_warn("%pOF: no msi-controller property, ITS ignored\n",
+				np);
+			continue;
+		}
+
+		if (of_address_to_resource(np, 0, &res)) {
+			pr_warn("%pOF: no regs?\n", np);
+			continue;
+		}
+
+		its_probe_one(&res, &np->fwnode, of_node_to_nid(np));
+	}
+	return 0;
+}
+
+#ifdef CONFIG_ACPI
+
+#define ACPI_GICV3_ITS_MEM_SIZE (SZ_128K)
+
+#ifdef CONFIG_ACPI_NUMA
+struct its_srat_map {
+	/* numa node id */
+	u32	numa_node;
+	/* GIC ITS ID */
+	u32	its_id;
+};
+
+static struct its_srat_map *its_srat_maps __initdata;
+static int its_in_srat __initdata;
+
+static int __init acpi_get_its_numa_node(u32 its_id)
+{
+	int i;
+
+	for (i = 0; i < its_in_srat; i++) {
+		if (its_id == its_srat_maps[i].its_id)
+			return its_srat_maps[i].numa_node;
+	}
+	return NUMA_NO_NODE;
+}
+
+static int __init gic_acpi_match_srat_its(union acpi_subtable_headers *header,
+					  const unsigned long end)
+{
+	return 0;
+}
+
+static int __init gic_acpi_parse_srat_its(union acpi_subtable_headers *header,
+			 const unsigned long end)
+{
+	int node;
+	struct acpi_srat_gic_its_affinity *its_affinity;
+
+	its_affinity = (struct acpi_srat_gic_its_affinity *)header;
+	if (!its_affinity)
+		return -EINVAL;
+
+	if (its_affinity->header.length < sizeof(*its_affinity)) {
+		pr_err("SRAT: Invalid header length %d in ITS affinity\n",
+			its_affinity->header.length);
+		return -EINVAL;
+	}
+
+	node = acpi_map_pxm_to_node(its_affinity->proximity_domain);
+
+	if (node == NUMA_NO_NODE || node >= MAX_NUMNODES) {
+		pr_err("SRAT: Invalid NUMA node %d in ITS affinity\n", node);
+		return 0;
+	}
+
+	its_srat_maps[its_in_srat].numa_node = node;
+	its_srat_maps[its_in_srat].its_id = its_affinity->its_id;
+	its_in_srat++;
+	pr_info("SRAT: PXM %d -> ITS %d -> Node %d\n",
+		its_affinity->proximity_domain, its_affinity->its_id, node);
+
+	return 0;
+}
+
+static void __init acpi_table_parse_srat_its(void)
+{
+	int count;
+
+	count = acpi_table_parse_entries(ACPI_SIG_SRAT,
+			sizeof(struct acpi_table_srat),
+			ACPI_SRAT_TYPE_GIC_ITS_AFFINITY,
+			gic_acpi_match_srat_its, 0);
+	if (count <= 0)
+		return;
+
+	its_srat_maps = kmalloc_array(count, sizeof(struct its_srat_map),
+				      GFP_KERNEL);
+	if (!its_srat_maps) {
+		pr_warn("SRAT: Failed to allocate memory for its_srat_maps!\n");
+		return;
+	}
+
+	acpi_table_parse_entries(ACPI_SIG_SRAT,
+			sizeof(struct acpi_table_srat),
+			ACPI_SRAT_TYPE_GIC_ITS_AFFINITY,
+			gic_acpi_parse_srat_its, 0);
+}
+
+/* free the its_srat_maps after ITS probing */
+static void __init acpi_its_srat_maps_free(void)
+{
+	kfree(its_srat_maps);
+}
+#else
+static void __init acpi_table_parse_srat_its(void)	{ }
+static int __init acpi_get_its_numa_node(u32 its_id) { return NUMA_NO_NODE; }
+static void __init acpi_its_srat_maps_free(void) { }
+#endif
+
+static int __init gic_acpi_parse_madt_its(union acpi_subtable_headers *header,
+					  const unsigned long end)
+{
+	struct acpi_madt_generic_translator *its_entry;
+	struct fwnode_handle *dom_handle;
+	struct resource res;
+	int err;
+
+	its_entry = (struct acpi_madt_generic_translator *)header;
+	memset(&res, 0, sizeof(res));
+	res.start = its_entry->base_address;
+	res.end = its_entry->base_address + ACPI_GICV3_ITS_MEM_SIZE - 1;
+	res.flags = IORESOURCE_MEM;
+
+	dom_handle = irq_domain_alloc_fwnode((void *)its_entry->base_address);
+	if (!dom_handle) {
+		pr_err("ITS@%pa: Unable to allocate GIC-Phytium-2500 ITS domain token\n",
+		       &res.start);
+		return -ENOMEM;
+	}
+
+	err = iort_register_domain_token(its_entry->translation_id, res.start,
+					 dom_handle);
+	if (err) {
+		pr_err("ITS@%pa: Unable to register GIC-Phytium-2500 ITS domain token (ITS ID %d) to IORT\n",
+		       &res.start, its_entry->translation_id);
+		goto dom_err;
+	}
+
+	err = its_probe_one(&res, dom_handle,
+			acpi_get_its_numa_node(its_entry->translation_id));
+	if (!err)
+		return 0;
+
+	iort_deregister_domain_token(its_entry->translation_id);
+dom_err:
+	irq_domain_free_fwnode(dom_handle);
+	return err;
+}
+
+static void __init its_acpi_probe(void)
+{
+	acpi_table_parse_srat_its();
+	acpi_table_parse_madt(ACPI_MADT_TYPE_GENERIC_TRANSLATOR,
+			      gic_acpi_parse_madt_its, 0);
+	acpi_its_srat_maps_free();
+}
+#else
+static void __init its_acpi_probe(void) { }
+#endif
+
+int __init phytium_its_init(struct fwnode_handle *handle, struct rdists *rdists,
+		    struct irq_domain *parent_domain)
+{
+	struct device_node *of_node;
+	struct its_node *its;
+	bool has_v4 = false;
+	int err;
+
+	its_parent = parent_domain;
+	of_node = to_of_node(handle);
+	if (of_node)
+		its_of_probe(of_node);
+	else
+		its_acpi_probe();
+
+	if (list_empty(&its_nodes)) {
+		pr_warn("ITS: No ITS available, not enabling LPIs\n");
+		return -ENXIO;
+	}
+
+	gic_rdists = rdists;
+
+	err = allocate_lpi_tables();
+	if (err)
+		return err;
+
+	list_for_each_entry(its, &its_nodes, entry)
+		has_v4 |= its->is_v4;
+
+	if (has_v4 & rdists->has_vlpis) {
+		if (its_init_vpe_domain() ||
+		    its_init_v4(parent_domain, &its_vpe_domain_ops, NULL)) {
+			rdists->has_vlpis = false;
+			pr_err("ITS: Disabling GICv4 support\n");
+		}
+	}
+
+	register_syscore_ops(&its_syscore_ops);
+
+	return 0;
+}
diff --git a/drivers/irqchip/irq-gic-phytium-2500.c b/drivers/irqchip/irq-gic-phytium-2500.c
new file mode 100644
index 000000000000..4d95ce60786d
--- /dev/null
+++ b/drivers/irqchip/irq-gic-phytium-2500.c
@@ -0,0 +1,1882 @@
+/*
+ * Copyright (C) 2020 Phytium Corporation.
+ * Author: Wang Yinfeng <wangyinfeng@phytium.com.cn>
+ *         Chen Baozi <chenbaozi@phytium.com.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt)	"GIC-2500: " fmt
+
+#include <linux/acpi.h>
+#include <linux/cpu.h>
+#include <linux/cpu_pm.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/irqdomain.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/percpu.h>
+#include <linux/slab.h>
+
+#include <linux/irqchip.h>
+#include <linux/irqchip/arm-gic-common.h>
+#include <linux/irqchip/arm-gic-phytium-2500.h>
+#include <linux/irqchip/irq-partition-percpu.h>
+
+#include <asm/cputype.h>
+#include <asm/exception.h>
+#include <asm/smp_plat.h>
+#include <asm/virt.h>
+
+#include "irq-gic-common.h"
+#include <linux/crash_dump.h>
+
+#define MAX_MARS3_SOC_COUNT	8
+#define MARS3_ADDR_SKTID_SHIFT	41
+
+struct gic_dist_desc {
+	void __iomem		*dist_base;
+	phys_addr_t		phys_base;
+	unsigned long		size;
+};
+
+struct redist_region {
+	void __iomem		*redist_base;
+	phys_addr_t		phys_base;
+	bool			single_redist;
+};
+
+static struct gic_dist_desc mars3_gic_dists[MAX_MARS3_SOC_COUNT] __read_mostly;
+
+static unsigned int mars3_sockets_bitmap = 0x1;
+
+#define mars3_irq_to_skt(hwirq)	(((hwirq) - 32) % 8)
+
+struct gic_chip_data {
+	struct fwnode_handle	*fwnode;
+	void __iomem		*dist_base;
+	struct redist_region	*redist_regions;
+	struct rdists		rdists;
+	struct irq_domain	*domain;
+	u64			redist_stride;
+	u32			nr_redist_regions;
+	bool			has_rss;
+	unsigned int		irq_nr;
+	struct partition_desc	*ppi_descs[16];
+};
+
+static struct gic_chip_data gic_data __read_mostly;
+static DEFINE_STATIC_KEY_TRUE(supports_deactivate_key);
+
+static struct gic_kvm_info gic_v3_kvm_info;
+static DEFINE_PER_CPU(bool, has_rss);
+
+#define MPIDR_RS(mpidr)			(((mpidr) & 0xF0UL) >> 4)
+#define gic_data_rdist()		(this_cpu_ptr(gic_data.rdists.rdist))
+#define gic_data_rdist_rd_base()	(gic_data_rdist()->rd_base)
+#define gic_data_rdist_sgi_base()	(gic_data_rdist_rd_base() + SZ_64K)
+
+/* Our default, arbitrary priority value. Linux only uses one anyway. */
+#define DEFAULT_PMR_VALUE	0xf0
+
+static inline unsigned int gic_irq(struct irq_data *d)
+{
+	return d->hwirq;
+}
+
+static inline int gic_irq_in_rdist(struct irq_data *d)
+{
+	return gic_irq(d) < 32;
+}
+
+static inline void __iomem *gic_dist_base(struct irq_data *d)
+{
+	if (gic_irq_in_rdist(d))	/* SGI+PPI -> SGI_base for this CPU */
+		return gic_data_rdist_sgi_base();
+
+	if (d->hwirq <= 1023)		/* SPI -> dist_base */
+		return gic_data.dist_base;
+
+	return NULL;
+}
+
+static void gic_do_wait_for_rwp(void __iomem *base)
+{
+	u32 count = 1000000;	/* 1s! */
+
+	while (readl_relaxed(base + GICD_CTLR) & GICD_CTLR_RWP) {
+		count--;
+		if (!count) {
+			pr_err_ratelimited("RWP timeout, gone fishing\n");
+			return;
+		}
+		cpu_relax();
+		udelay(1);
+	};
+}
+
+/* Wait for completion of a distributor change */
+static void gic_dist_wait_for_rwp(void)
+{
+	gic_do_wait_for_rwp(gic_data.dist_base);
+}
+
+/* Wait for completion of a redistributor change */
+static void gic_redist_wait_for_rwp(void)
+{
+	gic_do_wait_for_rwp(gic_data_rdist_rd_base());
+}
+
+#ifdef CONFIG_ARM64
+
+static u64 __maybe_unused gic_read_iar(void)
+{
+	if (cpus_have_const_cap(ARM64_WORKAROUND_CAVIUM_23154))
+		return gic_read_iar_cavium_thunderx();
+	else
+		return gic_read_iar_common();
+}
+#endif
+
+static void gic_enable_redist(bool enable)
+{
+	void __iomem *rbase;
+	u32 count = 1000000;	/* 1s! */
+	u32 val;
+	unsigned long mpidr;
+	int i;
+
+	rbase = gic_data_rdist_rd_base();
+
+	val = readl_relaxed(rbase + GICR_WAKER);
+	if (enable)
+		/* Wake up this CPU redistributor */
+		val &= ~GICR_WAKER_ProcessorSleep;
+	else
+		val |= GICR_WAKER_ProcessorSleep;
+	writel_relaxed(val, rbase + GICR_WAKER);
+
+	if (!enable) {		/* Check that GICR_WAKER is writeable */
+		val = readl_relaxed(rbase + GICR_WAKER);
+		if (!(val & GICR_WAKER_ProcessorSleep))
+			return;	/* No PM support in this redistributor */
+	}
+
+	while (--count) {
+		val = readl_relaxed(rbase + GICR_WAKER);
+		if (enable ^ (bool)(val & GICR_WAKER_ChildrenAsleep))
+			break;
+		cpu_relax();
+		udelay(1);
+	};
+	if (!count)
+		pr_err_ratelimited("redistributor failed to %s...\n",
+				   enable ? "wakeup" : "sleep");
+
+	mpidr = (unsigned long)cpu_logical_map(smp_processor_id());
+
+	/* Either Aff0 or Aff1 is not zero */
+	if (mpidr & 0xffff)
+		return;
+
+	/* Skip 64 Redistributors */
+	rbase = rbase + 64 * SZ_128K;
+
+	for (i = 0; i < 4; i++) {
+		val = readl_relaxed(rbase + GICR_WAKER);
+		if (enable)
+			val &= ~GICR_WAKER_ProcessorSleep;
+		else
+			val |= GICR_WAKER_ProcessorSleep;
+		writel_relaxed(val, rbase + GICR_WAKER);
+
+		if (!enable) {
+			val = readl_relaxed(rbase + GICR_WAKER);
+			if (!(val & GICR_WAKER_ProcessorSleep))
+				return;
+		}
+
+		count = 1000000;    /* 1s! */
+		while (--count) {
+			val = readl_relaxed(rbase + GICR_WAKER);
+			if (enable ^ (bool)(val & GICR_WAKER_ChildrenAsleep))
+				break;
+			cpu_relax();
+			udelay(1);
+		};
+
+		if (!count)
+			pr_err_ratelimited("CPU MPIDR 0x%lx: redistributor %d failed to %s...\n",
+					   mpidr, 64 + i, enable ? "wakeup" : "sleep");
+
+		rbase = rbase + SZ_128K;
+	}
+}
+
+/*
+ * Routines to disable, enable, EOI and route interrupts
+ */
+static int gic_peek_irq(struct irq_data *d, u32 offset)
+{
+	u32 mask = 1 << (gic_irq(d) % 32);
+	void __iomem *base;
+	unsigned int skt;
+
+	if (gic_irq_in_rdist(d))
+		base = gic_data_rdist_sgi_base();
+	else {
+		skt = mars3_irq_to_skt(gic_irq(d));
+		base = mars3_gic_dists[skt].dist_base;
+	}
+
+	return !!(readl_relaxed(base + offset + (gic_irq(d) / 32) * 4) & mask);
+}
+
+static void gic_poke_irq(struct irq_data *d, u32 offset)
+{
+	u32 mask = 1 << (gic_irq(d) % 32);
+	void __iomem *base;
+	unsigned long mpidr;
+	void __iomem *rbase;
+	int i;
+	unsigned int skt;
+
+	if (gic_irq_in_rdist(d)) {
+		base = gic_data_rdist_sgi_base();
+
+		writel_relaxed(mask, base + offset + (gic_irq(d) / 32) * 4);
+		gic_redist_wait_for_rwp();
+
+		mpidr = (unsigned long)cpu_logical_map(smp_processor_id());
+
+		if ((mpidr & 0xffff) == 0) {
+			rbase = base + 64*SZ_128K;
+
+			for (i = 0; i < 4; i++) {
+				writel_relaxed(mask, rbase + offset + (gic_irq(d) / 32) * 4);
+				gic_do_wait_for_rwp(rbase - SZ_64K);
+				rbase = rbase + SZ_128K;
+			}
+		}
+	} else {
+		skt = mars3_irq_to_skt(gic_irq(d));
+		base = mars3_gic_dists[skt].dist_base;
+		writel_relaxed(mask, base + offset + (gic_irq(d) / 32) * 4);
+		gic_do_wait_for_rwp(base);
+	}
+}
+
+static void gic_mask_irq(struct irq_data *d)
+{
+	gic_poke_irq(d, GICD_ICENABLER);
+}
+
+static void gic_eoimode1_mask_irq(struct irq_data *d)
+{
+	gic_mask_irq(d);
+	/*
+	 * When masking a forwarded interrupt, make sure it is
+	 * deactivated as well.
+	 *
+	 * This ensures that an interrupt that is getting
+	 * disabled/masked will not get "stuck", because there is
+	 * noone to deactivate it (guest is being terminated).
+	 */
+	if (irqd_is_forwarded_to_vcpu(d))
+		gic_poke_irq(d, GICD_ICACTIVER);
+}
+
+static void gic_unmask_irq(struct irq_data *d)
+{
+	gic_poke_irq(d, GICD_ISENABLER);
+}
+
+static int gic_irq_set_irqchip_state(struct irq_data *d,
+				     enum irqchip_irq_state which, bool val)
+{
+	u32 reg;
+
+	if (d->hwirq >= gic_data.irq_nr) /* PPI/SPI only */
+		return -EINVAL;
+
+	switch (which) {
+	case IRQCHIP_STATE_PENDING:
+		reg = val ? GICD_ISPENDR : GICD_ICPENDR;
+		break;
+
+	case IRQCHIP_STATE_ACTIVE:
+		reg = val ? GICD_ISACTIVER : GICD_ICACTIVER;
+		break;
+
+	case IRQCHIP_STATE_MASKED:
+		reg = val ? GICD_ICENABLER : GICD_ISENABLER;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	gic_poke_irq(d, reg);
+	return 0;
+}
+
+static int gic_irq_get_irqchip_state(struct irq_data *d,
+				     enum irqchip_irq_state which, bool *val)
+{
+	if (d->hwirq >= gic_data.irq_nr) /* PPI/SPI only */
+		return -EINVAL;
+
+	switch (which) {
+	case IRQCHIP_STATE_PENDING:
+		*val = gic_peek_irq(d, GICD_ISPENDR);
+		break;
+
+	case IRQCHIP_STATE_ACTIVE:
+		*val = gic_peek_irq(d, GICD_ISACTIVER);
+		break;
+
+	case IRQCHIP_STATE_MASKED:
+		*val = !gic_peek_irq(d, GICD_ISENABLER);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void gic_eoi_irq(struct irq_data *d)
+{
+	gic_write_eoir(gic_irq(d));
+}
+
+static void gic_eoimode1_eoi_irq(struct irq_data *d)
+{
+	/*
+	 * No need to deactivate an LPI, or an interrupt that
+	 * is is getting forwarded to a vcpu.
+	 */
+	if (gic_irq(d) >= 8192 || irqd_is_forwarded_to_vcpu(d))
+		return;
+	gic_write_dir(gic_irq(d));
+}
+
+static int gic_set_type(struct irq_data *d, unsigned int type)
+{
+	unsigned int irq = gic_irq(d);
+	unsigned long mpidr;
+	int i;
+	void __iomem *base;
+	void __iomem *rbase;
+	unsigned int skt;
+	int ret;
+
+	/* Interrupt configuration for SGIs can't be changed */
+	if (irq < 16)
+		return -EINVAL;
+
+	/* SPIs have restrictions on the supported types */
+	if (irq >= 32 && type != IRQ_TYPE_LEVEL_HIGH &&
+	    type != IRQ_TYPE_EDGE_RISING)
+		return -EINVAL;
+
+	if (gic_irq_in_rdist(d)) {
+		base = gic_data_rdist_sgi_base();
+		ret = gic_configure_irq(irq, type, base, gic_redist_wait_for_rwp);
+
+		mpidr = (unsigned long)cpu_logical_map(smp_processor_id());
+
+		if ((mpidr & 0xffff) == 0) {
+			rbase = base + 64*SZ_128K;
+
+			for (i = 0; i < 4; i++) {
+				ret = gic_configure_irq(irq, type, rbase, NULL);
+				gic_do_wait_for_rwp(rbase - SZ_64K);
+				rbase = rbase + SZ_128K;
+			}
+		}
+	} else {
+		skt = mars3_irq_to_skt(gic_irq(d));
+		base = mars3_gic_dists[skt].dist_base;
+		ret = gic_configure_irq(irq, type, base, NULL);
+		gic_do_wait_for_rwp(base);
+	}
+
+	return ret;
+}
+
+static int gic_irq_set_vcpu_affinity(struct irq_data *d, void *vcpu)
+{
+	if (vcpu)
+		irqd_set_forwarded_to_vcpu(d);
+	else
+		irqd_clr_forwarded_to_vcpu(d);
+	return 0;
+}
+
+static u64 gic_mpidr_to_affinity(unsigned long mpidr)
+{
+	u64 aff;
+
+	aff = ((u64)MPIDR_AFFINITY_LEVEL(mpidr, 3) << 32 |
+	       MPIDR_AFFINITY_LEVEL(mpidr, 2) << 16 |
+	       MPIDR_AFFINITY_LEVEL(mpidr, 1) << 8  |
+	       MPIDR_AFFINITY_LEVEL(mpidr, 0));
+
+	return aff;
+}
+
+static asmlinkage void __exception_irq_entry gic_handle_irq(struct pt_regs *regs)
+{
+	u32 irqnr;
+
+	do {
+		irqnr = gic_read_iar();
+
+		if (likely(irqnr > 15 && irqnr < 1020) || irqnr >= 8192) {
+			int err;
+
+			if (static_branch_likely(&supports_deactivate_key))
+				gic_write_eoir(irqnr);
+			else
+				isb();
+
+			err = handle_domain_irq(gic_data.domain, irqnr, regs);
+			if (err) {
+				WARN_ONCE(true, "Unexpected interrupt received!\n");
+				if (static_branch_likely(&supports_deactivate_key)) {
+					if (irqnr < 8192)
+						gic_write_dir(irqnr);
+				} else {
+					gic_write_eoir(irqnr);
+				}
+			}
+			continue;
+		}
+		if (irqnr < 16) {
+			gic_write_eoir(irqnr);
+			if (static_branch_likely(&supports_deactivate_key))
+				gic_write_dir(irqnr);
+#ifdef CONFIG_SMP
+			/*
+			 * Unlike GICv2, we don't need an smp_rmb() here.
+			 * The control dependency from gic_read_iar to
+			 * the ISB in gic_write_eoir is enough to ensure
+			 * that any shared data read by handle_IPI will
+			 * be read after the ACK.
+			 */
+			handle_IPI(irqnr, regs);
+#else
+			WARN_ONCE(true, "Unexpected SGI received!\n");
+#endif
+			continue;
+		}
+	} while (irqnr != ICC_IAR1_EL1_SPURIOUS);
+}
+
+static void __init gic_dist_init(void)
+{
+	unsigned int i;
+	u64 affinity;
+	void __iomem *base;
+	unsigned int skt;
+
+	for (skt = 0; skt < MAX_MARS3_SOC_COUNT; skt++) {
+		if ((((unsigned int)1 << skt) & mars3_sockets_bitmap) == 0)
+			continue;
+
+		base = mars3_gic_dists[skt].dist_base;
+
+		/* Disable the distributor */
+		writel_relaxed(0, base + GICD_CTLR);
+		gic_do_wait_for_rwp(base);
+
+		/*
+		 * Configure SPIs as non-secure Group-1. This will only matter
+		 * if the GIC only has a single security state. This will not
+		 * do the right thing if the kernel is running in secure mode,
+		 * but that's not the intended use case anyway.
+		 */
+		for (i = 32; i < gic_data.irq_nr; i += 32)
+			writel_relaxed(~0, base + GICD_IGROUPR + i / 8);
+
+		gic_dist_config(base, gic_data.irq_nr, NULL);
+		gic_do_wait_for_rwp(base);
+
+		/* Enable distributor with ARE, Group1 */
+		writel_relaxed(GICD_CTLR_ARE_NS | GICD_CTLR_ENABLE_G1A | GICD_CTLR_ENABLE_G1,
+			       base + GICD_CTLR);
+
+		/*
+		 * Set all global interrupts to the boot CPU only. ARE must be
+		 * enabled.
+		 */
+		affinity = gic_mpidr_to_affinity(cpu_logical_map(smp_processor_id()));
+		for (i = 32; i < gic_data.irq_nr; i++)
+			gic_write_irouter(affinity, base + GICD_IROUTER + i * 8);
+	}
+}
+
+static int gic_iterate_rdists(int (*fn)(struct redist_region *, void __iomem *))
+{
+	int ret = -ENODEV;
+	int i;
+
+	for (i = 0; i < gic_data.nr_redist_regions; i++) {
+		void __iomem *ptr = gic_data.redist_regions[i].redist_base;
+		u64 typer;
+		u32 reg;
+
+		reg = readl_relaxed(ptr + GICR_PIDR2) & GIC_PIDR2_ARCH_MASK;
+		if (reg != GIC_PIDR2_ARCH_GICv3 &&
+		    reg != GIC_PIDR2_ARCH_GICv4) { /* We're in trouble... */
+			pr_warn("No redistributor present @%p\n", ptr);
+			break;
+		}
+
+		do {
+			typer = gic_read_typer(ptr + GICR_TYPER);
+			ret = fn(gic_data.redist_regions + i, ptr);
+			if (!ret)
+				return 0;
+
+			if (gic_data.redist_regions[i].single_redist)
+				break;
+
+			if (gic_data.redist_stride) {
+				ptr += gic_data.redist_stride;
+			} else {
+				ptr += SZ_64K * 2; /* Skip RD_base + SGI_base */
+				if (typer & GICR_TYPER_VLPIS)
+					ptr += SZ_64K * 2; /* Skip VLPI_base + reserved page */
+			}
+		} while (!(typer & GICR_TYPER_LAST));
+	}
+
+	return ret ? -ENODEV : 0;
+}
+
+static int __gic_populate_rdist(struct redist_region *region, void __iomem *ptr)
+{
+	unsigned long mpidr = cpu_logical_map(smp_processor_id());
+	u64 typer;
+	u32 aff, aff2_skt, rdist_skt;
+
+	/*
+	 * Convert affinity to a 32bit value that can be matched to
+	 * GICR_TYPER bits [63:32].
+	 */
+	aff = (MPIDR_AFFINITY_LEVEL(mpidr, 1) << 8 |
+	      MPIDR_AFFINITY_LEVEL(mpidr, 0));
+
+	aff2_skt = MPIDR_AFFINITY_LEVEL(mpidr, 2) & 0x7;
+	rdist_skt = (((u64)region->phys_base >> MARS3_ADDR_SKTID_SHIFT) & 0x7);
+
+	if (aff2_skt != rdist_skt)
+		return 1;
+
+	typer = gic_read_typer(ptr + GICR_TYPER);
+	if ((typer >> 32) == aff) {
+		u64 offset = ptr - region->redist_base;
+		gic_data_rdist_rd_base() = ptr;
+		gic_data_rdist()->phys_base = region->phys_base + offset;
+
+		pr_info("CPU%d: found redistributor %lx region %d:%pa\n",
+			smp_processor_id(), mpidr,
+			(int)(region - gic_data.redist_regions),
+			&gic_data_rdist()->phys_base);
+		return 0;
+	}
+
+	/* Try next one */
+	return 1;
+}
+
+static int gic_populate_rdist(void)
+{
+	if (gic_iterate_rdists(__gic_populate_rdist) == 0)
+		return 0;
+
+	/* We couldn't even deal with ourselves... */
+	WARN(true, "CPU%d: mpidr %lx has no re-distributor!\n",
+	     smp_processor_id(),
+	     (unsigned long)cpu_logical_map(smp_processor_id()));
+	return -ENODEV;
+}
+
+static int __gic_update_vlpi_properties(struct redist_region *region,
+					void __iomem *ptr)
+{
+	u64 typer = gic_read_typer(ptr + GICR_TYPER);
+	gic_data.rdists.has_vlpis &= !!(typer & GICR_TYPER_VLPIS);
+	gic_data.rdists.has_direct_lpi &= !!(typer & GICR_TYPER_DirectLPIS);
+
+	return 1;
+}
+
+static void gic_update_vlpi_properties(void)
+{
+	gic_iterate_rdists(__gic_update_vlpi_properties);
+	pr_info("%sVLPI support, %sdirect LPI support\n",
+		!gic_data.rdists.has_vlpis ? "no " : "",
+		!gic_data.rdists.has_direct_lpi ? "no " : "");
+}
+
+static void gic_cpu_sys_reg_init(void)
+{
+	int i, cpu = smp_processor_id();
+	u64 mpidr = cpu_logical_map(cpu);
+	u64 need_rss = MPIDR_RS(mpidr);
+	bool group0;
+	u32 val, pribits;
+
+	/*
+	 * Need to check that the SRE bit has actually been set. If
+	 * not, it means that SRE is disabled at EL2. We're going to
+	 * die painfully, and there is nothing we can do about it.
+	 *
+	 * Kindly inform the luser.
+	 */
+	if (!gic_enable_sre())
+		pr_err("GIC: unable to set SRE (disabled at EL2), panic ahead\n");
+
+	pribits = gic_read_ctlr();
+	pribits &= ICC_CTLR_EL1_PRI_BITS_MASK;
+	pribits >>= ICC_CTLR_EL1_PRI_BITS_SHIFT;
+	pribits++;
+
+	/*
+	 * Let's find out if Group0 is under control of EL3 or not by
+	 * setting the highest possible, non-zero priority in PMR.
+	 *
+	 * If SCR_EL3.FIQ is set, the priority gets shifted down in
+	 * order for the CPU interface to set bit 7, and keep the
+	 * actual priority in the non-secure range. In the process, it
+	 * looses the least significant bit and the actual priority
+	 * becomes 0x80. Reading it back returns 0, indicating that
+	 * we're don't have access to Group0.
+	 */
+	write_gicreg(BIT(8 - pribits), ICC_PMR_EL1);
+	val = read_gicreg(ICC_PMR_EL1);
+	group0 = val != 0;
+
+	/* Set priority mask register */
+	write_gicreg(DEFAULT_PMR_VALUE, ICC_PMR_EL1);
+
+	/*
+	 * Some firmwares hand over to the kernel with the BPR changed from
+	 * its reset value (and with a value large enough to prevent
+	 * any pre-emptive interrupts from working at all). Writing a zero
+	 * to BPR restores is reset value.
+	 */
+	gic_write_bpr1(0);
+
+	if (static_branch_likely(&supports_deactivate_key)) {
+		/* EOI drops priority only (mode 1) */
+		gic_write_ctlr(ICC_CTLR_EL1_EOImode_drop);
+	} else {
+		/* EOI deactivates interrupt too (mode 0) */
+		gic_write_ctlr(ICC_CTLR_EL1_EOImode_drop_dir);
+	}
+
+	/* Always whack Group0 before Group1 */
+	if (group0) {
+		switch(pribits) {
+		case 8:
+		case 7:
+			write_gicreg(0, ICC_AP0R3_EL1);
+			write_gicreg(0, ICC_AP0R2_EL1);
+		case 6:
+			write_gicreg(0, ICC_AP0R1_EL1);
+		case 5:
+		case 4:
+			write_gicreg(0, ICC_AP0R0_EL1);
+		}
+
+		isb();
+	}
+
+	switch(pribits) {
+	case 8:
+	case 7:
+		write_gicreg(0, ICC_AP1R3_EL1);
+		write_gicreg(0, ICC_AP1R2_EL1);
+	case 6:
+		write_gicreg(0, ICC_AP1R1_EL1);
+	case 5:
+	case 4:
+		write_gicreg(0, ICC_AP1R0_EL1);
+	}
+
+	isb();
+
+	/* ... and let's hit the road... */
+	gic_write_grpen1(1);
+
+	/* Keep the RSS capability status in per_cpu variable */
+	per_cpu(has_rss, cpu) = !!(gic_read_ctlr() & ICC_CTLR_EL1_RSS);
+
+	/* Check all the CPUs have capable of sending SGIs to other CPUs */
+	for_each_online_cpu(i) {
+		bool have_rss = per_cpu(has_rss, i) && per_cpu(has_rss, cpu);
+
+		need_rss |= MPIDR_RS(cpu_logical_map(i));
+		if (need_rss && (!have_rss))
+			pr_crit("CPU%d (%lx) can't SGI CPU%d (%lx), no RSS\n",
+				cpu, (unsigned long)mpidr,
+				i, (unsigned long)cpu_logical_map(i));
+	}
+
+	/**
+	 * GIC spec says, when ICC_CTLR_EL1.RSS==1 and GICD_TYPER.RSS==0,
+	 * writing ICC_ASGI1R_EL1 register with RS != 0 is a CONSTRAINED
+	 * UNPREDICTABLE choice of :
+	 *   - The write is ignored.
+	 *   - The RS field is treated as 0.
+	 */
+	if (need_rss && (!gic_data.has_rss))
+		pr_crit_once("RSS is required but GICD doesn't support it\n");
+}
+
+static bool gicv3_nolpi;
+
+static int __init gicv3_nolpi_cfg(char *buf)
+{
+	return strtobool(buf, &gicv3_nolpi);
+}
+early_param("irqchip.gicv3_nolpi", gicv3_nolpi_cfg);
+
+static int gic_dist_supports_lpis(void)
+{
+	return !!(readl_relaxed(gic_data.dist_base + GICD_TYPER) & GICD_TYPER_LPIS) && !gicv3_nolpi;
+}
+
+static void gic_cpu_init(void)
+{
+	void __iomem *rbase;
+	unsigned long mpidr;
+	int i;
+
+	/* Register ourselves with the rest of the world */
+	if (gic_populate_rdist())
+		return;
+
+	gic_enable_redist(true);
+
+	rbase = gic_data_rdist_sgi_base();
+
+	/* Configure SGIs/PPIs as non-secure Group-1 */
+	writel_relaxed(~0, rbase + GICR_IGROUPR0);
+
+	gic_cpu_config(rbase, 32, gic_redist_wait_for_rwp);
+
+	mpidr = (unsigned long)cpu_logical_map(smp_processor_id());
+
+	if ((mpidr & 0xFFFF) == 0) {
+		rbase = rbase + 64*SZ_128K;
+
+		for (i = 0; i < 4; i++) {
+			/* Configure SGIs/PPIs as non-secure Group-1 */
+			writel_relaxed(~0, rbase + GICR_IGROUPR0);
+
+			gic_cpu_config(rbase, 32, NULL);
+			gic_do_wait_for_rwp(rbase - SZ_64K);
+
+			rbase = rbase + SZ_128K;
+		}
+	}
+
+	/* initialise system registers */
+	gic_cpu_sys_reg_init();
+}
+
+#ifdef CONFIG_SMP
+
+#define MPIDR_TO_SGI_RS(mpidr)	(MPIDR_RS(mpidr) << ICC_SGI1R_RS_SHIFT)
+#define MPIDR_TO_SGI_CLUSTER_ID(mpidr)	((mpidr) & ~0xFUL)
+
+static int gic_starting_cpu(unsigned int cpu)
+{
+	gic_cpu_init();
+
+	if (gic_dist_supports_lpis())
+		phytium_its_cpu_init();
+
+	return 0;
+}
+
+static u16 gic_compute_target_list(int *base_cpu, const struct cpumask *mask,
+				   unsigned long cluster_id)
+{
+	int next_cpu, cpu = *base_cpu;
+	unsigned long mpidr = cpu_logical_map(cpu);
+	u16 tlist = 0;
+
+	while (cpu < nr_cpu_ids) {
+		tlist |= 1 << (mpidr & 0xf);
+
+		next_cpu = cpumask_next(cpu, mask);
+		if (next_cpu >= nr_cpu_ids)
+			goto out;
+		cpu = next_cpu;
+
+		mpidr = cpu_logical_map(cpu);
+
+		if (cluster_id != MPIDR_TO_SGI_CLUSTER_ID(mpidr)) {
+			cpu--;
+			goto out;
+		}
+	}
+out:
+	*base_cpu = cpu;
+	return tlist;
+}
+
+#define MPIDR_TO_SGI_AFFINITY(cluster_id, level) \
+	(MPIDR_AFFINITY_LEVEL(cluster_id, level) \
+		<< ICC_SGI1R_AFFINITY_## level ##_SHIFT)
+
+static void gic_send_sgi(u64 cluster_id, u16 tlist, unsigned int irq)
+{
+	u64 val;
+
+	val = (MPIDR_TO_SGI_AFFINITY(cluster_id, 3)	|
+	       MPIDR_TO_SGI_AFFINITY(cluster_id, 2)	|
+	       irq << ICC_SGI1R_SGI_ID_SHIFT		|
+	       MPIDR_TO_SGI_AFFINITY(cluster_id, 1)	|
+	       MPIDR_TO_SGI_RS(cluster_id)		|
+	       tlist << ICC_SGI1R_TARGET_LIST_SHIFT);
+
+	pr_devel("CPU%d: ICC_SGI1R_EL1 %llx\n", smp_processor_id(), val);
+	gic_write_sgi1r(val);
+}
+
+static void gic_raise_softirq(const struct cpumask *mask, unsigned int irq)
+{
+	int cpu;
+
+	if (WARN_ON(irq >= 16))
+		return;
+
+	/*
+	 * Ensure that stores to Normal memory are visible to the
+	 * other CPUs before issuing the IPI.
+	 */
+	wmb();
+
+	for_each_cpu(cpu, mask) {
+		u64 cluster_id = MPIDR_TO_SGI_CLUSTER_ID(cpu_logical_map(cpu));
+		u16 tlist;
+
+		tlist = gic_compute_target_list(&cpu, mask, cluster_id);
+		gic_send_sgi(cluster_id, tlist, irq);
+	}
+
+	/* Force the above writes to ICC_SGI1R_EL1 to be executed */
+	isb();
+}
+
+static void gic_smp_init(void)
+{
+	set_smp_cross_call(gic_raise_softirq);
+	cpuhp_setup_state_nocalls(CPUHP_AP_IRQ_GIC_STARTING,
+				  "irqchip/arm/gic_phytium_2500:starting",
+				  gic_starting_cpu, NULL);
+}
+
+static int gic_cpumask_select(struct irq_data *d, const struct cpumask *mask_val)
+{
+	unsigned int skt, irq_skt, i;
+	unsigned int cpu, cpus = 0;
+	unsigned int skt_cpu_cnt[MAX_MARS3_SOC_COUNT] = {0};
+
+	irq_skt = mars3_irq_to_skt(gic_irq(d));
+
+	for (i = 0; i < nr_cpu_ids; i++) {
+		skt = (cpu_logical_map(i) >> 16) & 0xff;
+		if ((skt >= 0) && (skt < MAX_MARS3_SOC_COUNT)) {
+			if ((is_kdump_kernel()) && (irq_skt == skt)) {
+				return i;
+			}
+
+			skt_cpu_cnt[skt]++;
+		}
+		else if (skt != 0xff)
+			pr_err("socket address: %d is out of range.", skt);
+	}
+
+	if (0 != irq_skt) {
+		for (i = 0; i < irq_skt; i++)
+			cpus += skt_cpu_cnt[i];
+	}
+
+	cpu = cpumask_any_and(mask_val, cpu_online_mask);
+	if ((cpu > cpus) && (cpu < (cpus + skt_cpu_cnt[irq_skt])))
+		cpus = cpu;
+
+	return cpus;
+}
+
+static int gic_set_affinity(struct irq_data *d, const struct cpumask *mask_val,
+			    bool force)
+{
+	unsigned int cpu, skt;
+	void __iomem *reg;
+	int enabled;
+	u64 val;
+
+	if (force)
+		cpu = cpumask_first(mask_val);
+	else
+		cpu = gic_cpumask_select(d, mask_val);
+
+	if (cpu >= nr_cpu_ids)
+		return -EINVAL;
+
+	if (gic_irq_in_rdist(d))
+		return -EINVAL;
+
+	/* If interrupt was enabled, disable it first */
+	enabled = gic_peek_irq(d, GICD_ISENABLER);
+	if (enabled)
+		gic_mask_irq(d);
+
+	skt = mars3_irq_to_skt(gic_irq(d));
+	reg = mars3_gic_dists[skt].dist_base + GICD_IROUTER + (gic_irq(d) * 8);
+	val = gic_mpidr_to_affinity(cpu_logical_map(cpu));
+
+	gic_write_irouter(val, reg);
+
+	/*
+	 * If the interrupt was enabled, enabled it again. Otherwise,
+	 * just wait for the distributor to have digested our changes.
+	 */
+	if (enabled)
+		gic_unmask_irq(d);
+	else
+		gic_dist_wait_for_rwp();
+
+	irq_data_update_effective_affinity(d, cpumask_of(cpu));
+
+	return IRQ_SET_MASK_OK_DONE;
+}
+#else
+#define gic_set_affinity	NULL
+#define gic_smp_init()		do { } while(0)
+#endif
+
+static int gic_retrigger(struct irq_data *data)
+{
+	return !gic_irq_set_irqchip_state(data, IRQCHIP_STATE_PENDING, true);
+}
+
+#ifdef CONFIG_CPU_PM
+/* Check whether it's single security state view */
+static bool gic_dist_security_disabled(void)
+{
+	return readl_relaxed(gic_data.dist_base + GICD_CTLR) & GICD_CTLR_DS;
+}
+
+static int gic_cpu_pm_notifier(struct notifier_block *self,
+			       unsigned long cmd, void *v)
+{
+	if (cmd == CPU_PM_EXIT) {
+		if (gic_dist_security_disabled())
+			gic_enable_redist(true);
+		gic_cpu_sys_reg_init();
+	} else if (cmd == CPU_PM_ENTER && gic_dist_security_disabled()) {
+		gic_write_grpen1(0);
+		gic_enable_redist(false);
+	}
+	return NOTIFY_OK;
+}
+
+static struct notifier_block gic_cpu_pm_notifier_block = {
+	.notifier_call = gic_cpu_pm_notifier,
+};
+
+static void gic_cpu_pm_init(void)
+{
+	cpu_pm_register_notifier(&gic_cpu_pm_notifier_block);
+}
+
+#else
+static inline void gic_cpu_pm_init(void) { }
+#endif /* CONFIG_CPU_PM */
+
+static struct irq_chip gic_chip = {
+	.name			= "GIC-Phytium-2500",
+	.irq_mask		= gic_mask_irq,
+	.irq_unmask		= gic_unmask_irq,
+	.irq_eoi		= gic_eoi_irq,
+	.irq_set_type		= gic_set_type,
+	.irq_set_affinity	= gic_set_affinity,
+	.irq_retrigger          = gic_retrigger,
+	.irq_get_irqchip_state	= gic_irq_get_irqchip_state,
+	.irq_set_irqchip_state	= gic_irq_set_irqchip_state,
+	.flags			= IRQCHIP_SET_TYPE_MASKED |
+				  IRQCHIP_SKIP_SET_WAKE |
+				  IRQCHIP_MASK_ON_SUSPEND,
+};
+
+static struct irq_chip gic_eoimode1_chip = {
+	.name			= "GIC-Phytium-2500",
+	.irq_mask		= gic_eoimode1_mask_irq,
+	.irq_unmask		= gic_unmask_irq,
+	.irq_eoi		= gic_eoimode1_eoi_irq,
+	.irq_set_type		= gic_set_type,
+	.irq_set_affinity	= gic_set_affinity,
+	.irq_retrigger          = gic_retrigger,
+	.irq_get_irqchip_state	= gic_irq_get_irqchip_state,
+	.irq_set_irqchip_state	= gic_irq_set_irqchip_state,
+	.irq_set_vcpu_affinity	= gic_irq_set_vcpu_affinity,
+	.flags			= IRQCHIP_SET_TYPE_MASKED |
+				  IRQCHIP_SKIP_SET_WAKE |
+				  IRQCHIP_MASK_ON_SUSPEND,
+};
+
+#define GIC_ID_NR	(1U << GICD_TYPER_ID_BITS(gic_data.rdists.gicd_typer))
+
+static int gic_irq_domain_map(struct irq_domain *d, unsigned int irq,
+			      irq_hw_number_t hw)
+{
+	struct irq_chip *chip = &gic_chip;
+	struct irq_data *irqd = irq_desc_get_irq_data(irq_to_desc(irq));
+
+	if (static_branch_likely(&supports_deactivate_key))
+		chip = &gic_eoimode1_chip;
+
+	/* SGIs are private to the core kernel */
+	if (hw < 16)
+		return -EPERM;
+	/* Nothing here */
+	if (hw >= gic_data.irq_nr && hw < 8192)
+		return -EPERM;
+	/* Off limits */
+	if (hw >= GIC_ID_NR)
+		return -EPERM;
+
+	/* PPIs */
+	if (hw < 32) {
+		irq_set_percpu_devid(irq);
+		irq_domain_set_info(d, irq, hw, chip, d->host_data,
+				    handle_percpu_devid_irq, NULL, NULL);
+		irq_set_status_flags(irq, IRQ_NOAUTOEN);
+	}
+	/* SPIs */
+	if (hw >= 32 && hw < gic_data.irq_nr) {
+		irq_domain_set_info(d, irq, hw, chip, d->host_data,
+				    handle_fasteoi_irq, NULL, NULL);
+		irq_set_probe(irq);
+		irqd_set_single_target(irqd);
+	}
+	/* LPIs */
+	if (hw >= 8192 && hw < GIC_ID_NR) {
+		if (!gic_dist_supports_lpis())
+			return -EPERM;
+		irq_domain_set_info(d, irq, hw, chip, d->host_data,
+				    handle_fasteoi_irq, NULL, NULL);
+	}
+
+	/* Prevents SW retriggers which mess up the ACK/EOI ordering */
+	irqd_set_handle_enforce_irqctx(irqd);
+	return 0;
+}
+
+#define GIC_IRQ_TYPE_PARTITION	(GIC_IRQ_TYPE_LPI + 1)
+
+static int gic_irq_domain_translate(struct irq_domain *d,
+				    struct irq_fwspec *fwspec,
+				    unsigned long *hwirq,
+				    unsigned int *type)
+{
+	if (is_of_node(fwspec->fwnode)) {
+		if (fwspec->param_count < 3)
+			return -EINVAL;
+
+		switch (fwspec->param[0]) {
+		case 0:			/* SPI */
+			*hwirq = fwspec->param[1] + 32;
+			break;
+		case 1:			/* PPI */
+		case GIC_IRQ_TYPE_PARTITION:
+			*hwirq = fwspec->param[1] + 16;
+			break;
+		case GIC_IRQ_TYPE_LPI:	/* LPI */
+			*hwirq = fwspec->param[1];
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		*type = fwspec->param[2] & IRQ_TYPE_SENSE_MASK;
+
+		/*
+		 * Make it clear that broken DTs are... broken.
+		 * Partitionned PPIs are an unfortunate exception.
+		 */
+		WARN_ON(*type == IRQ_TYPE_NONE &&
+			fwspec->param[0] != GIC_IRQ_TYPE_PARTITION);
+		return 0;
+	}
+
+	if (is_fwnode_irqchip(fwspec->fwnode)) {
+		if (fwspec->param_count != 2)
+			return -EINVAL;
+
+		*hwirq = fwspec->param[0];
+		*type = fwspec->param[1];
+
+		WARN_ON(*type == IRQ_TYPE_NONE);
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int gic_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,
+				unsigned int nr_irqs, void *arg)
+{
+	int i, ret;
+	irq_hw_number_t hwirq;
+	unsigned int type = IRQ_TYPE_NONE;
+	struct irq_fwspec *fwspec = arg;
+
+	ret = gic_irq_domain_translate(domain, fwspec, &hwirq, &type);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < nr_irqs; i++) {
+		ret = gic_irq_domain_map(domain, virq + i, hwirq + i);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static void gic_irq_domain_free(struct irq_domain *domain, unsigned int virq,
+				unsigned int nr_irqs)
+{
+	int i;
+
+	for (i = 0; i < nr_irqs; i++) {
+		struct irq_data *d = irq_domain_get_irq_data(domain, virq + i);
+		irq_set_handler(virq + i, NULL);
+		irq_domain_reset_irq_data(d);
+	}
+}
+
+static int gic_irq_domain_select(struct irq_domain *d,
+				 struct irq_fwspec *fwspec,
+				 enum irq_domain_bus_token bus_token)
+{
+	/* Not for us */
+        if (fwspec->fwnode != d->fwnode)
+		return 0;
+
+	/* If this is not DT, then we have a single domain */
+	if (!is_of_node(fwspec->fwnode))
+		return 1;
+
+	/*
+	 * If this is a PPI and we have a 4th (non-null) parameter,
+	 * then we need to match the partition domain.
+	 */
+	if (fwspec->param_count >= 4 &&
+	    fwspec->param[0] == 1 && fwspec->param[3] != 0)
+		return d == partition_get_domain(gic_data.ppi_descs[fwspec->param[1]]);
+
+	return d == gic_data.domain;
+}
+
+static const struct irq_domain_ops gic_irq_domain_ops = {
+	.translate = gic_irq_domain_translate,
+	.alloc = gic_irq_domain_alloc,
+	.free = gic_irq_domain_free,
+	.select = gic_irq_domain_select,
+};
+
+static int partition_domain_translate(struct irq_domain *d,
+				      struct irq_fwspec *fwspec,
+				      unsigned long *hwirq,
+				      unsigned int *type)
+{
+	struct device_node *np;
+	int ret;
+
+	np = of_find_node_by_phandle(fwspec->param[3]);
+	if (WARN_ON(!np))
+		return -EINVAL;
+
+	ret = partition_translate_id(gic_data.ppi_descs[fwspec->param[1]],
+				     of_node_to_fwnode(np));
+	if (ret < 0)
+		return ret;
+
+	*hwirq = ret;
+	*type = fwspec->param[2] & IRQ_TYPE_SENSE_MASK;
+
+	return 0;
+}
+
+static const struct irq_domain_ops partition_domain_ops = {
+	.translate = partition_domain_translate,
+	.select = gic_irq_domain_select,
+};
+
+static int __init gic_init_bases(void __iomem *dist_base,
+				 struct redist_region *rdist_regs,
+				 u32 nr_redist_regions,
+				 u64 redist_stride,
+				 struct fwnode_handle *handle)
+{
+	u32 typer;
+	int gic_irqs;
+	int err;
+
+	if (!is_hyp_mode_available())
+		static_branch_disable(&supports_deactivate_key);
+
+	if (static_branch_likely(&supports_deactivate_key))
+		pr_info("GIC: Using split EOI/Deactivate mode\n");
+
+	gic_data.fwnode = handle;
+	gic_data.dist_base = dist_base;
+	gic_data.redist_regions = rdist_regs;
+	gic_data.nr_redist_regions = nr_redist_regions;
+	gic_data.redist_stride = redist_stride;
+
+	/*
+	 * Find out how many interrupts are supported.
+	 * The GIC only supports up to 1020 interrupt sources (SGI+PPI+SPI)
+	 */
+	typer = readl_relaxed(gic_data.dist_base + GICD_TYPER);
+	gic_data.rdists.gicd_typer = typer;
+	gic_irqs = GICD_TYPER_IRQS(typer);
+	if (gic_irqs > 1020)
+		gic_irqs = 1020;
+	gic_data.irq_nr = gic_irqs;
+
+	gic_data.domain = irq_domain_create_tree(handle, &gic_irq_domain_ops,
+						 &gic_data);
+	irq_domain_update_bus_token(gic_data.domain, DOMAIN_BUS_WIRED);
+	gic_data.rdists.rdist = alloc_percpu(typeof(*gic_data.rdists.rdist));
+	gic_data.rdists.has_vlpis = true;
+	gic_data.rdists.has_direct_lpi = true;
+
+	if (WARN_ON(!gic_data.domain) || WARN_ON(!gic_data.rdists.rdist)) {
+		err = -ENOMEM;
+		goto out_free;
+	}
+
+	gic_data.has_rss = !!(typer & GICD_TYPER_RSS);
+	pr_info("Distributor has %sRange Selector support\n",
+		gic_data.has_rss ? "" : "no ");
+
+	set_handle_irq(gic_handle_irq);
+
+	gic_update_vlpi_properties();
+
+	gic_smp_init();
+	gic_dist_init();
+	gic_cpu_init();
+	gic_cpu_pm_init();
+
+	if (gic_dist_supports_lpis()) {
+		phytium_its_init(handle, &gic_data.rdists, gic_data.domain);
+		phytium_its_cpu_init();
+	}
+
+	return 0;
+
+out_free:
+	if (gic_data.domain)
+		irq_domain_remove(gic_data.domain);
+	free_percpu(gic_data.rdists.rdist);
+	return err;
+}
+
+static int __init gic_validate_dist_version(void __iomem *dist_base)
+{
+	u32 reg = readl_relaxed(dist_base + GICD_PIDR2) & GIC_PIDR2_ARCH_MASK;
+
+	if (reg != GIC_PIDR2_ARCH_GICv3 && reg != GIC_PIDR2_ARCH_GICv4)
+		return -ENODEV;
+
+	return 0;
+}
+
+/* Create all possible partitions at boot time */
+static void __init gic_populate_ppi_partitions(struct device_node *gic_node)
+{
+	struct device_node *parts_node, *child_part;
+	int part_idx = 0, i;
+	int nr_parts;
+	struct partition_affinity *parts;
+
+	parts_node = of_get_child_by_name(gic_node, "ppi-partitions");
+	if (!parts_node)
+		return;
+
+	nr_parts = of_get_child_count(parts_node);
+
+	if (!nr_parts)
+		goto out_put_node;
+
+	parts = kcalloc(nr_parts, sizeof(*parts), GFP_KERNEL);
+	if (WARN_ON(!parts))
+		goto out_put_node;
+
+	for_each_child_of_node(parts_node, child_part) {
+		struct partition_affinity *part;
+		int n;
+
+		part = &parts[part_idx];
+
+		part->partition_id = of_node_to_fwnode(child_part);
+
+		pr_info("GIC: PPI partition %s[%d] { ",
+			child_part->name, part_idx);
+
+		n = of_property_count_elems_of_size(child_part, "affinity",
+						    sizeof(u32));
+		WARN_ON(n <= 0);
+
+		for (i = 0; i < n; i++) {
+			int err, cpu;
+			u32 cpu_phandle;
+			struct device_node *cpu_node;
+
+			err = of_property_read_u32_index(child_part, "affinity",
+							 i, &cpu_phandle);
+			if (WARN_ON(err))
+				continue;
+
+			cpu_node = of_find_node_by_phandle(cpu_phandle);
+			if (WARN_ON(!cpu_node))
+				continue;
+
+			cpu = of_cpu_node_to_id(cpu_node);
+			if (WARN_ON(cpu < 0))
+				continue;
+
+			pr_cont("%pOF[%d] ", cpu_node, cpu);
+
+			cpumask_set_cpu(cpu, &part->mask);
+		}
+
+		pr_cont("}\n");
+		part_idx++;
+	}
+
+	for (i = 0; i < 16; i++) {
+		unsigned int irq;
+		struct partition_desc *desc;
+		struct irq_fwspec ppi_fwspec = {
+			.fwnode		= gic_data.fwnode,
+			.param_count	= 3,
+			.param		= {
+				[0]	= GIC_IRQ_TYPE_PARTITION,
+				[1]	= i,
+				[2]	= IRQ_TYPE_NONE,
+			},
+		};
+
+		irq = irq_create_fwspec_mapping(&ppi_fwspec);
+		if (WARN_ON(!irq))
+			continue;
+		desc = partition_create_desc(gic_data.fwnode, parts, nr_parts,
+					     irq, &partition_domain_ops);
+		if (WARN_ON(!desc))
+			continue;
+
+		gic_data.ppi_descs[i] = desc;
+	}
+
+out_put_node:
+	of_node_put(parts_node);
+}
+
+static void __init gic_of_setup_kvm_info(struct device_node *node)
+{
+	int ret;
+	struct resource r;
+	u32 gicv_idx;
+
+	gic_v3_kvm_info.type = GIC_V3;
+
+	gic_v3_kvm_info.maint_irq = irq_of_parse_and_map(node, 0);
+	if (!gic_v3_kvm_info.maint_irq)
+		return;
+
+	if (of_property_read_u32(node, "#redistributor-regions",
+				 &gicv_idx))
+		gicv_idx = 1;
+
+	gicv_idx += 3;	/* Also skip GICD, GICC, GICH */
+	ret = of_address_to_resource(node, gicv_idx, &r);
+	if (!ret)
+		gic_v3_kvm_info.vcpu = r;
+
+	gic_v3_kvm_info.has_v4 = gic_data.rdists.has_vlpis;
+	gic_set_kvm_info(&gic_v3_kvm_info);
+}
+
+static int __init gic_of_init(struct device_node *node, struct device_node *parent)
+{
+	void __iomem *dist_base;
+	struct redist_region *rdist_regs;
+	u64 redist_stride;
+	u32 nr_redist_regions;
+	int err, i, skt;
+	struct resource res;
+
+	dist_base = of_iomap(node, 0);
+	if (!dist_base) {
+		pr_err("%pOF: unable to map gic dist registers\n", node);
+		return -ENXIO;
+	}
+
+	err = gic_validate_dist_version(dist_base);
+	if (err) {
+		pr_err("%pOF: no distributor detected, giving up\n", node);
+		goto out_unmap_dist;
+	}
+
+	if (of_address_to_resource(node, 0, &res)) {
+		printk("Error: No GIC Distributor in FDT\n");
+		goto out_unmap_dist;
+	}
+
+	mars3_gic_dists[0].phys_base = res.start;
+	mars3_gic_dists[0].size =  resource_size(&res);
+	mars3_gic_dists[0].dist_base = dist_base;
+
+	if (of_property_read_u32(node, "#mars3-soc-bitmap", &mars3_sockets_bitmap))
+		mars3_sockets_bitmap = 0x1;
+
+	for (skt = 1; skt < MAX_MARS3_SOC_COUNT; skt++) {
+		if ((((unsigned int)1 << skt) & mars3_sockets_bitmap) == 0)
+			continue;
+
+		mars3_gic_dists[skt].phys_base = ((unsigned long)skt << MARS3_ADDR_SKTID_SHIFT) |
+						 mars3_gic_dists[0].phys_base;
+		mars3_gic_dists[skt].size =  mars3_gic_dists[0].size;
+		mars3_gic_dists[skt].dist_base = ioremap(mars3_gic_dists[skt].phys_base,
+							 mars3_gic_dists[skt].size);
+	}
+
+	if (of_property_read_u32(node, "#redistributor-regions", &nr_redist_regions))
+		nr_redist_regions = 1;
+
+	rdist_regs = kcalloc(nr_redist_regions, sizeof(*rdist_regs),
+			     GFP_KERNEL);
+	if (!rdist_regs) {
+		err = -ENOMEM;
+		goto out_unmap_dist;
+	}
+
+	for (i = 0; i < nr_redist_regions; i++) {
+		struct resource res;
+		int ret;
+
+		ret = of_address_to_resource(node, 1 + i, &res);
+		rdist_regs[i].redist_base = of_iomap(node, 1 + i);
+		if (ret || !rdist_regs[i].redist_base) {
+			pr_err("%pOF: couldn't map region %d\n", node, i);
+			err = -ENODEV;
+			goto out_unmap_rdist;
+		}
+		rdist_regs[i].phys_base = res.start;
+	}
+
+	if (of_property_read_u64(node, "redistributor-stride", &redist_stride))
+		redist_stride = 0;
+
+	err = gic_init_bases(dist_base, rdist_regs, nr_redist_regions,
+			     redist_stride, &node->fwnode);
+	if (err)
+		goto out_unmap_rdist;
+
+	gic_populate_ppi_partitions(node);
+
+	if (static_branch_likely(&supports_deactivate_key))
+		gic_of_setup_kvm_info(node);
+	return 0;
+
+out_unmap_rdist:
+	for (i = 0; i < nr_redist_regions; i++)
+		if (rdist_regs[i].redist_base)
+			iounmap(rdist_regs[i].redist_base);
+	kfree(rdist_regs);
+out_unmap_dist:
+	iounmap(dist_base);
+	return err;
+}
+
+IRQCHIP_DECLARE(gic_phyt_2500, "arm,gic-phytium-2500", gic_of_init);
+
+#ifdef CONFIG_ACPI
+static struct
+{
+	void __iomem *dist_base;
+	struct redist_region *redist_regs;
+	u32 nr_redist_regions;
+	bool single_redist;
+	u32 maint_irq;
+	int maint_irq_mode;
+	phys_addr_t vcpu_base;
+} acpi_data __initdata;
+
+static int gic_mars3_sockets_bitmap(void)
+{
+	unsigned int skt, i;
+	int skt_bitmap = 0;
+	unsigned int skt_cpu_cnt[MAX_MARS3_SOC_COUNT] = {0};
+
+	for (i = 0; i < max_t(unsigned int, nr_cpu_ids, NR_CPUS); i++) {
+		skt = (cpu_logical_map(i) >> 16) & 0xff;
+		if ((skt >= 0) && (skt < MAX_MARS3_SOC_COUNT))
+			skt_cpu_cnt[skt]++;
+		else if (skt != 0xff)
+			pr_err("socket address: %d is out of range.", skt);
+	}
+
+	for (i = 0; i < MAX_MARS3_SOC_COUNT; i++) {
+		if (skt_cpu_cnt[i] > 0)
+			skt_bitmap |= (1 << i);
+	}
+
+	return skt_bitmap;
+}
+
+static void __init
+gic_acpi_register_redist(phys_addr_t phys_base, void __iomem *redist_base)
+{
+	static int count = 0;
+
+	acpi_data.redist_regs[count].phys_base = phys_base;
+	acpi_data.redist_regs[count].redist_base = redist_base;
+	acpi_data.redist_regs[count].single_redist = acpi_data.single_redist;
+	count++;
+}
+
+static int __init
+gic_acpi_parse_madt_redist(union acpi_subtable_headers *header,
+			   const unsigned long end)
+{
+	struct acpi_madt_generic_redistributor *redist =
+			(struct acpi_madt_generic_redistributor *)header;
+	void __iomem *redist_base;
+
+	redist_base = ioremap(redist->base_address, redist->length);
+	if (!redist_base) {
+		pr_err("Couldn't map GICR region @%llx\n", redist->base_address);
+		return -ENOMEM;
+	}
+
+	gic_acpi_register_redist(redist->base_address, redist_base);
+	return 0;
+}
+
+static int __init
+gic_acpi_parse_madt_gicc(union acpi_subtable_headers *header,
+			 const unsigned long end)
+{
+	struct acpi_madt_generic_interrupt *gicc =
+				(struct acpi_madt_generic_interrupt *)header;
+	u32 reg = readl_relaxed(acpi_data.dist_base + GICD_PIDR2) & GIC_PIDR2_ARCH_MASK;
+	u32 size = reg == GIC_PIDR2_ARCH_GICv4 ? SZ_64K * 4 : SZ_64K * 2;
+	void __iomem *redist_base;
+
+	/* GICC entry which has !ACPI_MADT_ENABLED is not unusable so skip */
+	if (!(gicc->flags & ACPI_MADT_ENABLED))
+		return 0;
+
+	redist_base = ioremap(gicc->gicr_base_address, size);
+	if (!redist_base)
+		return -ENOMEM;
+
+	gic_acpi_register_redist(gicc->gicr_base_address, redist_base);
+	return 0;
+}
+
+static int __init gic_acpi_collect_gicr_base(void)
+{
+	acpi_tbl_entry_handler redist_parser;
+	enum acpi_madt_type type;
+
+	if (acpi_data.single_redist) {
+		type = ACPI_MADT_TYPE_GENERIC_INTERRUPT;
+		redist_parser = gic_acpi_parse_madt_gicc;
+	} else {
+		type = ACPI_MADT_TYPE_GENERIC_REDISTRIBUTOR;
+		redist_parser = gic_acpi_parse_madt_redist;
+	}
+
+	/* Collect redistributor base addresses in GICR entries */
+	if (acpi_table_parse_madt(type, redist_parser, 0) > 0)
+		return 0;
+
+	pr_info("No valid GICR entries exist\n");
+	return -ENODEV;
+}
+
+static int __init gic_acpi_match_gicr(union acpi_subtable_headers *header,
+				  const unsigned long end)
+{
+	/* Subtable presence means that redist exists, that's it */
+	return 0;
+}
+
+static int __init gic_acpi_match_gicc(union acpi_subtable_headers *header,
+				      const unsigned long end)
+{
+	struct acpi_madt_generic_interrupt *gicc =
+				(struct acpi_madt_generic_interrupt *)header;
+
+	/*
+	 * If GICC is enabled and has valid gicr base address, then it means
+	 * GICR base is presented via GICC
+	 */
+	if ((gicc->flags & ACPI_MADT_ENABLED) && gicc->gicr_base_address)
+		return 0;
+
+	/*
+	 * It's perfectly valid firmware can pass disabled GICC entry, driver
+	 * should not treat as errors, skip the entry instead of probe fail.
+	 */
+	if (!(gicc->flags & ACPI_MADT_ENABLED))
+		return 0;
+
+	return -ENODEV;
+}
+
+static int __init gic_acpi_count_gicr_regions(void)
+{
+	int count;
+
+	/*
+	 * Count how many redistributor regions we have. It is not allowed
+	 * to mix redistributor description, GICR and GICC subtables have to be
+	 * mutually exclusive.
+	 */
+	count = acpi_table_parse_madt(ACPI_MADT_TYPE_GENERIC_REDISTRIBUTOR,
+				      gic_acpi_match_gicr, 0);
+	if (count > 0) {
+		acpi_data.single_redist = false;
+		return count;
+	}
+
+	count = acpi_table_parse_madt(ACPI_MADT_TYPE_GENERIC_INTERRUPT,
+				      gic_acpi_match_gicc, 0);
+	if (count > 0)
+		acpi_data.single_redist = true;
+
+	return count;
+}
+
+static bool __init acpi_validate_gic_table(struct acpi_subtable_header *header,
+					   struct acpi_probe_entry *ape)
+{
+	struct acpi_madt_generic_distributor *dist;
+	int count;
+
+	dist = (struct acpi_madt_generic_distributor *)header;
+	if (dist->version != ape->driver_data)
+		return false;
+
+	/* We need to do that exercise anyway, the sooner the better */
+	count = gic_acpi_count_gicr_regions();
+	if (count <= 0)
+		return false;
+
+	acpi_data.nr_redist_regions = count;
+	return true;
+}
+
+static int __init gic_acpi_parse_virt_madt_gicc(union acpi_subtable_headers *header,
+						const unsigned long end)
+{
+	struct acpi_madt_generic_interrupt *gicc =
+		(struct acpi_madt_generic_interrupt *)header;
+	int maint_irq_mode;
+	static int first_madt = true;
+
+	/* Skip unusable CPUs */
+	if (!(gicc->flags & ACPI_MADT_ENABLED))
+		return 0;
+
+	maint_irq_mode = (gicc->flags & ACPI_MADT_VGIC_IRQ_MODE) ?
+		ACPI_EDGE_SENSITIVE : ACPI_LEVEL_SENSITIVE;
+
+	if (first_madt) {
+		first_madt = false;
+
+		acpi_data.maint_irq = gicc->vgic_interrupt;
+		acpi_data.maint_irq_mode = maint_irq_mode;
+		acpi_data.vcpu_base = gicc->gicv_base_address;
+
+		return 0;
+	}
+
+	/*
+	 * The maintenance interrupt and GICV should be the same for every CPU
+	 */
+	if ((acpi_data.maint_irq != gicc->vgic_interrupt) ||
+	    (acpi_data.maint_irq_mode != maint_irq_mode) ||
+	    (acpi_data.vcpu_base != gicc->gicv_base_address))
+		return -EINVAL;
+
+	return 0;
+}
+
+static bool __init gic_acpi_collect_virt_info(void)
+{
+	int count;
+
+	count = acpi_table_parse_madt(ACPI_MADT_TYPE_GENERIC_INTERRUPT,
+				      gic_acpi_parse_virt_madt_gicc, 0);
+
+	return (count > 0);
+}
+
+#define ACPI_GICV3_DIST_MEM_SIZE (SZ_64K)
+#define ACPI_GICV2_VCTRL_MEM_SIZE	(SZ_4K)
+#define ACPI_GICV2_VCPU_MEM_SIZE	(SZ_8K)
+
+static void __init gic_acpi_setup_kvm_info(void)
+{
+	int irq;
+
+	if (!gic_acpi_collect_virt_info()) {
+		pr_warn("Unable to get hardware information used for virtualization\n");
+		return;
+	}
+
+	gic_v3_kvm_info.type = GIC_V3;
+
+	irq = acpi_register_gsi(NULL, acpi_data.maint_irq,
+				acpi_data.maint_irq_mode,
+				ACPI_ACTIVE_HIGH);
+	if (irq <= 0)
+		return;
+
+	gic_v3_kvm_info.maint_irq = irq;
+
+	if (acpi_data.vcpu_base) {
+		struct resource *vcpu = &gic_v3_kvm_info.vcpu;
+
+		vcpu->flags = IORESOURCE_MEM;
+		vcpu->start = acpi_data.vcpu_base;
+		vcpu->end = vcpu->start + ACPI_GICV2_VCPU_MEM_SIZE - 1;
+	}
+
+	gic_v3_kvm_info.has_v4 = gic_data.rdists.has_vlpis;
+	gic_set_kvm_info(&gic_v3_kvm_info);
+}
+
+static int __init
+gic_acpi_init(union acpi_subtable_headers *header, const unsigned long end)
+{
+	struct acpi_madt_generic_distributor *dist;
+	struct fwnode_handle *domain_handle;
+	size_t size;
+	int i, err, skt;
+
+	/* Get distributor base address */
+	dist = (struct acpi_madt_generic_distributor *)header;
+	acpi_data.dist_base = ioremap(dist->base_address,
+				      ACPI_GICV3_DIST_MEM_SIZE);
+	if (!acpi_data.dist_base) {
+		pr_err("Unable to map GICD registers\n");
+		return -ENOMEM;
+	}
+
+	err = gic_validate_dist_version(acpi_data.dist_base);
+	if (err) {
+		pr_err("No distributor detected at @%p, giving up\n",
+		       acpi_data.dist_base);
+		goto out_dist_unmap;
+	}
+
+	mars3_gic_dists[0].phys_base = dist->base_address;
+	mars3_gic_dists[0].size =  ACPI_GICV3_DIST_MEM_SIZE;
+	mars3_gic_dists[0].dist_base = acpi_data.dist_base;
+
+	mars3_sockets_bitmap = gic_mars3_sockets_bitmap();
+	if (mars3_sockets_bitmap == 0) {
+		mars3_sockets_bitmap = 0x1;
+		pr_err("No socket, please check cpus MPIDR_AFFINITY_LEVEL!");
+	} else
+		pr_info("mars3_sockets_bitmap = 0x%x\n", mars3_sockets_bitmap);
+
+	for (skt = 1; skt < MAX_MARS3_SOC_COUNT; skt++) {
+		if ((((unsigned int)1 << skt) & mars3_sockets_bitmap) == 0)
+			continue;
+
+		mars3_gic_dists[skt].phys_base = ((unsigned long)skt << MARS3_ADDR_SKTID_SHIFT) |
+						 mars3_gic_dists[0].phys_base;
+		mars3_gic_dists[skt].size =  mars3_gic_dists[0].size;
+		mars3_gic_dists[skt].dist_base = ioremap(mars3_gic_dists[skt].phys_base,
+							 mars3_gic_dists[skt].size);
+	}
+
+	size = sizeof(*acpi_data.redist_regs) * acpi_data.nr_redist_regions;
+	acpi_data.redist_regs = kzalloc(size, GFP_KERNEL);
+	if (!acpi_data.redist_regs) {
+		err = -ENOMEM;
+		goto out_dist_unmap;
+	}
+
+	err = gic_acpi_collect_gicr_base();
+	if (err)
+		goto out_redist_unmap;
+
+	domain_handle = irq_domain_alloc_fwnode(acpi_data.dist_base);
+	if (!domain_handle) {
+		err = -ENOMEM;
+		goto out_redist_unmap;
+	}
+
+	err = gic_init_bases(acpi_data.dist_base, acpi_data.redist_regs,
+			     acpi_data.nr_redist_regions, 0, domain_handle);
+	if (err)
+		goto out_fwhandle_free;
+
+	acpi_set_irq_model(ACPI_IRQ_MODEL_GIC, domain_handle);
+
+	if (static_branch_likely(&supports_deactivate_key))
+		gic_acpi_setup_kvm_info();
+
+	return 0;
+
+out_fwhandle_free:
+	irq_domain_free_fwnode(domain_handle);
+out_redist_unmap:
+	for (i = 0; i < acpi_data.nr_redist_regions; i++)
+		if (acpi_data.redist_regs[i].redist_base)
+			iounmap(acpi_data.redist_regs[i].redist_base);
+	kfree(acpi_data.redist_regs);
+out_dist_unmap:
+	iounmap(acpi_data.dist_base);
+	return err;
+}
+IRQCHIP_ACPI_DECLARE(gic_phyt_2500, ACPI_MADT_TYPE_PHYTIUM_2500,
+		     acpi_validate_gic_table, ACPI_MADT_GIC_VERSION_V3,
+		     gic_acpi_init);
+#endif
diff --git a/drivers/irqchip/irq-phytium-ixic.c b/drivers/irqchip/irq-phytium-ixic.c
new file mode 100644
index 000000000000..8b33c88eba71
--- /dev/null
+++ b/drivers/irqchip/irq-phytium-ixic.c
@@ -0,0 +1,266 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for Phytium D2000 PCIe legacy INTx interrupt controller
+ *
+ * Copyright (c) 2020 Phytium Technology Co., Ltd.
+ *
+ * Author: Chen Baozi <chenbaozi@phytium.com.cn>
+ */
+
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqdomain.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+
+#define NUM_IRQS		4
+
+#define CTR_BANK_NUM		6
+#define CTR_BANK_SIZE		0x10000
+#define CTR_BANK_ISTATUS_LOCAL	0x184
+
+#define HPB_INTX_STATUS_0	0x0
+#define HPB_INTX_STATUS_1	0x1000
+
+struct ixic_irq_data {
+	void __iomem *ctr;
+	void __iomem *hpb;
+	u32 spi_base;
+};
+
+static void phytium_ixic_irq_eoi(struct irq_data *d)
+{
+	struct ixic_irq_data *data = irq_data_get_irq_chip_data(d);
+	unsigned int intx = irqd_to_hwirq(d);
+	u32 gstatus = readl(data->hpb) | (readl(data->hpb + HPB_INTX_STATUS_1) << 12);
+	u32 imask, istatus;
+	int i;
+
+	WARN_ON(intx >= NUM_IRQS);
+	imask = 1 << (3 - intx);
+	istatus = (1 << intx) << 24;
+	for (i = 0; i < CTR_BANK_NUM; i++, gstatus >>= 4) {
+		if (gstatus & imask)
+			writel(istatus, data->ctr + CTR_BANK_SIZE*i + CTR_BANK_ISTATUS_LOCAL);
+	}
+
+	irq_chip_eoi_parent(d);
+}
+
+static struct irq_chip phytium_ixic_irq_chip = {
+	.name = "IXIU",
+	.irq_eoi = phytium_ixic_irq_eoi,
+	.irq_mask = irq_chip_mask_parent,
+	.irq_unmask = irq_chip_unmask_parent,
+	.irq_set_type = irq_chip_set_type_parent,
+	.irq_set_affinity = irq_chip_set_affinity_parent,
+	.flags = IRQCHIP_MASK_ON_SUSPEND,
+};
+
+static int phytium_ixic_translate(struct irq_domain *domain,
+				  struct irq_fwspec *fwspec,
+				  unsigned long *hwirq,
+				  unsigned int *type)
+{
+	struct ixic_irq_data *info = domain->host_data;
+
+	if (is_of_node(fwspec->fwnode)) {
+		if (fwspec->param_count != 3)
+			return -EINVAL;
+
+		if (fwspec->param[0] != GIC_SPI)
+			return -EINVAL; /* No PPI should point to this domain */
+
+		*hwirq = fwspec->param[1] - info->spi_base;
+		*type = fwspec->param[2] & IRQ_TYPE_SENSE_MASK;
+	} else {
+		if (fwspec->param_count != 2)
+			return -EINVAL;
+		*hwirq = fwspec->param[0] - info->spi_base;
+		*type = fwspec->param[1] & IRQ_TYPE_SENSE_MASK;
+	}
+
+	return 0;
+}
+
+static int phytium_ixic_alloc(struct irq_domain *dom, unsigned int virq,
+			      unsigned int nr_irqs, void *data)
+{
+	struct irq_fwspec *fwspec = data;
+	struct irq_fwspec parent_fwspec;
+	struct ixic_irq_data *info = dom->host_data;
+	irq_hw_number_t hwirq;
+
+	/* We assume the device use the parent's format directly */
+	parent_fwspec = *fwspec;
+	if (is_of_node(dom->parent->fwnode)) {
+		if (fwspec->param_count != 3)
+			return -EINVAL; /* Not GIC compliant */
+		if (fwspec->param[0] != GIC_SPI)
+			return -EINVAL; /* No PPI should point to this domain */
+
+		/* Get the local hwirq of IXIC */
+		hwirq = fwspec->param[1] - info->spi_base;
+	} else {
+		hwirq = fwspec->param[0] - info->spi_base;
+	}
+	WARN_ON(nr_irqs != 1);
+	irq_domain_set_hwirq_and_chip(dom, virq, hwirq, &phytium_ixic_irq_chip, info);
+
+	parent_fwspec.fwnode = dom->parent->fwnode;
+	return irq_domain_alloc_irqs_parent(dom, virq, nr_irqs, &parent_fwspec);
+}
+
+static const struct irq_domain_ops ixic_domain_ops = {
+	.translate = phytium_ixic_translate,
+	.alloc	= phytium_ixic_alloc,
+	.free	= irq_domain_free_irqs_common,
+};
+
+static struct ixic_irq_data *phytium_ixic_init(const struct fwnode_handle *fwnode,
+					      struct resource *ctr, struct resource *hpb)
+{
+	struct ixic_irq_data *data;
+	int err;
+
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return ERR_PTR(-ENOMEM);
+
+	if (fwnode_property_read_u32_array(fwnode, "intx-spi-base",
+					   &data->spi_base, 1)) {
+		err = -ENODEV;
+		goto out_free;
+	}
+
+	data->ctr = ioremap(ctr->start, resource_size(ctr));
+	if (!data->ctr) {
+		err = -ENODEV;
+		goto out_free;
+	}
+
+	data->hpb = ioremap(hpb->start, resource_size(hpb));
+	if (!data->hpb) {
+		err = -ENODEV;
+		goto out_free;
+	}
+
+	return data;
+
+out_free:
+	kfree(data);
+	return ERR_PTR(err);
+}
+
+static int __init phytium_ixic_dt_init(struct device_node *node,
+				   struct device_node *parent)
+{
+	struct irq_domain *pd, *d;
+	struct ixic_irq_data *data;
+	struct resource ctr, hpb;
+
+	if (!parent) {
+		pr_err("%pOF: no parent, giving up\n", node);
+		return -ENODEV;
+	}
+
+	pd = irq_find_host(parent);
+	if (!pd) {
+		pr_err("%pOF: unable to obtain parent domain\n", node);
+		return -ENXIO;
+	}
+
+	if (of_address_to_resource(node, 0, &ctr)) {
+		pr_err("%pOF: failed to parse 'ctr' memory resource\n", node);
+		return -ENXIO;
+	}
+
+	if (of_address_to_resource(node, 1, &hpb)) {
+		pr_err("%pOF: failed to parse 'hpb' memory resource\n", node);
+		return -ENXIO;
+	}
+
+	data = phytium_ixic_init(of_node_to_fwnode(node), &ctr, &hpb);
+	if (IS_ERR(data))
+		return PTR_ERR(data);
+
+	d = irq_domain_add_hierarchy(pd, 0, NUM_IRQS, node, &ixic_domain_ops, data);
+	if (!d) {
+		pr_err("%pOF: failed to allocate domain\n", node);
+		goto out_unmap;
+	}
+
+	pr_info("%pOF: %d interrupts forwarded to %pOF\n", node, NUM_IRQS, parent);
+
+	return 0;
+
+out_unmap:
+	iounmap(data->ctr);
+	iounmap(data->hpb);
+	kfree(data);
+	return -ENOMEM;
+}
+IRQCHIP_DECLARE(ixic, "phytium,d2000-ixic", phytium_ixic_dt_init);
+
+#ifdef CONFIG_ACPI
+static int phytium_ixic_acpi_probe(struct platform_device *pdev)
+{
+	struct irq_domain *domain;
+	struct ixic_irq_data *data;
+	struct resource *ctr, *hpb;
+
+	ctr = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!ctr) {
+		dev_err(&pdev->dev, "failed to parse 'ctr' memory resource\n");
+		return -ENXIO;
+	}
+
+	hpb = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!hpb) {
+		dev_err(&pdev->dev, "failed to parse 'hpb' memory resource\n");
+		return -ENXIO;
+	}
+
+	data = phytium_ixic_init(dev_fwnode(&pdev->dev), ctr, hpb);
+	if (IS_ERR(data))
+		return PTR_ERR(data);
+
+	domain = acpi_irq_create_hierarchy(0, NUM_IRQS, dev_fwnode(&pdev->dev),
+					   &ixic_domain_ops, data);
+	if (!domain) {
+		dev_err(&pdev->dev, "failed to create IRQ domain\n");
+		goto out_unmap;
+	}
+
+	dev_info(&pdev->dev, "%d interrupts forwarded\n", NUM_IRQS);
+
+	return 0;
+
+out_unmap:
+	iounmap(data->ctr);
+	iounmap(data->hpb);
+	kfree(data);
+	return -ENOMEM;
+}
+
+static const struct acpi_device_id phytium_ixic_acpi_ids[] = {
+	{ "PHYT0013" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(acpi, phytium_ixic_acpi_ids);
+
+static struct platform_driver phytium_ixic_driver = {
+	.driver = {
+		.name = "phytium-ixic",
+		.acpi_match_table = phytium_ixic_acpi_ids,
+	},
+	.probe = phytium_ixic_acpi_probe,
+};
+builtin_platform_driver(phytium_ixic_driver);
+#endif
diff --git a/drivers/pci/controller/Kconfig b/drivers/pci/controller/Kconfig
index 64e2f5e379aa..4f2edd5ee54b 100644
--- a/drivers/pci/controller/Kconfig
+++ b/drivers/pci/controller/Kconfig
@@ -271,6 +271,16 @@ config VMD
 	  To compile this driver as a module, choose M here: the
 	  module will be called vmd.
 
+config PCIE_PHYTIUM_EP
+        tristate "Phytium PCIe endpoint controller"
+        depends on OF
+        depends on PCI_ENDPOINT
+        help
+          Say Y here if you want to support Phytium PCIe controller in
+          endpoint mode on Phytium SoC. The controller can act as Root Port
+          or End Point with different phytium firmware. But End Point mode only support
+          one physical function.
+
 config PCIE_BRCMSTB
 	tristate "Broadcom Brcmstb PCIe host controller"
 	depends on ARCH_BRCMSTB || ARCH_BCM2835 || COMPILE_TEST
diff --git a/drivers/pci/controller/Makefile b/drivers/pci/controller/Makefile
index 04c6edc285c5..1ba948a7338e 100644
--- a/drivers/pci/controller/Makefile
+++ b/drivers/pci/controller/Makefile
@@ -32,6 +32,7 @@ obj-$(CONFIG_VMD) += vmd.o
 obj-$(CONFIG_PCIE_BRCMSTB) += pcie-brcmstb.o
 obj-$(CONFIG_PCI_LOONGSON) += pci-loongson.o
 obj-$(CONFIG_PCIE_HISI_ERR) += pcie-hisi-error.o
+obj-$(CONFIG_PCIE_PHYTIUM_EP) += pcie-phytium-ep.o
 # pcie-hisi.o quirks are needed even without CONFIG_PCIE_DW
 obj-y				+= dwc/
 obj-y				+= mobiveil/
diff --git a/drivers/pci/controller/pcie-phytium-ep.c b/drivers/pci/controller/pcie-phytium-ep.c
new file mode 100755
index 000000000000..cd3dbd8b4228
--- /dev/null
+++ b/drivers/pci/controller/pcie-phytium-ep.c
@@ -0,0 +1,480 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Phytium d2000 pcie endpoint driver
+ *
+ * Copyright (c) 2021 Phytium Limited.
+ *
+ * Author:
+ *	Yang Xun <yangxun@phytium.com.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/of.h>
+#include <linux/module.h>
+#include <linux/pci-epc.h>
+#include <linux/pci-epf.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/sizes.h>
+
+#include "pcie-phytium-ep.h"
+#include "pcie-phytium-register.h"
+
+#define PHYTIUM_PCIE_EP_IRQ_PCI_ADDR_NONE	0x0
+#define PHYTIUM_PCIE_EP_IRQ_PCI_ADDR_LEGACY	0x1
+
+static int phytium_pcie_ep_write_header(struct pci_epc *epc, unsigned char fn,
+					struct pci_epf_header *hdr)
+{
+	struct phytium_pcie_ep *priv = epc_get_drvdata(epc);
+	u16 tmp = 0;
+
+	phytium_pcie_writew(priv, fn, PHYTIUM_PCI_VENDOR_ID, hdr->vendorid);
+	phytium_pcie_writew(priv, fn, PHYTIUM_PCI_DEVICE_ID, hdr->deviceid);
+	phytium_pcie_writeb(priv, fn, PHYTIUM_PCI_REVISION_ID, hdr->revid);
+	phytium_pcie_writeb(priv, fn, PHYTIUM_PCI_CLASS_PROG, hdr->progif_code);
+	phytium_pcie_writew(priv, fn, PHYTIUM_PCI_CLASS_DEVICE,
+			    hdr->subclass_code | (hdr->baseclass_code << 8));
+
+	phytium_pcie_writew(priv, fn, PHYTIUM_PCI_SUBSYS_VENDOR_ID,
+			    hdr->subsys_vendor_id);
+	phytium_pcie_writew(priv, fn, PHYTIUM_PCI_SUBSYS_DEVICE_ID,
+			    hdr->subsys_id);
+
+	tmp = phytium_pcie_readw(priv, fn, PHYTIUM_PCI_INTERRUPT_PIN);
+	tmp = ((tmp & (~INTERRUPT_PIN_MASK)) | hdr->interrupt_pin);
+	phytium_pcie_writew(priv, fn, PHYTIUM_PCI_INTERRUPT_PIN, tmp);
+
+	tmp = phytium_pcie_readw(priv, fn, PHYTIUM_PCI_MSIX_CAP);
+	phytium_pcie_writew(priv, fn, PHYTIUM_PCI_MSIX_CAP, MSIX_DISABLE);
+
+	return 0;
+}
+
+static int phytium_pcie_ep_set_bar(struct pci_epc *epc, u8 fn,
+					    struct pci_epf_bar *epf_bar)
+{
+	struct phytium_pcie_ep *priv = epc_get_drvdata(epc);
+	u64 sz = 0, sz_mask, atr_size;
+	int flags = epf_bar->flags;
+	u32 setting, src_addr0, src_addr1, trsl_addr0, trsl_addr1, trsl_param;
+	enum pci_barno barno = epf_bar->barno;
+	struct pci_epc_mem *mem = epc->mem;
+
+	if ((flags & PCI_BASE_ADDRESS_MEM_TYPE_64) && (barno & 1)) {
+		dev_err(&epc->dev, "bar %d do not support mem64\n", barno);
+		return -EINVAL;
+	}
+
+	if (barno & 1) {
+		dev_err(&epc->dev, "not support bar 1/3/5\n");
+		return -EINVAL;
+	}
+	dev_dbg(epc->dev.parent, "set bar%d mapping address 0x%pa size 0x%lx\n",
+		barno, &(epf_bar->phys_addr), epf_bar->size);
+
+	if ((flags & PCI_BASE_ADDRESS_SPACE) == PCI_BASE_ADDRESS_SPACE_IO) {
+		setting = BAR_IO_TYPE;
+		sz = max_t(size_t, epf_bar->size, BAR_IO_MIN_APERTURE);
+		sz = 1 << fls64(sz - 1);
+		sz_mask = ~(sz - 1);
+		setting |= sz_mask;
+		trsl_param = TRSL_ID_IO;
+	} else {
+		setting = BAR_MEM_TYPE;
+		sz = max_t(size_t, epf_bar->size, BAR_MEM_MIN_APERTURE);
+		sz = 1 << fls64(sz - 1);
+		sz_mask = ~(sz - 1);
+		setting |= lower_32_bits(sz_mask);
+
+		if (flags & PCI_BASE_ADDRESS_MEM_TYPE_64)
+			setting |= BAR_MEM_64BIT;
+
+		if (flags & PCI_BASE_ADDRESS_MEM_PREFETCH)
+			setting |= BAR_MEM_PREFETCHABLE;
+
+		trsl_param = TRSL_ID_MASTER;
+	}
+
+	phytium_pcie_writel(priv, fn, PHYTIUM_PCI_BAR(barno), setting);
+	if (flags & PCI_BASE_ADDRESS_MEM_TYPE_64)
+		phytium_pcie_writel(priv, fn, PHYTIUM_PCI_BAR(barno + 1),
+				    upper_32_bits(sz_mask));
+	dev_dbg(epc->dev.parent, "set bar%d mapping address 0x%pa size 0x%llx 0x%x\n",
+		barno, &(epf_bar->phys_addr), sz, lower_32_bits(epf_bar->phys_addr));
+	sz = ALIGN(sz, mem->window.page_size);
+	atr_size = fls64(sz - 1) - 1;
+	src_addr0 = ATR_IMPL | ((atr_size & ATR_SIZE_MASK) << ATR_SIZE_SHIFT);
+	src_addr1 = 0;
+	trsl_addr0 = (lower_32_bits(epf_bar->phys_addr) & TRSL_ADDR_32_12_MASK);
+	trsl_addr1 = upper_32_bits(epf_bar->phys_addr);
+
+	phytium_pcie_writel(priv, fn, PHYTIUM_PCI_WIN0_SRC_ADDR0(barno),
+			    src_addr0);
+	phytium_pcie_writel(priv, fn, PHYTIUM_PCI_WIN0_SRC_ADDR1(barno),
+			    src_addr1);
+	phytium_pcie_writel(priv, fn, PHYTIUM_PCI_WIN0_TRSL_ADDR0(barno),
+			    trsl_addr0);
+	phytium_pcie_writel(priv, fn, PHYTIUM_PCI_WIN0_TRSL_ADDR1(barno),
+			    trsl_addr1);
+	phytium_pcie_writel(priv, fn, PHYTIUM_PCI_WIN0_TRSL_PARAM(barno),
+			    trsl_param);
+
+	return 0;
+}
+
+static void phytium_pcie_ep_clear_bar(struct pci_epc *epc, u8 fn,
+					       struct pci_epf_bar *epf_bar)
+{
+	struct phytium_pcie_ep *priv = epc_get_drvdata(epc);
+	int flags = epf_bar->flags;
+	enum pci_barno barno = epf_bar->barno;
+
+	phytium_pcie_writel(priv, fn, PHYTIUM_PCI_BAR(barno), 0);
+	if (flags & PCI_BASE_ADDRESS_MEM_TYPE_64)
+		phytium_pcie_writel(priv, fn, PHYTIUM_PCI_BAR(barno + 1), 0);
+
+	phytium_pcie_writel(priv, fn, PHYTIUM_PCI_WIN0_SRC_ADDR0(barno), 0);
+	phytium_pcie_writel(priv, fn, PHYTIUM_PCI_WIN0_SRC_ADDR1(barno), 0);
+	phytium_pcie_writel(priv, fn, PHYTIUM_PCI_WIN0_TRSL_ADDR0(barno), 0);
+	phytium_pcie_writel(priv, fn, PHYTIUM_PCI_WIN0_TRSL_ADDR1(barno), 0);
+	phytium_pcie_writel(priv, fn, PHYTIUM_PCI_WIN0_TRSL_PARAM(barno), 0);
+}
+
+static int phytium_pcie_ep_map_addr(struct pci_epc *epc, u8 fn,
+				    phys_addr_t addr, u64 pci_addr,
+				    size_t size)
+{
+	struct phytium_pcie_ep *priv = epc_get_drvdata(epc);
+	u32 src_addr0, src_addr1, trsl_addr0, trsl_addr1, trsl_param, atr_size;
+	u64 sz = 0;
+	u32 r;
+	struct pci_epc_mem *mem = epc->mem;
+
+	r = find_first_zero_bit(&priv->ob_region_map,
+				sizeof(priv->ob_region_map) * BITS_PER_LONG);
+	if (r >= priv->max_regions) {
+		dev_err(&epc->dev, "no free outbound region\n");
+		return -EINVAL;
+	}
+
+	dev_dbg(epc->dev.parent, "set slave %d: mapping address 0x%pa to pci 0x%llx, size 0x%zx\n",
+		r, &addr, pci_addr, size);
+
+	sz = ALIGN(size, mem->window.page_size);
+	atr_size = fls64(sz - 1) - 1;
+	src_addr0 = ATR_IMPL | ((atr_size & ATR_SIZE_MASK) << ATR_SIZE_SHIFT);
+	src_addr0 |= (lower_32_bits(addr) & SRC_ADDR_32_12_MASK);
+	src_addr1 = upper_32_bits(addr);
+	trsl_addr0 = (lower_32_bits(pci_addr) & TRSL_ADDR_32_12_MASK);
+	trsl_addr1 = upper_32_bits(pci_addr);
+	trsl_param = TRSL_ID_PCIE_TR;
+
+	phytium_pcie_writel(priv, fn, PHYTIUM_PCI_SLAVE0_SRC_ADDR0(r),
+			    src_addr0);
+	phytium_pcie_writel(priv, fn, PHYTIUM_PCI_SLAVE0_SRC_ADDR1(r),
+			    src_addr1);
+	phytium_pcie_writel(priv, fn, PHYTIUM_PCI_SLAVE0_TRSL_ADDR0(r),
+			    trsl_addr0);
+	phytium_pcie_writel(priv, fn, PHYTIUM_PCI_SLAVE0_TRSL_ADDR1(r),
+			    trsl_addr1);
+	phytium_pcie_writel(priv, fn, PHYTIUM_PCI_SLAVE0_TRSL_PARAM(r),
+			    trsl_param);
+	set_bit(r, &priv->ob_region_map);
+	priv->ob_addr[r] = addr;
+
+	return 0;
+}
+
+static void phytium_pcie_ep_unmap_addr(struct pci_epc *epc, u8 fn,
+				       phys_addr_t addr)
+{
+	struct phytium_pcie_ep *priv = epc_get_drvdata(epc);
+	u32 r;
+
+	for (r = 0; r < priv->max_regions; r++)
+		if (priv->ob_addr[r] == addr)
+			break;
+
+	if (r == priv->max_regions) {
+		dev_err(&epc->dev, "used unmap addr 0x%pa\n", &addr);
+		return;
+	}
+	dev_dbg(epc->dev.parent, "set slave %d: unmapping address 0x%pa\n",  r, &addr);
+
+	phytium_pcie_writel(priv, fn, PHYTIUM_PCI_SLAVE0_SRC_ADDR0(r), 0);
+	phytium_pcie_writel(priv, fn, PHYTIUM_PCI_SLAVE0_SRC_ADDR1(r), 0);
+	phytium_pcie_writel(priv, fn, PHYTIUM_PCI_SLAVE0_TRSL_ADDR0(r), 0);
+	phytium_pcie_writel(priv, fn, PHYTIUM_PCI_SLAVE0_TRSL_ADDR1(r), 0);
+	phytium_pcie_writel(priv, fn, PHYTIUM_PCI_SLAVE0_TRSL_PARAM(r), 0);
+	priv->ob_addr[r] = 0;
+	clear_bit(r, &priv->ob_region_map);
+}
+
+static int phytium_pcie_ep_set_msi(struct pci_epc *epc, u8 fn, u8 mmc)
+{
+	struct phytium_pcie_ep *priv = epc_get_drvdata(epc);
+	u16 flags = 0;
+
+	flags = (mmc & MSI_NUM_MASK) << MSI_NUM_SHIFT;
+	flags &= ~MSI_MASK_SUPPORT;
+	phytium_pcie_writew(priv, fn, PHYTIUM_PCI_INTERRUPT_PIN, flags);
+
+	return 0;
+}
+
+static int phytium_pcie_ep_get_msi(struct pci_epc *epc, u8 fn)
+{
+	struct phytium_pcie_ep *priv = epc_get_drvdata(epc);
+	u16 flags, mme;
+	u32 cap = PHYTIUM_PCI_CF_MSI_BASE;
+
+	flags = phytium_pcie_readw(priv, fn, cap + PCI_MSI_FLAGS);
+	if (!(flags & PCI_MSI_FLAGS_ENABLE))
+		return -EINVAL;
+
+	mme = (flags & PCI_MSI_FLAGS_QSIZE) >> 4;
+
+	return mme;
+}
+
+static int phytium_pcie_ep_send_msi_irq(struct phytium_pcie_ep *priv, u8 fn,
+						  u8 interrupt_num)
+{
+	u32 cap = PHYTIUM_PCI_CF_MSI_BASE;
+	u16 flags, mme, data_mask, data;
+	u8 msi_count;
+	u64 pci_addr, pci_addr_mask = IRQ_MAPPING_SIZE - 1;
+	u32 src_addr0, src_addr1, trsl_addr0, trsl_addr1, trsl_param, atr_size;
+
+	flags = phytium_pcie_readw(priv, fn, cap + PCI_MSI_FLAGS);
+	if (!(flags & PCI_MSI_FLAGS_ENABLE))
+		return -EINVAL;
+
+	mme = (flags & PCI_MSI_FLAGS_QSIZE) >> 4;
+	msi_count = 1 << mme;
+	if (!interrupt_num || interrupt_num > msi_count)
+		return -EINVAL;
+
+	data_mask = msi_count - 1;
+	data = phytium_pcie_readw(priv, fn, cap + PCI_MSI_DATA_64);
+	data = (data & ~data_mask) | ((interrupt_num - 1) & data_mask);
+
+	/* Get the PCI address */
+	pci_addr = phytium_pcie_readl(priv, fn, cap + PCI_MSI_ADDRESS_HI);
+	pci_addr <<= 32;
+	pci_addr |= phytium_pcie_readl(priv, fn, cap + PCI_MSI_ADDRESS_LO);
+	pci_addr &= GENMASK_ULL(63, 2);
+
+	if (priv->irq_pci_addr != (pci_addr & ~pci_addr_mask) || (priv->irq_pci_fn != fn)) {
+		/* First region for IRQ writes. */
+		atr_size = fls64(pci_addr_mask) - 1;
+		src_addr0 = ATR_IMPL | ((atr_size & ATR_SIZE_MASK) << ATR_SIZE_SHIFT);
+		src_addr0 |= (lower_32_bits(priv->irq_phys_addr) & SRC_ADDR_32_12_MASK);
+		src_addr1 = upper_32_bits(priv->irq_phys_addr);
+		trsl_addr0 = (lower_32_bits(pci_addr) & TRSL_ADDR_32_12_MASK);
+		trsl_addr1 = upper_32_bits(pci_addr);
+		trsl_param = TRSL_ID_PCIE_TR;
+
+		phytium_pcie_writel(priv, fn, PHYTIUM_PCI_SLAVE0_SRC_ADDR0(0),
+			    src_addr0);
+		phytium_pcie_writel(priv, fn, PHYTIUM_PCI_SLAVE0_SRC_ADDR1(0),
+			    src_addr1);
+		phytium_pcie_writel(priv, fn, PHYTIUM_PCI_SLAVE0_TRSL_ADDR0(0),
+			    trsl_addr0);
+		phytium_pcie_writel(priv, fn, PHYTIUM_PCI_SLAVE0_TRSL_ADDR1(0),
+			    trsl_addr1);
+		phytium_pcie_writel(priv, fn, PHYTIUM_PCI_SLAVE0_TRSL_PARAM(0),
+			    trsl_param);
+		priv->irq_pci_addr = (pci_addr & ~pci_addr_mask);
+		priv->irq_pci_fn = fn;
+	}
+
+	dev_dbg(priv->epc->dev.parent, "send event %d\n",  data);
+	writew(data, priv->irq_cpu_addr + (pci_addr & pci_addr_mask));
+
+	return 0;
+}
+
+static int phytium_pcie_ep_raise_irq(struct pci_epc *epc, u8 fn,
+				     enum pci_epc_irq_type type,
+				     u16 interrupt_num)
+{
+	struct phytium_pcie_ep *priv = epc_get_drvdata(epc);
+
+	switch (type) {
+	case PCI_EPC_IRQ_MSI:
+		return phytium_pcie_ep_send_msi_irq(priv, fn, interrupt_num);
+
+	default:
+		break;
+	}
+
+	return -EINVAL;
+}
+
+static int phytium_pcie_ep_start(struct pci_epc *epc)
+{
+	struct pci_epf *epf;
+	u32 cfg;
+
+	cfg = BIT(0);
+	list_for_each_entry(epf, &epc->pci_epf, list)
+		cfg |= BIT(epf->func_no);
+
+/*	list_for_each_entry(epf, &epc->pci_epf, list)
+		pci_epf_linkup(epf);
+*/
+	return 0;
+}
+
+static const struct pci_epc_ops phytium_pcie_epc_ops = {
+	.write_header	= phytium_pcie_ep_write_header,
+	.set_bar	= phytium_pcie_ep_set_bar,
+	.clear_bar	= phytium_pcie_ep_clear_bar,
+	.map_addr	= phytium_pcie_ep_map_addr,
+	.unmap_addr	= phytium_pcie_ep_unmap_addr,
+	.set_msi	= phytium_pcie_ep_set_msi,
+	.get_msi	= phytium_pcie_ep_get_msi,
+	.raise_irq	= phytium_pcie_ep_raise_irq,
+	.start		= phytium_pcie_ep_start,
+};
+
+
+
+static int phytium_pcie_ep_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct phytium_pcie_ep *priv = NULL;
+	struct resource *res;
+	struct device_node *np = dev->of_node;
+	struct pci_epc *epc;
+	int ret = 0, value;
+
+	dev_dbg(dev, "enter %s\n", __func__);
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "reg");
+	priv->reg_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(priv->reg_base)) {
+		dev_err(dev, "missing \"reg\"\n");
+		return PTR_ERR(priv->reg_base);
+	}
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mem");
+	if (!res) {
+		dev_err(dev, "missing \"mem\"\n");
+		return -EINVAL;
+	}
+	priv->mem_res = res;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "hpb");
+	priv->hpb_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(priv->hpb_base)) {
+		dev_err(dev, "missing \"hpb\"\n");
+		return PTR_ERR(priv->hpb_base);
+	}
+
+	ret = of_property_read_u32(np, "max-outbound-regions", &priv->max_regions);
+	if (ret < 0) {
+		dev_err(dev, "missing \"max-outbound-regions\"\n");
+		return ret;
+	}
+	dev_info(dev, "%s max-outbound-regions %d\n", __func__, priv->max_regions);
+
+	priv->ob_addr = devm_kcalloc(dev, priv->max_regions,
+				     sizeof(*priv->ob_addr), GFP_KERNEL);
+	if (!priv->ob_addr)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, priv);
+
+	epc = devm_pci_epc_create(dev, &phytium_pcie_epc_ops);
+	if (IS_ERR(epc)) {
+		dev_err(dev, "failed to create epc device\n");
+		return PTR_ERR(epc);
+	}
+
+	priv->epc = epc;
+	epc_set_drvdata(epc, priv);
+
+	if (of_property_read_u8(np, "max-functions", &epc->max_functions) < 0)
+		epc->max_functions = 1;
+	dev_info(dev, "%s epc->max_functions %d\n", __func__, epc->max_functions);
+
+
+	ret = pci_epc_mem_init(epc, priv->mem_res->start,
+			       resource_size(priv->mem_res), PAGE_SIZE);
+	if (ret < 0) {
+		dev_err(dev, "failed to initialize the memory space\n");
+		return ret;
+	}
+
+	priv->irq_cpu_addr = pci_epc_mem_alloc_addr(epc, &priv->irq_phys_addr,
+						    SZ_4K);
+	if (!priv->irq_cpu_addr) {
+		dev_err(dev, "failed to reserve memory space for MSI\n");
+		ret = -ENOMEM;
+		goto err_alloc_irq_mem;
+	}
+	priv->irq_pci_addr = PHYTIUM_PCIE_EP_IRQ_PCI_ADDR_NONE;
+	/* Reserve region 0 for IRQS */
+	set_bit(0, &priv->ob_region_map);
+
+	value = ((lower_32_bits(priv->mem_res->start) >> C0_PREF_VALUE_SHIFT)
+		& C0_PREF_BASE_MASK) << C0_PREF_BASE_SHIFT;
+	value |= (((lower_32_bits(priv->mem_res->end) >> C0_PREF_VALUE_SHIFT)
+		& C0_PREF_LIMIT_MASK) << C0_PREF_LIMIT_SHIFT);
+	phytium_hpb_writel(priv, PHYTIUM_HPB_C0_PREF_BASE_LIMIT, value);
+
+	value = ((upper_32_bits(priv->mem_res->start) >> C0_PREF_UP32_VALUE_SHIFT)
+		& C0_PREF_BASE_UP32_MASK) << C0_PREF_BASE_UP32_SHIFT;
+	value |= (((upper_32_bits(priv->mem_res->end) >> C0_PREF_UP32_VALUE_SHIFT)
+		 & C0_PREF_LIMIT_UP32_MASK) << C0_PREF_LIMIT_UP32_SHIFT);
+	phytium_hpb_writel(priv, PHYTIUM_HPB_C0_PREF_BASE_LIMIT_UP32, value);
+
+	dev_dbg(dev, "exit %s successful\n", __func__);
+	return 0;
+
+err_alloc_irq_mem:
+	pci_epc_mem_exit(epc);
+	return ret;
+}
+
+static int phytium_pcie_ep_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct phytium_pcie_ep *priv = dev_get_drvdata(dev);
+	struct pci_epc *epc = priv->epc;
+
+	pci_epc_mem_exit(epc);
+
+	return 0;
+}
+
+static const struct of_device_id phytium_pcie_ep_of_match[] = {
+	{ .compatible = "phytium,d2000-pcie-ep" },
+	{ },
+};
+
+static struct platform_driver phytium_pcie_ep_driver = {
+	.driver = {
+		.name = "phytium-pcie-ep",
+		.of_match_table = phytium_pcie_ep_of_match,
+	},
+	.probe = phytium_pcie_ep_probe,
+	.remove = phytium_pcie_ep_remove,
+};
+
+module_platform_driver(phytium_pcie_ep_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Yang Xun <yangxun@phytium.com.cn>");
+MODULE_DESCRIPTION("Phytium Pcie Controller Endpoint driver");
diff --git a/drivers/pci/controller/pcie-phytium-ep.h b/drivers/pci/controller/pcie-phytium-ep.h
new file mode 100755
index 000000000000..27d39a222f3c
--- /dev/null
+++ b/drivers/pci/controller/pcie-phytium-ep.h
@@ -0,0 +1,95 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Phytium d2000 pcie endpoint driver
+ *
+ * Copyright (c) 2021 Phytium Limited.
+ *
+ * Author:
+ *	Yang Xun <yangxun@phytium.com.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __PCIE_PHYTIUM_EP_H__
+#define __PCIE_PHYTIUM_EP_H__
+
+#include "pcie-phytium-register.h"
+
+#define IRQ_MAPPING_SIZE	0x1000
+struct phytium_pcie_ep {
+	void __iomem		*reg_base;
+	struct resource		*mem_res;
+	void __iomem		*hpb_base;
+	unsigned int		max_regions;
+	unsigned long		ob_region_map;
+	phys_addr_t		*ob_addr;
+	phys_addr_t		irq_phys_addr;
+	void __iomem		*irq_cpu_addr;
+	unsigned long		irq_pci_addr;
+	u8			irq_pci_fn;
+	struct pci_epc		*epc;
+};
+
+static inline void
+phytium_pcie_writeb(struct phytium_pcie_ep *priv, u8 fn, u32 reg, u8 value)
+{
+	pr_debug("Write 32'h%08lx 32'h%08x\n", PHYTIUM_PCIE_FUNC_BASE(fn) + reg, value);
+	writeb(value, priv->reg_base + PHYTIUM_PCIE_FUNC_BASE(fn) + reg);
+}
+
+static inline unsigned char
+phytium_pcie_readb(struct phytium_pcie_ep *priv, u8 fn, u32 reg)
+{
+	unsigned char value;
+
+	value = readb(priv->reg_base + PHYTIUM_PCIE_FUNC_BASE(fn) + reg);
+	pr_debug("Read 32'h%08lx 32'h%08x\n", PHYTIUM_PCIE_FUNC_BASE(fn) + reg, value);
+
+	return value;
+}
+
+static inline void
+phytium_pcie_writew(struct phytium_pcie_ep *priv, u8 fn, u32 reg, u16 value)
+{
+	pr_debug("Write 32'h%08lx 32'h%08x\n", PHYTIUM_PCIE_FUNC_BASE(fn) + reg, value);
+	writew(value, priv->reg_base + PHYTIUM_PCIE_FUNC_BASE(fn) + reg);
+}
+
+static inline unsigned short
+phytium_pcie_readw(struct phytium_pcie_ep *priv, u8 fn, u32 reg)
+{
+	unsigned short value;
+
+	value = readw(priv->reg_base + PHYTIUM_PCIE_FUNC_BASE(fn) + reg);
+	pr_debug("Read 32'h%08lx 32'h%08x\n", PHYTIUM_PCIE_FUNC_BASE(fn) + reg, value);
+
+	return value;
+}
+
+static inline void
+phytium_pcie_writel(struct phytium_pcie_ep *priv, u8 fn, u32 reg, u32 value)
+{
+	pr_debug("Write 32'h%08lx 32'h%08x\n", PHYTIUM_PCIE_FUNC_BASE(fn) + reg, value);
+	writel(value, priv->reg_base + PHYTIUM_PCIE_FUNC_BASE(fn) + reg);
+}
+
+static inline unsigned int
+phytium_pcie_readl(struct phytium_pcie_ep *priv, u8 fn, u32 reg)
+{
+	unsigned int value;
+
+	value = readl(priv->reg_base + PHYTIUM_PCIE_FUNC_BASE(fn) + reg);
+	pr_debug("Read 32'h%08lx 32'h%08x\n", PHYTIUM_PCIE_FUNC_BASE(fn) + reg, value);
+
+	return value;
+}
+
+static inline void
+phytium_hpb_writel(struct phytium_pcie_ep *priv, u32 reg, u32 value)
+{
+	pr_debug("Write 32'h%08x 32'h%08x\n",  reg, value);
+	writel(value, priv->hpb_base + reg);
+}
+#endif
diff --git a/drivers/pci/controller/pcie-phytium-register.h b/drivers/pci/controller/pcie-phytium-register.h
new file mode 100755
index 000000000000..7b90d416dd4b
--- /dev/null
+++ b/drivers/pci/controller/pcie-phytium-register.h
@@ -0,0 +1,87 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Phytium d2000 pcie endpoint driver
+ *
+ * Copyright (c) 2021 Phytium Limited.
+ *
+ * Author:
+ *	Yang Xun <yangxun@phytium.com.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __PCIE_PHYTIUM_REGISTER_H__
+#define __PCIE_PHYTIUM_REGISTER_H__
+
+#define	PHYTIUM_PCIE_FUNC_BASE(fn)		(((fn) << 14) & GENMASK(16, 14))
+#define	PHYTIUM_PCI_VENDOR_ID			0x98
+#define	PHYTIUM_PCI_DEVICE_ID			0x9a
+#define	PHYTIUM_PCI_REVISION_ID			0x9c
+#define	PHYTIUM_PCI_CLASS_PROG			0x9d
+#define	PHYTIUM_PCI_CLASS_DEVICE		0x9e
+#define	PHYTIUM_PCI_SUBSYS_VENDOR_ID		0xa0
+#define	PHYTIUM_PCI_SUBSYS_DEVICE_ID		0xa2
+#define	PHYTIUM_PCI_INTERRUPT_PIN		0xa8
+#define	 INTERRUPT_PIN_MASK				0x7
+#define	 MSI_DISABLE					(1 << 3)
+#define	 MSI_NUM_MASK					(0x7)
+#define	 MSI_NUM_SHIFT					4
+#define	 MSI_MASK_SUPPORT				(1 << 7)
+#define	PHYTIUM_PCI_MSIX_CAP			0xaa
+	#define	MSIX_DISABLE				(0 << 15)
+
+#define	PHYTIUM_PCI_BAR_0			0xe4
+#define PHYTIUM_PCI_BAR(bar_num)		(0xe4 + bar_num * 4)
+#define	 BAR_IO_TYPE					(1 << 0)
+#define	 BAR_MEM_TYPE					(0 << 0)
+#define	 BAR_MEM_64BIT					(1 << 2)
+#define	 BAR_MEM_PREFETCHABLE				(1 << 3)
+#define	 BAR_IO_MIN_APERTURE				4
+#define	 BAR_MEM_MIN_APERTURE				16
+
+
+#define	PHYTIUM_PCI_WIN0_BASE			0x600
+#define	PHYTIUM_PCI_WIN0_SRC_ADDR0(table)	(PHYTIUM_PCI_WIN0_BASE + 0X20 * table + 0x0)
+#define	 ATR_IMPL					0x1
+#define	 ATR_SIZE_MASK					0x3f
+#define	 ATR_SIZE_SHIFT					1
+#define	 ATR_SIZE_ALIGN					0x1000
+#define	 SRC_ADDR_32_12_MASK				0xfffff000
+
+#define	PHYTIUM_PCI_WIN0_SRC_ADDR1(table)	(PHYTIUM_PCI_WIN0_BASE + 0X20 * table + 0x4)
+#define	PHYTIUM_PCI_WIN0_TRSL_ADDR0(table)	(PHYTIUM_PCI_WIN0_BASE + 0X20 * table + 0x8)
+#define	 TRSL_ADDR_32_12_MASK				0xfffff000
+
+#define	PHYTIUM_PCI_WIN0_TRSL_ADDR1(table)	(PHYTIUM_PCI_WIN0_BASE + 0X20 * table + 0xc)
+#define	PHYTIUM_PCI_WIN0_TRSL_PARAM(table)	(PHYTIUM_PCI_WIN0_BASE + 0X20 * table + 0x10)
+#define	 TRSL_ID_IO					0x1
+#define	 TRSL_ID_MASTER					0x4
+#define	 TRSL_ID_PCIE_TR				0x0
+
+#define	PHYTIUM_PCI_SLAVE0_BASE			0x800
+#define	PHYTIUM_PCI_SLAVE0_SRC_ADDR0(table)	(PHYTIUM_PCI_SLAVE0_BASE + 0X20 * table + 0x0)
+#define	PHYTIUM_PCI_SLAVE0_SRC_ADDR1(table)	(PHYTIUM_PCI_SLAVE0_BASE + 0X20 * table + 0x4)
+#define	PHYTIUM_PCI_SLAVE0_TRSL_ADDR0(table)	(PHYTIUM_PCI_SLAVE0_BASE + 0X20 * table + 0x8)
+#define	PHYTIUM_PCI_SLAVE0_TRSL_ADDR1(table)	(PHYTIUM_PCI_SLAVE0_BASE + 0X20 * table + 0xc)
+#define	PHYTIUM_PCI_SLAVE0_TRSL_PARAM(table)	(PHYTIUM_PCI_SLAVE0_BASE + 0X20 * table + 0x10)
+
+#define	PHYTIUM_PCI_CF_MSI_BASE			0x10e0
+#define	PHYTIUM_PCI_CF_MSI_CONTROL		0x10e2
+
+#define	PHYTIUM_HPB_C0_PREF_BASE_LIMIT	0xa30
+	#define C0_PREF_LIMIT_MASK		0xfff
+	#define C0_PREF_LIMIT_SHIFT		20
+	#define C0_PREF_BASE_MASK		0xfff
+	#define C0_PREF_BASE_SHIFT		4
+	#define C0_PREF_VALUE_SHIFT		20
+#define	PHYTIUM_HPB_C0_PREF_BASE_LIMIT_UP32	0xa34
+	#define C0_PREF_LIMIT_UP32_MASK	0xff
+	#define C0_PREF_LIMIT_UP32_SHIFT	8
+	#define C0_PREF_BASE_UP32_MASK	0xff
+	#define C0_PREF_BASE_UP32_SHIFT	0
+	#define C0_PREF_UP32_VALUE_SHIFT	0
+#endif
+
+
diff --git a/include/acpi/actbl2.h b/include/acpi/actbl2.h
index e44230e4aff9..2f63bc84dddc 100644
--- a/include/acpi/actbl2.h
+++ b/include/acpi/actbl2.h
@@ -518,7 +518,8 @@ enum acpi_madt_type {
 	ACPI_MADT_TYPE_GENERIC_MSI_FRAME = 13,
 	ACPI_MADT_TYPE_GENERIC_REDISTRIBUTOR = 14,
 	ACPI_MADT_TYPE_GENERIC_TRANSLATOR = 15,
-	ACPI_MADT_TYPE_RESERVED = 16	/* 16 and greater are reserved */
+	ACPI_MADT_TYPE_RESERVED = 16,	/* 16 and greater are reserved */
+	 ACPI_MADT_TYPE_PHYTIUM_2500 = 128
 };
 
 /*
diff --git a/include/linux/irqchip/arm-gic-phytium-2500.h b/include/linux/irqchip/arm-gic-phytium-2500.h
new file mode 100755
index 000000000000..2ae61f3293cc
--- /dev/null
+++ b/include/linux/irqchip/arm-gic-phytium-2500.h
@@ -0,0 +1,621 @@
+/*
+ * Copyright (C) 2020 Phytium Corporation.
+ * Author: Wang Yinfeng <wangyinfeng@phytium.com.cn>
+ *         Chen Baozi <chenbaozi@phytium.com.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef __LINUX_IRQCHIP_ARM_GIC_PHYTIUM_2500_H
+#define __LINUX_IRQCHIP_ARM_GIC_PHYTIUM_2500_H
+
+/*
+ * Distributor registers. We assume we're running non-secure, with ARE
+ * being set. Secure-only and non-ARE registers are not described.
+ */
+#define GICD_CTLR			0x0000
+#define GICD_TYPER			0x0004
+#define GICD_IIDR			0x0008
+#define GICD_STATUSR			0x0010
+#define GICD_SETSPI_NSR			0x0040
+#define GICD_CLRSPI_NSR			0x0048
+#define GICD_SETSPI_SR			0x0050
+#define GICD_CLRSPI_SR			0x0058
+#define GICD_SEIR			0x0068
+#define GICD_IGROUPR			0x0080
+#define GICD_ISENABLER			0x0100
+#define GICD_ICENABLER			0x0180
+#define GICD_ISPENDR			0x0200
+#define GICD_ICPENDR			0x0280
+#define GICD_ISACTIVER			0x0300
+#define GICD_ICACTIVER			0x0380
+#define GICD_IPRIORITYR			0x0400
+#define GICD_ICFGR			0x0C00
+#define GICD_IGRPMODR			0x0D00
+#define GICD_NSACR			0x0E00
+#define GICD_IROUTER			0x6000
+#define GICD_IDREGS			0xFFD0
+#define GICD_PIDR2			0xFFE8
+
+/*
+ * Those registers are actually from GICv2, but the spec demands that they
+ * are implemented as RES0 if ARE is 1 (which we do in KVM's emulated GICv3).
+ */
+#define GICD_ITARGETSR			0x0800
+#define GICD_SGIR			0x0F00
+#define GICD_CPENDSGIR			0x0F10
+#define GICD_SPENDSGIR			0x0F20
+
+#define GICD_CTLR_RWP			(1U << 31)
+#define GICD_CTLR_DS			(1U << 6)
+#define GICD_CTLR_ARE_NS		(1U << 4)
+#define GICD_CTLR_ENABLE_G1A		(1U << 1)
+#define GICD_CTLR_ENABLE_G1		(1U << 0)
+
+#define GICD_IIDR_IMPLEMENTER_SHIFT	0
+#define GICD_IIDR_IMPLEMENTER_MASK	(0xfff << GICD_IIDR_IMPLEMENTER_SHIFT)
+#define GICD_IIDR_REVISION_SHIFT	12
+#define GICD_IIDR_REVISION_MASK		(0xf << GICD_IIDR_REVISION_SHIFT)
+#define GICD_IIDR_VARIANT_SHIFT		16
+#define GICD_IIDR_VARIANT_MASK		(0xf << GICD_IIDR_VARIANT_SHIFT)
+#define GICD_IIDR_PRODUCT_ID_SHIFT	24
+#define GICD_IIDR_PRODUCT_ID_MASK	(0xff << GICD_IIDR_PRODUCT_ID_SHIFT)
+
+
+/*
+ * In systems with a single security state (what we emulate in KVM)
+ * the meaning of the interrupt group enable bits is slightly different
+ */
+#define GICD_CTLR_ENABLE_SS_G1		(1U << 1)
+#define GICD_CTLR_ENABLE_SS_G0		(1U << 0)
+
+#define GICD_TYPER_RSS			(1U << 26)
+#define GICD_TYPER_LPIS			(1U << 17)
+#define GICD_TYPER_MBIS			(1U << 16)
+
+#define GICD_TYPER_ID_BITS(typer)	((((typer) >> 19) & 0x1f) + 1)
+#define GICD_TYPER_NUM_LPIS(typer)	((((typer) >> 11) & 0x1f) + 1)
+#define GICD_TYPER_IRQS(typer)		((((typer) & 0x1f) + 1) * 32)
+
+#define GICD_IROUTER_SPI_MODE_ONE	(0U << 31)
+#define GICD_IROUTER_SPI_MODE_ANY	(1U << 31)
+
+#define GIC_PIDR2_ARCH_MASK		0xf0
+#define GIC_PIDR2_ARCH_GICv3		0x30
+#define GIC_PIDR2_ARCH_GICv4		0x40
+
+#define GIC_V3_DIST_SIZE		0x10000
+
+/*
+ * Re-Distributor registers, offsets from RD_base
+ */
+#define GICR_CTLR			GICD_CTLR
+#define GICR_IIDR			0x0004
+#define GICR_TYPER			0x0008
+#define GICR_STATUSR			GICD_STATUSR
+#define GICR_WAKER			0x0014
+#define GICR_SETLPIR			0x0040
+#define GICR_CLRLPIR			0x0048
+#define GICR_SEIR			GICD_SEIR
+#define GICR_PROPBASER			0x0070
+#define GICR_PENDBASER			0x0078
+#define GICR_INVLPIR			0x00A0
+#define GICR_INVALLR			0x00B0
+#define GICR_SYNCR			0x00C0
+#define GICR_MOVLPIR			0x0100
+#define GICR_MOVALLR			0x0110
+#define GICR_IDREGS			GICD_IDREGS
+#define GICR_PIDR2			GICD_PIDR2
+
+#define GICR_CTLR_ENABLE_LPIS		(1UL << 0)
+#define GICR_CTLR_RWP			(1UL << 3)
+
+#define GICR_TYPER_CPU_NUMBER(r)	(((r) >> 8) & 0xffff)
+
+#define GICR_WAKER_ProcessorSleep	(1U << 1)
+#define GICR_WAKER_ChildrenAsleep	(1U << 2)
+
+#define GIC_BASER_CACHE_nCnB		0ULL
+#define GIC_BASER_CACHE_SameAsInner	0ULL
+#define GIC_BASER_CACHE_nC		1ULL
+#define GIC_BASER_CACHE_RaWt		2ULL
+#define GIC_BASER_CACHE_RaWb		3ULL
+#define GIC_BASER_CACHE_WaWt		4ULL
+#define GIC_BASER_CACHE_WaWb		5ULL
+#define GIC_BASER_CACHE_RaWaWt		6ULL
+#define GIC_BASER_CACHE_RaWaWb		7ULL
+#define GIC_BASER_CACHE_MASK		7ULL
+#define GIC_BASER_NonShareable		0ULL
+#define GIC_BASER_InnerShareable	1ULL
+#define GIC_BASER_OuterShareable	2ULL
+#define GIC_BASER_SHAREABILITY_MASK	3ULL
+
+#define GIC_BASER_CACHEABILITY(reg, inner_outer, type)			\
+	(GIC_BASER_CACHE_##type << reg##_##inner_outer##_CACHEABILITY_SHIFT)
+
+#define GIC_BASER_SHAREABILITY(reg, type)				\
+	(GIC_BASER_##type << reg##_SHAREABILITY_SHIFT)
+
+/* encode a size field of width @w containing @n - 1 units */
+#define GIC_ENCODE_SZ(n, w) (((unsigned long)(n) - 1) & GENMASK_ULL(((w) - 1), 0))
+
+#define GICR_PROPBASER_SHAREABILITY_SHIFT		(10)
+#define GICR_PROPBASER_INNER_CACHEABILITY_SHIFT		(7)
+#define GICR_PROPBASER_OUTER_CACHEABILITY_SHIFT		(56)
+#define GICR_PROPBASER_SHAREABILITY_MASK				\
+	GIC_BASER_SHAREABILITY(GICR_PROPBASER, SHAREABILITY_MASK)
+#define GICR_PROPBASER_INNER_CACHEABILITY_MASK				\
+	GIC_BASER_CACHEABILITY(GICR_PROPBASER, INNER, MASK)
+#define GICR_PROPBASER_OUTER_CACHEABILITY_MASK				\
+	GIC_BASER_CACHEABILITY(GICR_PROPBASER, OUTER, MASK)
+#define GICR_PROPBASER_CACHEABILITY_MASK GICR_PROPBASER_INNER_CACHEABILITY_MASK
+
+#define GICR_PROPBASER_InnerShareable					\
+	GIC_BASER_SHAREABILITY(GICR_PROPBASER, InnerShareable)
+
+#define GICR_PROPBASER_nCnB	GIC_BASER_CACHEABILITY(GICR_PROPBASER, INNER, nCnB)
+#define GICR_PROPBASER_nC 	GIC_BASER_CACHEABILITY(GICR_PROPBASER, INNER, nC)
+#define GICR_PROPBASER_RaWt	GIC_BASER_CACHEABILITY(GICR_PROPBASER, INNER, RaWt)
+#define GICR_PROPBASER_RaWb	GIC_BASER_CACHEABILITY(GICR_PROPBASER, INNER, RaWt)
+#define GICR_PROPBASER_WaWt	GIC_BASER_CACHEABILITY(GICR_PROPBASER, INNER, WaWt)
+#define GICR_PROPBASER_WaWb	GIC_BASER_CACHEABILITY(GICR_PROPBASER, INNER, WaWb)
+#define GICR_PROPBASER_RaWaWt	GIC_BASER_CACHEABILITY(GICR_PROPBASER, INNER, RaWaWt)
+#define GICR_PROPBASER_RaWaWb	GIC_BASER_CACHEABILITY(GICR_PROPBASER, INNER, RaWaWb)
+
+#define GICR_PROPBASER_IDBITS_MASK			(0x1f)
+#define GICR_PROPBASER_ADDRESS(x)	((x) & GENMASK_ULL(51, 12))
+#define GICR_PENDBASER_ADDRESS(x)	((x) & GENMASK_ULL(51, 16))
+
+#define GICR_PENDBASER_SHAREABILITY_SHIFT		(10)
+#define GICR_PENDBASER_INNER_CACHEABILITY_SHIFT		(7)
+#define GICR_PENDBASER_OUTER_CACHEABILITY_SHIFT		(56)
+#define GICR_PENDBASER_SHAREABILITY_MASK				\
+	GIC_BASER_SHAREABILITY(GICR_PENDBASER, SHAREABILITY_MASK)
+#define GICR_PENDBASER_INNER_CACHEABILITY_MASK				\
+	GIC_BASER_CACHEABILITY(GICR_PENDBASER, INNER, MASK)
+#define GICR_PENDBASER_OUTER_CACHEABILITY_MASK				\
+	GIC_BASER_CACHEABILITY(GICR_PENDBASER, OUTER, MASK)
+#define GICR_PENDBASER_CACHEABILITY_MASK GICR_PENDBASER_INNER_CACHEABILITY_MASK
+
+#define GICR_PENDBASER_InnerShareable					\
+	GIC_BASER_SHAREABILITY(GICR_PENDBASER, InnerShareable)
+
+#define GICR_PENDBASER_nCnB	GIC_BASER_CACHEABILITY(GICR_PENDBASER, INNER, nCnB)
+#define GICR_PENDBASER_nC 	GIC_BASER_CACHEABILITY(GICR_PENDBASER, INNER, nC)
+#define GICR_PENDBASER_RaWt	GIC_BASER_CACHEABILITY(GICR_PENDBASER, INNER, RaWt)
+#define GICR_PENDBASER_RaWb	GIC_BASER_CACHEABILITY(GICR_PENDBASER, INNER, RaWt)
+#define GICR_PENDBASER_WaWt	GIC_BASER_CACHEABILITY(GICR_PENDBASER, INNER, WaWt)
+#define GICR_PENDBASER_WaWb	GIC_BASER_CACHEABILITY(GICR_PENDBASER, INNER, WaWb)
+#define GICR_PENDBASER_RaWaWt	GIC_BASER_CACHEABILITY(GICR_PENDBASER, INNER, RaWaWt)
+#define GICR_PENDBASER_RaWaWb	GIC_BASER_CACHEABILITY(GICR_PENDBASER, INNER, RaWaWb)
+
+#define GICR_PENDBASER_PTZ				BIT_ULL(62)
+
+/*
+ * Re-Distributor registers, offsets from SGI_base
+ */
+#define GICR_IGROUPR0			GICD_IGROUPR
+#define GICR_ISENABLER0			GICD_ISENABLER
+#define GICR_ICENABLER0			GICD_ICENABLER
+#define GICR_ISPENDR0			GICD_ISPENDR
+#define GICR_ICPENDR0			GICD_ICPENDR
+#define GICR_ISACTIVER0			GICD_ISACTIVER
+#define GICR_ICACTIVER0			GICD_ICACTIVER
+#define GICR_IPRIORITYR0		GICD_IPRIORITYR
+#define GICR_ICFGR0			GICD_ICFGR
+#define GICR_IGRPMODR0			GICD_IGRPMODR
+#define GICR_NSACR			GICD_NSACR
+
+#define GICR_TYPER_PLPIS		(1U << 0)
+#define GICR_TYPER_VLPIS		(1U << 1)
+#define GICR_TYPER_DirectLPIS		(1U << 3)
+#define GICR_TYPER_LAST			(1U << 4)
+
+#define GIC_V3_REDIST_SIZE		0x20000
+
+#define LPI_PROP_GROUP1			(1 << 1)
+#define LPI_PROP_ENABLED		(1 << 0)
+
+/*
+ * Re-Distributor registers, offsets from VLPI_base
+ */
+#define GICR_VPROPBASER			0x0070
+
+#define GICR_VPROPBASER_IDBITS_MASK	0x1f
+
+#define GICR_VPROPBASER_SHAREABILITY_SHIFT		(10)
+#define GICR_VPROPBASER_INNER_CACHEABILITY_SHIFT	(7)
+#define GICR_VPROPBASER_OUTER_CACHEABILITY_SHIFT	(56)
+
+#define GICR_VPROPBASER_SHAREABILITY_MASK				\
+	GIC_BASER_SHAREABILITY(GICR_VPROPBASER, SHAREABILITY_MASK)
+#define GICR_VPROPBASER_INNER_CACHEABILITY_MASK				\
+	GIC_BASER_CACHEABILITY(GICR_VPROPBASER, INNER, MASK)
+#define GICR_VPROPBASER_OUTER_CACHEABILITY_MASK				\
+	GIC_BASER_CACHEABILITY(GICR_VPROPBASER, OUTER, MASK)
+#define GICR_VPROPBASER_CACHEABILITY_MASK				\
+	GICR_VPROPBASER_INNER_CACHEABILITY_MASK
+
+#define GICR_VPROPBASER_InnerShareable					\
+	GIC_BASER_SHAREABILITY(GICR_VPROPBASER, InnerShareable)
+
+#define GICR_VPROPBASER_nCnB	GIC_BASER_CACHEABILITY(GICR_VPROPBASER, INNER, nCnB)
+#define GICR_VPROPBASER_nC 	GIC_BASER_CACHEABILITY(GICR_VPROPBASER, INNER, nC)
+#define GICR_VPROPBASER_RaWt	GIC_BASER_CACHEABILITY(GICR_VPROPBASER, INNER, RaWt)
+#define GICR_VPROPBASER_RaWb	GIC_BASER_CACHEABILITY(GICR_VPROPBASER, INNER, RaWt)
+#define GICR_VPROPBASER_WaWt	GIC_BASER_CACHEABILITY(GICR_VPROPBASER, INNER, WaWt)
+#define GICR_VPROPBASER_WaWb	GIC_BASER_CACHEABILITY(GICR_VPROPBASER, INNER, WaWb)
+#define GICR_VPROPBASER_RaWaWt	GIC_BASER_CACHEABILITY(GICR_VPROPBASER, INNER, RaWaWt)
+#define GICR_VPROPBASER_RaWaWb	GIC_BASER_CACHEABILITY(GICR_VPROPBASER, INNER, RaWaWb)
+
+#define GICR_VPENDBASER			0x0078
+
+#define GICR_VPENDBASER_SHAREABILITY_SHIFT		(10)
+#define GICR_VPENDBASER_INNER_CACHEABILITY_SHIFT	(7)
+#define GICR_VPENDBASER_OUTER_CACHEABILITY_SHIFT	(56)
+#define GICR_VPENDBASER_SHAREABILITY_MASK				\
+	GIC_BASER_SHAREABILITY(GICR_VPENDBASER, SHAREABILITY_MASK)
+#define GICR_VPENDBASER_INNER_CACHEABILITY_MASK				\
+	GIC_BASER_CACHEABILITY(GICR_VPENDBASER, INNER, MASK)
+#define GICR_VPENDBASER_OUTER_CACHEABILITY_MASK				\
+	GIC_BASER_CACHEABILITY(GICR_VPENDBASER, OUTER, MASK)
+#define GICR_VPENDBASER_CACHEABILITY_MASK				\
+	GICR_VPENDBASER_INNER_CACHEABILITY_MASK
+
+#define GICR_VPENDBASER_NonShareable					\
+	GIC_BASER_SHAREABILITY(GICR_VPENDBASER, NonShareable)
+
+#define GICR_VPENDBASER_nCnB	GIC_BASER_CACHEABILITY(GICR_VPENDBASER, INNER, nCnB)
+#define GICR_VPENDBASER_nC 	GIC_BASER_CACHEABILITY(GICR_VPENDBASER, INNER, nC)
+#define GICR_VPENDBASER_RaWt	GIC_BASER_CACHEABILITY(GICR_VPENDBASER, INNER, RaWt)
+#define GICR_VPENDBASER_RaWb	GIC_BASER_CACHEABILITY(GICR_VPENDBASER, INNER, RaWt)
+#define GICR_VPENDBASER_WaWt	GIC_BASER_CACHEABILITY(GICR_VPENDBASER, INNER, WaWt)
+#define GICR_VPENDBASER_WaWb	GIC_BASER_CACHEABILITY(GICR_VPENDBASER, INNER, WaWb)
+#define GICR_VPENDBASER_RaWaWt	GIC_BASER_CACHEABILITY(GICR_VPENDBASER, INNER, RaWaWt)
+#define GICR_VPENDBASER_RaWaWb	GIC_BASER_CACHEABILITY(GICR_VPENDBASER, INNER, RaWaWb)
+
+#define GICR_VPENDBASER_Dirty		(1ULL << 60)
+#define GICR_VPENDBASER_PendingLast	(1ULL << 61)
+#define GICR_VPENDBASER_IDAI		(1ULL << 62)
+#define GICR_VPENDBASER_Valid		(1ULL << 63)
+
+/*
+ * ITS registers, offsets from ITS_base
+ */
+#define GITS_CTLR			0x0000
+#define GITS_IIDR			0x0004
+#define GITS_TYPER			0x0008
+#define GITS_CBASER			0x0080
+#define GITS_CWRITER			0x0088
+#define GITS_CREADR			0x0090
+#define GITS_BASER			0x0100
+#define GITS_IDREGS_BASE		0xffd0
+#define GITS_PIDR0			0xffe0
+#define GITS_PIDR1			0xffe4
+#define GITS_PIDR2			GICR_PIDR2
+#define GITS_PIDR4			0xffd0
+#define GITS_CIDR0			0xfff0
+#define GITS_CIDR1			0xfff4
+#define GITS_CIDR2			0xfff8
+#define GITS_CIDR3			0xfffc
+
+#define GITS_TRANSLATER			0x10040
+
+#define GITS_CTLR_ENABLE		(1U << 0)
+#define GITS_CTLR_ImDe			(1U << 1)
+#define	GITS_CTLR_ITS_NUMBER_SHIFT	4
+#define	GITS_CTLR_ITS_NUMBER		(0xFU << GITS_CTLR_ITS_NUMBER_SHIFT)
+#define GITS_CTLR_QUIESCENT		(1U << 31)
+
+#define GITS_TYPER_PLPIS		(1UL << 0)
+#define GITS_TYPER_VLPIS		(1UL << 1)
+#define GITS_TYPER_ITT_ENTRY_SIZE_SHIFT	4
+#define GITS_TYPER_ITT_ENTRY_SIZE(r)	((((r) >> GITS_TYPER_ITT_ENTRY_SIZE_SHIFT) & 0x1f) + 1)
+#define GITS_TYPER_IDBITS_SHIFT		8
+#define GITS_TYPER_DEVBITS_SHIFT	13
+#define GITS_TYPER_DEVBITS(r)		((((r) >> GITS_TYPER_DEVBITS_SHIFT) & 0x1f) + 1)
+#define GITS_TYPER_PTA			(1UL << 19)
+#define GITS_TYPER_HCC_SHIFT		24
+#define GITS_TYPER_HCC(r)		(((r) >> GITS_TYPER_HCC_SHIFT) & 0xff)
+#define GITS_TYPER_VMOVP		(1ULL << 37)
+
+#define GITS_IIDR_REV_SHIFT		12
+#define GITS_IIDR_REV_MASK		(0xf << GITS_IIDR_REV_SHIFT)
+#define GITS_IIDR_REV(r)		(((r) >> GITS_IIDR_REV_SHIFT) & 0xf)
+#define GITS_IIDR_PRODUCTID_SHIFT	24
+
+#define GITS_CBASER_VALID			(1ULL << 63)
+#define GITS_CBASER_SHAREABILITY_SHIFT		(10)
+#define GITS_CBASER_INNER_CACHEABILITY_SHIFT	(59)
+#define GITS_CBASER_OUTER_CACHEABILITY_SHIFT	(53)
+#define GITS_CBASER_SHAREABILITY_MASK					\
+	GIC_BASER_SHAREABILITY(GITS_CBASER, SHAREABILITY_MASK)
+#define GITS_CBASER_INNER_CACHEABILITY_MASK				\
+	GIC_BASER_CACHEABILITY(GITS_CBASER, INNER, MASK)
+#define GITS_CBASER_OUTER_CACHEABILITY_MASK				\
+	GIC_BASER_CACHEABILITY(GITS_CBASER, OUTER, MASK)
+#define GITS_CBASER_CACHEABILITY_MASK GITS_CBASER_INNER_CACHEABILITY_MASK
+
+#define GITS_CBASER_InnerShareable					\
+	GIC_BASER_SHAREABILITY(GITS_CBASER, InnerShareable)
+
+#define GITS_CBASER_nCnB	GIC_BASER_CACHEABILITY(GITS_CBASER, INNER, nCnB)
+#define GITS_CBASER_nC		GIC_BASER_CACHEABILITY(GITS_CBASER, INNER, nC)
+#define GITS_CBASER_RaWt	GIC_BASER_CACHEABILITY(GITS_CBASER, INNER, RaWt)
+#define GITS_CBASER_RaWb	GIC_BASER_CACHEABILITY(GITS_CBASER, INNER, RaWt)
+#define GITS_CBASER_WaWt	GIC_BASER_CACHEABILITY(GITS_CBASER, INNER, WaWt)
+#define GITS_CBASER_WaWb	GIC_BASER_CACHEABILITY(GITS_CBASER, INNER, WaWb)
+#define GITS_CBASER_RaWaWt	GIC_BASER_CACHEABILITY(GITS_CBASER, INNER, RaWaWt)
+#define GITS_CBASER_RaWaWb	GIC_BASER_CACHEABILITY(GITS_CBASER, INNER, RaWaWb)
+
+#define GITS_BASER_NR_REGS		8
+
+#define GITS_BASER_VALID			(1ULL << 63)
+#define GITS_BASER_INDIRECT			(1ULL << 62)
+
+#define GITS_BASER_INNER_CACHEABILITY_SHIFT	(59)
+#define GITS_BASER_OUTER_CACHEABILITY_SHIFT	(53)
+#define GITS_BASER_INNER_CACHEABILITY_MASK				\
+	GIC_BASER_CACHEABILITY(GITS_BASER, INNER, MASK)
+#define GITS_BASER_CACHEABILITY_MASK		GITS_BASER_INNER_CACHEABILITY_MASK
+#define GITS_BASER_OUTER_CACHEABILITY_MASK				\
+	GIC_BASER_CACHEABILITY(GITS_BASER, OUTER, MASK)
+#define GITS_BASER_SHAREABILITY_MASK					\
+	GIC_BASER_SHAREABILITY(GITS_BASER, SHAREABILITY_MASK)
+
+#define GITS_BASER_nCnB		GIC_BASER_CACHEABILITY(GITS_BASER, INNER, nCnB)
+#define GITS_BASER_nC		GIC_BASER_CACHEABILITY(GITS_BASER, INNER, nC)
+#define GITS_BASER_RaWt		GIC_BASER_CACHEABILITY(GITS_BASER, INNER, RaWt)
+#define GITS_BASER_RaWb		GIC_BASER_CACHEABILITY(GITS_BASER, INNER, RaWt)
+#define GITS_BASER_WaWt		GIC_BASER_CACHEABILITY(GITS_BASER, INNER, WaWt)
+#define GITS_BASER_WaWb		GIC_BASER_CACHEABILITY(GITS_BASER, INNER, WaWb)
+#define GITS_BASER_RaWaWt	GIC_BASER_CACHEABILITY(GITS_BASER, INNER, RaWaWt)
+#define GITS_BASER_RaWaWb	GIC_BASER_CACHEABILITY(GITS_BASER, INNER, RaWaWb)
+
+#define GITS_BASER_TYPE_SHIFT			(56)
+#define GITS_BASER_TYPE(r)		(((r) >> GITS_BASER_TYPE_SHIFT) & 7)
+#define GITS_BASER_ENTRY_SIZE_SHIFT		(48)
+#define GITS_BASER_ENTRY_SIZE(r)	((((r) >> GITS_BASER_ENTRY_SIZE_SHIFT) & 0x1f) + 1)
+#define GITS_BASER_ENTRY_SIZE_MASK	GENMASK_ULL(52, 48)
+#define GITS_BASER_PHYS_52_to_48(phys)					\
+	(((phys) & GENMASK_ULL(47, 16)) | (((phys) >> 48) & 0xf) << 12)
+#define GITS_BASER_SHAREABILITY_SHIFT	(10)
+#define GITS_BASER_InnerShareable					\
+	GIC_BASER_SHAREABILITY(GITS_BASER, InnerShareable)
+#define GITS_BASER_PAGE_SIZE_SHIFT	(8)
+#define GITS_BASER_PAGE_SIZE_4K		(0ULL << GITS_BASER_PAGE_SIZE_SHIFT)
+#define GITS_BASER_PAGE_SIZE_16K	(1ULL << GITS_BASER_PAGE_SIZE_SHIFT)
+#define GITS_BASER_PAGE_SIZE_64K	(2ULL << GITS_BASER_PAGE_SIZE_SHIFT)
+#define GITS_BASER_PAGE_SIZE_MASK	(3ULL << GITS_BASER_PAGE_SIZE_SHIFT)
+#define GITS_BASER_PAGES_MAX		256
+#define GITS_BASER_PAGES_SHIFT		(0)
+#define GITS_BASER_NR_PAGES(r)		(((r) & 0xff) + 1)
+
+#define GITS_BASER_TYPE_NONE		0
+#define GITS_BASER_TYPE_DEVICE		1
+#define GITS_BASER_TYPE_VCPU		2
+#define GITS_BASER_TYPE_RESERVED3	3
+#define GITS_BASER_TYPE_COLLECTION	4
+#define GITS_BASER_TYPE_RESERVED5	5
+#define GITS_BASER_TYPE_RESERVED6	6
+#define GITS_BASER_TYPE_RESERVED7	7
+
+#define GITS_LVL1_ENTRY_SIZE           (8UL)
+
+/*
+ * ITS commands
+ */
+#define GITS_CMD_MAPD			0x08
+#define GITS_CMD_MAPC			0x09
+#define GITS_CMD_MAPTI			0x0a
+#define GITS_CMD_MAPI			0x0b
+#define GITS_CMD_MOVI			0x01
+#define GITS_CMD_DISCARD		0x0f
+#define GITS_CMD_INV			0x0c
+#define GITS_CMD_MOVALL			0x0e
+#define GITS_CMD_INVALL			0x0d
+#define GITS_CMD_INT			0x03
+#define GITS_CMD_CLEAR			0x04
+#define GITS_CMD_SYNC			0x05
+
+/*
+ * GICv4 ITS specific commands
+ */
+#define GITS_CMD_GICv4(x)		((x) | 0x20)
+#define GITS_CMD_VINVALL		GITS_CMD_GICv4(GITS_CMD_INVALL)
+#define GITS_CMD_VMAPP			GITS_CMD_GICv4(GITS_CMD_MAPC)
+#define GITS_CMD_VMAPTI			GITS_CMD_GICv4(GITS_CMD_MAPTI)
+#define GITS_CMD_VMOVI			GITS_CMD_GICv4(GITS_CMD_MOVI)
+#define GITS_CMD_VSYNC			GITS_CMD_GICv4(GITS_CMD_SYNC)
+/* VMOVP is the odd one, as it doesn't have a physical counterpart */
+#define GITS_CMD_VMOVP			GITS_CMD_GICv4(2)
+
+/*
+ * ITS error numbers
+ */
+#define E_ITS_MOVI_UNMAPPED_INTERRUPT		0x010107
+#define E_ITS_MOVI_UNMAPPED_COLLECTION		0x010109
+#define E_ITS_INT_UNMAPPED_INTERRUPT		0x010307
+#define E_ITS_CLEAR_UNMAPPED_INTERRUPT		0x010507
+#define E_ITS_MAPD_DEVICE_OOR			0x010801
+#define E_ITS_MAPD_ITTSIZE_OOR			0x010802
+#define E_ITS_MAPC_PROCNUM_OOR			0x010902
+#define E_ITS_MAPC_COLLECTION_OOR		0x010903
+#define E_ITS_MAPTI_UNMAPPED_DEVICE		0x010a04
+#define E_ITS_MAPTI_ID_OOR			0x010a05
+#define E_ITS_MAPTI_PHYSICALID_OOR		0x010a06
+#define E_ITS_INV_UNMAPPED_INTERRUPT		0x010c07
+#define E_ITS_INVALL_UNMAPPED_COLLECTION	0x010d09
+#define E_ITS_MOVALL_PROCNUM_OOR		0x010e01
+#define E_ITS_DISCARD_UNMAPPED_INTERRUPT	0x010f07
+
+/*
+ * CPU interface registers
+ */
+#define ICC_CTLR_EL1_EOImode_SHIFT	(1)
+#define ICC_CTLR_EL1_EOImode_drop_dir	(0U << ICC_CTLR_EL1_EOImode_SHIFT)
+#define ICC_CTLR_EL1_EOImode_drop	(1U << ICC_CTLR_EL1_EOImode_SHIFT)
+#define ICC_CTLR_EL1_EOImode_MASK	(1 << ICC_CTLR_EL1_EOImode_SHIFT)
+#define ICC_CTLR_EL1_CBPR_SHIFT		0
+#define ICC_CTLR_EL1_CBPR_MASK		(1 << ICC_CTLR_EL1_CBPR_SHIFT)
+#define ICC_CTLR_EL1_PRI_BITS_SHIFT	8
+#define ICC_CTLR_EL1_PRI_BITS_MASK	(0x7 << ICC_CTLR_EL1_PRI_BITS_SHIFT)
+#define ICC_CTLR_EL1_ID_BITS_SHIFT	11
+#define ICC_CTLR_EL1_ID_BITS_MASK	(0x7 << ICC_CTLR_EL1_ID_BITS_SHIFT)
+#define ICC_CTLR_EL1_SEIS_SHIFT		14
+#define ICC_CTLR_EL1_SEIS_MASK		(0x1 << ICC_CTLR_EL1_SEIS_SHIFT)
+#define ICC_CTLR_EL1_A3V_SHIFT		15
+#define ICC_CTLR_EL1_A3V_MASK		(0x1 << ICC_CTLR_EL1_A3V_SHIFT)
+#define ICC_CTLR_EL1_RSS		(0x1 << 18)
+#define ICC_PMR_EL1_SHIFT		0
+#define ICC_PMR_EL1_MASK		(0xff << ICC_PMR_EL1_SHIFT)
+#define ICC_BPR0_EL1_SHIFT		0
+#define ICC_BPR0_EL1_MASK		(0x7 << ICC_BPR0_EL1_SHIFT)
+#define ICC_BPR1_EL1_SHIFT		0
+#define ICC_BPR1_EL1_MASK		(0x7 << ICC_BPR1_EL1_SHIFT)
+#define ICC_IGRPEN0_EL1_SHIFT		0
+#define ICC_IGRPEN0_EL1_MASK		(1 << ICC_IGRPEN0_EL1_SHIFT)
+#define ICC_IGRPEN1_EL1_SHIFT		0
+#define ICC_IGRPEN1_EL1_MASK		(1 << ICC_IGRPEN1_EL1_SHIFT)
+#define ICC_SRE_EL1_DIB			(1U << 2)
+#define ICC_SRE_EL1_DFB			(1U << 1)
+#define ICC_SRE_EL1_SRE			(1U << 0)
+
+/*
+ * Hypervisor interface registers (SRE only)
+ */
+#define ICH_LR_VIRTUAL_ID_MASK		((1ULL << 32) - 1)
+
+#define ICH_LR_EOI			(1ULL << 41)
+#define ICH_LR_GROUP			(1ULL << 60)
+#define ICH_LR_HW			(1ULL << 61)
+#define ICH_LR_STATE			(3ULL << 62)
+#define ICH_LR_PENDING_BIT		(1ULL << 62)
+#define ICH_LR_ACTIVE_BIT		(1ULL << 63)
+#define ICH_LR_PHYS_ID_SHIFT		32
+#define ICH_LR_PHYS_ID_MASK		(0x3ffULL << ICH_LR_PHYS_ID_SHIFT)
+#define ICH_LR_PRIORITY_SHIFT		48
+#define ICH_LR_PRIORITY_MASK		(0xffULL << ICH_LR_PRIORITY_SHIFT)
+
+/* These are for GICv2 emulation only */
+#define GICH_LR_VIRTUALID		(0x3ffUL << 0)
+#define GICH_LR_PHYSID_CPUID_SHIFT	(10)
+#define GICH_LR_PHYSID_CPUID		(7UL << GICH_LR_PHYSID_CPUID_SHIFT)
+
+#define ICH_MISR_EOI			(1 << 0)
+#define ICH_MISR_U			(1 << 1)
+
+#define ICH_HCR_EN			(1 << 0)
+#define ICH_HCR_UIE			(1 << 1)
+#define ICH_HCR_NPIE			(1 << 3)
+#define ICH_HCR_TC			(1 << 10)
+#define ICH_HCR_TALL0			(1 << 11)
+#define ICH_HCR_TALL1			(1 << 12)
+#define ICH_HCR_EOIcount_SHIFT		27
+#define ICH_HCR_EOIcount_MASK		(0x1f << ICH_HCR_EOIcount_SHIFT)
+
+#define ICH_VMCR_ACK_CTL_SHIFT		2
+#define ICH_VMCR_ACK_CTL_MASK		(1 << ICH_VMCR_ACK_CTL_SHIFT)
+#define ICH_VMCR_FIQ_EN_SHIFT		3
+#define ICH_VMCR_FIQ_EN_MASK		(1 << ICH_VMCR_FIQ_EN_SHIFT)
+#define ICH_VMCR_CBPR_SHIFT		4
+#define ICH_VMCR_CBPR_MASK		(1 << ICH_VMCR_CBPR_SHIFT)
+#define ICH_VMCR_EOIM_SHIFT		9
+#define ICH_VMCR_EOIM_MASK		(1 << ICH_VMCR_EOIM_SHIFT)
+#define ICH_VMCR_BPR1_SHIFT		18
+#define ICH_VMCR_BPR1_MASK		(7 << ICH_VMCR_BPR1_SHIFT)
+#define ICH_VMCR_BPR0_SHIFT		21
+#define ICH_VMCR_BPR0_MASK		(7 << ICH_VMCR_BPR0_SHIFT)
+#define ICH_VMCR_PMR_SHIFT		24
+#define ICH_VMCR_PMR_MASK		(0xffUL << ICH_VMCR_PMR_SHIFT)
+#define ICH_VMCR_ENG0_SHIFT		0
+#define ICH_VMCR_ENG0_MASK		(1 << ICH_VMCR_ENG0_SHIFT)
+#define ICH_VMCR_ENG1_SHIFT		1
+#define ICH_VMCR_ENG1_MASK		(1 << ICH_VMCR_ENG1_SHIFT)
+
+#define ICH_VTR_PRI_BITS_SHIFT		29
+#define ICH_VTR_PRI_BITS_MASK		(7 << ICH_VTR_PRI_BITS_SHIFT)
+#define ICH_VTR_ID_BITS_SHIFT		23
+#define ICH_VTR_ID_BITS_MASK		(7 << ICH_VTR_ID_BITS_SHIFT)
+#define ICH_VTR_SEIS_SHIFT		22
+#define ICH_VTR_SEIS_MASK		(1 << ICH_VTR_SEIS_SHIFT)
+#define ICH_VTR_A3V_SHIFT		21
+#define ICH_VTR_A3V_MASK		(1 << ICH_VTR_A3V_SHIFT)
+
+#define ICC_IAR1_EL1_SPURIOUS		0x3ff
+
+#define ICC_SRE_EL2_SRE			(1 << 0)
+#define ICC_SRE_EL2_ENABLE		(1 << 3)
+
+#define ICC_SGI1R_TARGET_LIST_SHIFT	0
+#define ICC_SGI1R_TARGET_LIST_MASK	(0xffff << ICC_SGI1R_TARGET_LIST_SHIFT)
+#define ICC_SGI1R_AFFINITY_1_SHIFT	16
+#define ICC_SGI1R_AFFINITY_1_MASK	(0xff << ICC_SGI1R_AFFINITY_1_SHIFT)
+#define ICC_SGI1R_SGI_ID_SHIFT		24
+#define ICC_SGI1R_SGI_ID_MASK		(0xfULL << ICC_SGI1R_SGI_ID_SHIFT)
+#define ICC_SGI1R_AFFINITY_2_SHIFT	32
+#define ICC_SGI1R_AFFINITY_2_MASK	(0xffULL << ICC_SGI1R_AFFINITY_2_SHIFT)
+#define ICC_SGI1R_IRQ_ROUTING_MODE_BIT	40
+#define ICC_SGI1R_RS_SHIFT		44
+#define ICC_SGI1R_RS_MASK		(0xfULL << ICC_SGI1R_RS_SHIFT)
+#define ICC_SGI1R_AFFINITY_3_SHIFT	48
+#define ICC_SGI1R_AFFINITY_3_MASK	(0xffULL << ICC_SGI1R_AFFINITY_3_SHIFT)
+
+#include <asm/arch_gicv3.h>
+
+#ifndef __ASSEMBLY__
+
+/*
+ * We need a value to serve as a irq-type for LPIs. Choose one that will
+ * hopefully pique the interest of the reviewer.
+ */
+#define GIC_IRQ_TYPE_LPI		0xa110c8ed
+
+struct rdists {
+	struct {
+		void __iomem	*rd_base;
+		struct page	*pend_page;
+		phys_addr_t	phys_base;
+		bool		lpi_enabled;
+	} __percpu		*rdist;
+	phys_addr_t		prop_table_pa;
+	void			*prop_table_va;
+	u64			flags;
+	u32			gicd_typer;
+	bool			has_vlpis;
+	bool			has_direct_lpi;
+};
+
+struct irq_domain;
+struct fwnode_handle;
+int phytium_its_cpu_init(void);
+int phytium_its_init(struct fwnode_handle *handle, struct rdists *rdists,
+	     struct irq_domain *domain);
+
+static inline bool gic_enable_sre(void)
+{
+	u32 val;
+
+	val = gic_read_sre();
+	if (val & ICC_SRE_EL1_SRE)
+		return true;
+
+	val |= ICC_SRE_EL1_SRE;
+	gic_write_sre(val);
+	val = gic_read_sre();
+
+	return !!(val & ICC_SRE_EL1_SRE);
+}
+
+#endif
+
+#endif
